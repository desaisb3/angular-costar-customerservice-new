{"ast":null,"code":"// AWS SDK for JavaScript v2.553.0\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// License at https://sdk.amazonaws.com/js/BUNDLE_LICENSE.txt\n(function () {\n  function r(e, n, t) {\n    function o(i, f) {\n      if (!n[i]) {\n        if (!e[i]) {\n          var c = \"function\" == typeof require && require;\n          if (!f && c) return c(i, !0);\n          if (u) return u(i, !0);\n          var a = new Error(\"Cannot find module '\" + i + \"'\");\n          throw a.code = \"MODULE_NOT_FOUND\", a;\n        }\n\n        var p = n[i] = {\n          exports: {}\n        };\n        e[i][0].call(p.exports, function (r) {\n          var n = e[i][1][r];\n          return o(n || r);\n        }, p, p.exports, r, e, n, t);\n      }\n\n      return n[i].exports;\n    }\n\n    for (var u = \"function\" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);\n\n    return o;\n  }\n\n  return r;\n})()({\n  1: [function (require, module, exports) {\n    module.exports = {\n      \"version\": \"2.0\",\n      \"metadata\": {\n        \"apiVersion\": \"2014-06-30\",\n        \"endpointPrefix\": \"cognito-identity\",\n        \"jsonVersion\": \"1.1\",\n        \"protocol\": \"json\",\n        \"serviceFullName\": \"Amazon Cognito Identity\",\n        \"serviceId\": \"Cognito Identity\",\n        \"signatureVersion\": \"v4\",\n        \"targetPrefix\": \"AWSCognitoIdentityService\",\n        \"uid\": \"cognito-identity-2014-06-30\"\n      },\n      \"operations\": {\n        \"CreateIdentityPool\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"IdentityPoolName\", \"AllowUnauthenticatedIdentities\"],\n            \"members\": {\n              \"IdentityPoolName\": {},\n              \"AllowUnauthenticatedIdentities\": {\n                \"type\": \"boolean\"\n              },\n              \"SupportedLoginProviders\": {\n                \"shape\": \"S4\"\n              },\n              \"DeveloperProviderName\": {},\n              \"OpenIdConnectProviderARNs\": {\n                \"shape\": \"S8\"\n              },\n              \"CognitoIdentityProviders\": {\n                \"shape\": \"Sa\"\n              },\n              \"SamlProviderARNs\": {\n                \"shape\": \"Sf\"\n              },\n              \"IdentityPoolTags\": {\n                \"shape\": \"Sg\"\n              }\n            }\n          },\n          \"output\": {\n            \"shape\": \"Sj\"\n          }\n        },\n        \"DeleteIdentities\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"IdentityIdsToDelete\"],\n            \"members\": {\n              \"IdentityIdsToDelete\": {\n                \"type\": \"list\",\n                \"member\": {}\n              }\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {\n              \"UnprocessedIdentityIds\": {\n                \"type\": \"list\",\n                \"member\": {\n                  \"type\": \"structure\",\n                  \"members\": {\n                    \"IdentityId\": {},\n                    \"ErrorCode\": {}\n                  }\n                }\n              }\n            }\n          }\n        },\n        \"DeleteIdentityPool\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"IdentityPoolId\"],\n            \"members\": {\n              \"IdentityPoolId\": {}\n            }\n          }\n        },\n        \"DescribeIdentity\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"IdentityId\"],\n            \"members\": {\n              \"IdentityId\": {}\n            }\n          },\n          \"output\": {\n            \"shape\": \"Su\"\n          }\n        },\n        \"DescribeIdentityPool\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"IdentityPoolId\"],\n            \"members\": {\n              \"IdentityPoolId\": {}\n            }\n          },\n          \"output\": {\n            \"shape\": \"Sj\"\n          }\n        },\n        \"GetCredentialsForIdentity\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"IdentityId\"],\n            \"members\": {\n              \"IdentityId\": {},\n              \"Logins\": {\n                \"shape\": \"Sz\"\n              },\n              \"CustomRoleArn\": {}\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {\n              \"IdentityId\": {},\n              \"Credentials\": {\n                \"type\": \"structure\",\n                \"members\": {\n                  \"AccessKeyId\": {},\n                  \"SecretKey\": {},\n                  \"SessionToken\": {},\n                  \"Expiration\": {\n                    \"type\": \"timestamp\"\n                  }\n                }\n              }\n            }\n          }\n        },\n        \"GetId\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"IdentityPoolId\"],\n            \"members\": {\n              \"AccountId\": {},\n              \"IdentityPoolId\": {},\n              \"Logins\": {\n                \"shape\": \"Sz\"\n              }\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {\n              \"IdentityId\": {}\n            }\n          }\n        },\n        \"GetIdentityPoolRoles\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"IdentityPoolId\"],\n            \"members\": {\n              \"IdentityPoolId\": {}\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {\n              \"IdentityPoolId\": {},\n              \"Roles\": {\n                \"shape\": \"S1b\"\n              },\n              \"RoleMappings\": {\n                \"shape\": \"S1d\"\n              }\n            }\n          }\n        },\n        \"GetOpenIdToken\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"IdentityId\"],\n            \"members\": {\n              \"IdentityId\": {},\n              \"Logins\": {\n                \"shape\": \"Sz\"\n              }\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {\n              \"IdentityId\": {},\n              \"Token\": {}\n            }\n          }\n        },\n        \"GetOpenIdTokenForDeveloperIdentity\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"IdentityPoolId\", \"Logins\"],\n            \"members\": {\n              \"IdentityPoolId\": {},\n              \"IdentityId\": {},\n              \"Logins\": {\n                \"shape\": \"Sz\"\n              },\n              \"TokenDuration\": {\n                \"type\": \"long\"\n              }\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {\n              \"IdentityId\": {},\n              \"Token\": {}\n            }\n          }\n        },\n        \"ListIdentities\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"IdentityPoolId\", \"MaxResults\"],\n            \"members\": {\n              \"IdentityPoolId\": {},\n              \"MaxResults\": {\n                \"type\": \"integer\"\n              },\n              \"NextToken\": {},\n              \"HideDisabled\": {\n                \"type\": \"boolean\"\n              }\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {\n              \"IdentityPoolId\": {},\n              \"Identities\": {\n                \"type\": \"list\",\n                \"member\": {\n                  \"shape\": \"Su\"\n                }\n              },\n              \"NextToken\": {}\n            }\n          }\n        },\n        \"ListIdentityPools\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"MaxResults\"],\n            \"members\": {\n              \"MaxResults\": {\n                \"type\": \"integer\"\n              },\n              \"NextToken\": {}\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {\n              \"IdentityPools\": {\n                \"type\": \"list\",\n                \"member\": {\n                  \"type\": \"structure\",\n                  \"members\": {\n                    \"IdentityPoolId\": {},\n                    \"IdentityPoolName\": {}\n                  }\n                }\n              },\n              \"NextToken\": {}\n            }\n          }\n        },\n        \"ListTagsForResource\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"ResourceArn\"],\n            \"members\": {\n              \"ResourceArn\": {}\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {\n              \"Tags\": {\n                \"shape\": \"Sg\"\n              }\n            }\n          }\n        },\n        \"LookupDeveloperIdentity\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"IdentityPoolId\"],\n            \"members\": {\n              \"IdentityPoolId\": {},\n              \"IdentityId\": {},\n              \"DeveloperUserIdentifier\": {},\n              \"MaxResults\": {\n                \"type\": \"integer\"\n              },\n              \"NextToken\": {}\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {\n              \"IdentityId\": {},\n              \"DeveloperUserIdentifierList\": {\n                \"type\": \"list\",\n                \"member\": {}\n              },\n              \"NextToken\": {}\n            }\n          }\n        },\n        \"MergeDeveloperIdentities\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"SourceUserIdentifier\", \"DestinationUserIdentifier\", \"DeveloperProviderName\", \"IdentityPoolId\"],\n            \"members\": {\n              \"SourceUserIdentifier\": {},\n              \"DestinationUserIdentifier\": {},\n              \"DeveloperProviderName\": {},\n              \"IdentityPoolId\": {}\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {\n              \"IdentityId\": {}\n            }\n          }\n        },\n        \"SetIdentityPoolRoles\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"IdentityPoolId\", \"Roles\"],\n            \"members\": {\n              \"IdentityPoolId\": {},\n              \"Roles\": {\n                \"shape\": \"S1b\"\n              },\n              \"RoleMappings\": {\n                \"shape\": \"S1d\"\n              }\n            }\n          }\n        },\n        \"TagResource\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"ResourceArn\"],\n            \"members\": {\n              \"ResourceArn\": {},\n              \"Tags\": {\n                \"shape\": \"Sg\"\n              }\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {}\n          }\n        },\n        \"UnlinkDeveloperIdentity\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"IdentityId\", \"IdentityPoolId\", \"DeveloperProviderName\", \"DeveloperUserIdentifier\"],\n            \"members\": {\n              \"IdentityId\": {},\n              \"IdentityPoolId\": {},\n              \"DeveloperProviderName\": {},\n              \"DeveloperUserIdentifier\": {}\n            }\n          }\n        },\n        \"UnlinkIdentity\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"IdentityId\", \"Logins\", \"LoginsToRemove\"],\n            \"members\": {\n              \"IdentityId\": {},\n              \"Logins\": {\n                \"shape\": \"Sz\"\n              },\n              \"LoginsToRemove\": {\n                \"shape\": \"Sv\"\n              }\n            }\n          }\n        },\n        \"UntagResource\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"ResourceArn\"],\n            \"members\": {\n              \"ResourceArn\": {},\n              \"TagKeys\": {\n                \"type\": \"list\",\n                \"member\": {}\n              }\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {}\n          }\n        },\n        \"UpdateIdentityPool\": {\n          \"input\": {\n            \"shape\": \"Sj\"\n          },\n          \"output\": {\n            \"shape\": \"Sj\"\n          }\n        }\n      },\n      \"shapes\": {\n        \"S4\": {\n          \"type\": \"map\",\n          \"key\": {},\n          \"value\": {}\n        },\n        \"S8\": {\n          \"type\": \"list\",\n          \"member\": {}\n        },\n        \"Sa\": {\n          \"type\": \"list\",\n          \"member\": {\n            \"type\": \"structure\",\n            \"members\": {\n              \"ProviderName\": {},\n              \"ClientId\": {},\n              \"ServerSideTokenCheck\": {\n                \"type\": \"boolean\"\n              }\n            }\n          }\n        },\n        \"Sf\": {\n          \"type\": \"list\",\n          \"member\": {}\n        },\n        \"Sg\": {\n          \"type\": \"map\",\n          \"key\": {},\n          \"value\": {}\n        },\n        \"Sj\": {\n          \"type\": \"structure\",\n          \"required\": [\"IdentityPoolId\", \"IdentityPoolName\", \"AllowUnauthenticatedIdentities\"],\n          \"members\": {\n            \"IdentityPoolId\": {},\n            \"IdentityPoolName\": {},\n            \"AllowUnauthenticatedIdentities\": {\n              \"type\": \"boolean\"\n            },\n            \"SupportedLoginProviders\": {\n              \"shape\": \"S4\"\n            },\n            \"DeveloperProviderName\": {},\n            \"OpenIdConnectProviderARNs\": {\n              \"shape\": \"S8\"\n            },\n            \"CognitoIdentityProviders\": {\n              \"shape\": \"Sa\"\n            },\n            \"SamlProviderARNs\": {\n              \"shape\": \"Sf\"\n            },\n            \"IdentityPoolTags\": {\n              \"shape\": \"Sg\"\n            }\n          }\n        },\n        \"Su\": {\n          \"type\": \"structure\",\n          \"members\": {\n            \"IdentityId\": {},\n            \"Logins\": {\n              \"shape\": \"Sv\"\n            },\n            \"CreationDate\": {\n              \"type\": \"timestamp\"\n            },\n            \"LastModifiedDate\": {\n              \"type\": \"timestamp\"\n            }\n          }\n        },\n        \"Sv\": {\n          \"type\": \"list\",\n          \"member\": {}\n        },\n        \"Sz\": {\n          \"type\": \"map\",\n          \"key\": {},\n          \"value\": {}\n        },\n        \"S1b\": {\n          \"type\": \"map\",\n          \"key\": {},\n          \"value\": {}\n        },\n        \"S1d\": {\n          \"type\": \"map\",\n          \"key\": {},\n          \"value\": {\n            \"type\": \"structure\",\n            \"required\": [\"Type\"],\n            \"members\": {\n              \"Type\": {},\n              \"AmbiguousRoleResolution\": {},\n              \"RulesConfiguration\": {\n                \"type\": \"structure\",\n                \"required\": [\"Rules\"],\n                \"members\": {\n                  \"Rules\": {\n                    \"type\": \"list\",\n                    \"member\": {\n                      \"type\": \"structure\",\n                      \"required\": [\"Claim\", \"MatchType\", \"Value\", \"RoleARN\"],\n                      \"members\": {\n                        \"Claim\": {},\n                        \"MatchType\": {},\n                        \"Value\": {},\n                        \"RoleARN\": {}\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    };\n  }, {}],\n  2: [function (require, module, exports) {\n    module.exports = {\n      \"pagination\": {}\n    };\n  }, {}],\n  3: [function (require, module, exports) {\n    module.exports = {\n      \"version\": \"2.0\",\n      \"metadata\": {\n        \"apiVersion\": \"2017-02-15\",\n        \"endpointPrefix\": \"connect\",\n        \"jsonVersion\": \"1.0\",\n        \"protocol\": \"json\",\n        \"serviceAbbreviation\": \"Connect\",\n        \"serviceFullName\": \"AmazonConnectCTIService\",\n        \"signatureVersion\": \"\",\n        \"targetPrefix\": \"AmazonConnectCTIService\",\n        \"uid\": \"connect-2017-02-15\"\n      },\n      \"operations\": {\n        \"AcceptContact\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"authentication\", \"contactId\"],\n            \"members\": {\n              \"authentication\": {\n                \"shape\": \"S2\"\n              },\n              \"contactId\": {}\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {}\n          }\n        },\n        \"ClearContact\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"contactId\"],\n            \"members\": {\n              \"contactId\": {}\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {}\n          }\n        },\n        \"CompleteContact\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"contactId\"],\n            \"members\": {\n              \"contactId\": {}\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {}\n          }\n        },\n        \"ConferenceConnections\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"authentication\", \"contactId\"],\n            \"members\": {\n              \"authentication\": {\n                \"shape\": \"S2\"\n              },\n              \"contactId\": {}\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {}\n          }\n        },\n        \"CreateAdditionalConnection\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"authentication\", \"contactId\", \"endpoint\"],\n            \"members\": {\n              \"authentication\": {\n                \"shape\": \"S2\"\n              },\n              \"contactId\": {},\n              \"endpoint\": {\n                \"shape\": \"Se\"\n              }\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {}\n          }\n        },\n        \"CreateOutboundContact\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"authentication\", \"endpoint\"],\n            \"members\": {\n              \"authentication\": {\n                \"shape\": \"S2\"\n              },\n              \"endpoint\": {\n                \"shape\": \"Se\"\n              },\n              \"queueARN\": {}\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {}\n          }\n        },\n        \"CreateTaskContact\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"endpoint\", \"name\"],\n            \"members\": {\n              \"endpoint\": {\n                \"shape\": \"Se\"\n              },\n              \"previousContactId\": {},\n              \"name\": {},\n              \"description\": {},\n              \"references\": {\n                \"shape\": \"Sr\"\n              },\n              \"idempotencyToken\": {},\n              \"scheduledTime\": {\n                \"type\": \"long\"\n              }\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {\n              \"contactId\": {}\n            }\n          }\n        },\n        \"CreateTransport\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"transportType\", \"authentication\"],\n            \"members\": {\n              \"transportType\": {},\n              \"participantId\": {},\n              \"contactId\": {},\n              \"softphoneClientId\": {},\n              \"authentication\": {\n                \"shape\": \"S2\"\n              }\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {\n              \"webSocketTransport\": {\n                \"type\": \"structure\",\n                \"required\": [\"url\", \"transportLifeTimeInSeconds\"],\n                \"members\": {\n                  \"url\": {},\n                  \"transportLifeTimeInSeconds\": {\n                    \"type\": \"long\"\n                  },\n                  \"expiry\": {}\n                }\n              },\n              \"chatTokenTransport\": {\n                \"type\": \"structure\",\n                \"required\": [\"participantToken\", \"expiry\"],\n                \"members\": {\n                  \"participantToken\": {},\n                  \"expiry\": {}\n                }\n              },\n              \"softphoneTransport\": {\n                \"type\": \"structure\",\n                \"required\": [\"softphoneMediaConnections\"],\n                \"members\": {\n                  \"softphoneMediaConnections\": {\n                    \"type\": \"list\",\n                    \"member\": {\n                      \"type\": \"structure\",\n                      \"required\": [\"username\", \"credential\", \"urls\"],\n                      \"members\": {\n                        \"username\": {},\n                        \"credential\": {},\n                        \"urls\": {\n                          \"type\": \"list\",\n                          \"member\": {}\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        },\n        \"DestroyConnection\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"authentication\", \"contactId\", \"connectionId\"],\n            \"members\": {\n              \"authentication\": {\n                \"shape\": \"S2\"\n              },\n              \"contactId\": {},\n              \"connectionId\": {}\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {}\n          }\n        },\n        \"GetAgentConfiguration\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"authentication\"],\n            \"members\": {\n              \"authentication\": {\n                \"shape\": \"S2\"\n              }\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"required\": [\"configuration\"],\n            \"members\": {\n              \"configuration\": {\n                \"shape\": \"S1h\"\n              }\n            }\n          }\n        },\n        \"GetAgentPermissions\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"authentication\"],\n            \"members\": {\n              \"authentication\": {\n                \"shape\": \"S2\"\n              },\n              \"nextToken\": {},\n              \"maxResults\": {\n                \"type\": \"integer\"\n              }\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"required\": [\"permissions\"],\n            \"members\": {\n              \"permissions\": {\n                \"type\": \"list\",\n                \"member\": {}\n              },\n              \"nextToken\": {}\n            }\n          }\n        },\n        \"GetAgentSnapshot\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"authentication\"],\n            \"members\": {\n              \"authentication\": {\n                \"shape\": \"S2\"\n              },\n              \"nextToken\": {},\n              \"timeout\": {\n                \"type\": \"long\"\n              }\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"required\": [\"snapshot\", \"nextToken\"],\n            \"members\": {\n              \"snapshot\": {\n                \"type\": \"structure\",\n                \"required\": [\"state\", \"contacts\", \"snapshotTimestamp\"],\n                \"members\": {\n                  \"state\": {\n                    \"shape\": \"S20\"\n                  },\n                  \"nextState\": {\n                    \"shape\": \"S20\"\n                  },\n                  \"agentAvailabilityState\": {\n                    \"type\": \"structure\",\n                    \"members\": {\n                      \"state\": {},\n                      \"timeStamp\": {\n                        \"type\": \"timestamp\"\n                      }\n                    }\n                  },\n                  \"contacts\": {\n                    \"type\": \"list\",\n                    \"member\": {\n                      \"type\": \"structure\",\n                      \"required\": [\"contactId\", \"type\", \"state\", \"connections\", \"attributes\"],\n                      \"members\": {\n                        \"contactId\": {},\n                        \"initialContactId\": {},\n                        \"type\": {},\n                        \"state\": {\n                          \"type\": \"structure\",\n                          \"required\": [\"type\", \"timestamp\"],\n                          \"members\": {\n                            \"type\": {},\n                            \"timestamp\": {\n                              \"type\": \"timestamp\"\n                            }\n                          }\n                        },\n                        \"queue\": {\n                          \"shape\": \"Sk\"\n                        },\n                        \"queueTimestamp\": {\n                          \"type\": \"timestamp\"\n                        },\n                        \"connections\": {\n                          \"type\": \"list\",\n                          \"member\": {\n                            \"type\": \"structure\",\n                            \"required\": [\"connectionId\", \"state\", \"type\", \"initial\"],\n                            \"members\": {\n                              \"connectionId\": {},\n                              \"endpoint\": {\n                                \"shape\": \"Se\"\n                              },\n                              \"state\": {\n                                \"type\": \"structure\",\n                                \"required\": [\"type\", \"timestamp\"],\n                                \"members\": {\n                                  \"type\": {},\n                                  \"timestamp\": {\n                                    \"type\": \"timestamp\"\n                                  }\n                                }\n                              },\n                              \"type\": {},\n                              \"initial\": {\n                                \"type\": \"boolean\"\n                              },\n                              \"softphoneMediaInfo\": {\n                                \"type\": \"structure\",\n                                \"members\": {\n                                  \"callType\": {},\n                                  \"autoAccept\": {\n                                    \"type\": \"boolean\"\n                                  },\n                                  \"mediaLegContextToken\": {},\n                                  \"callContextToken\": {},\n                                  \"callConfigJson\": {}\n                                }\n                              },\n                              \"chatMediaInfo\": {\n                                \"type\": \"structure\",\n                                \"members\": {\n                                  \"chatAutoAccept\": {\n                                    \"type\": \"boolean\"\n                                  },\n                                  \"connectionData\": {},\n                                  \"customerName\": {}\n                                }\n                              },\n                              \"monitoringInfo\": {\n                                \"type\": \"structure\",\n                                \"members\": {\n                                  \"agent\": {\n                                    \"type\": \"structure\",\n                                    \"members\": {\n                                      \"agentName\": {}\n                                    }\n                                  },\n                                  \"joinTimeStamp\": {\n                                    \"type\": \"timestamp\"\n                                  }\n                                }\n                              },\n                              \"mute\": {\n                                \"type\": \"boolean\"\n                              }\n                            }\n                          }\n                        },\n                        \"attributes\": {\n                          \"type\": \"map\",\n                          \"key\": {},\n                          \"value\": {\n                            \"type\": \"structure\",\n                            \"required\": [\"name\"],\n                            \"members\": {\n                              \"name\": {},\n                              \"value\": {}\n                            }\n                          }\n                        },\n                        \"contactDuration\": {},\n                        \"name\": {},\n                        \"description\": {},\n                        \"references\": {\n                          \"shape\": \"Sr\"\n                        },\n                        \"initiationMethod\": {},\n                        \"contactFeatures\": {\n                          \"type\": \"structure\",\n                          \"members\": {\n                            \"attachmentsEnabled\": {\n                              \"type\": \"boolean\"\n                            }\n                          }\n                        }\n                      }\n                    }\n                  },\n                  \"snapshotTimestamp\": {\n                    \"type\": \"timestamp\"\n                  }\n                }\n              },\n              \"nextToken\": {}\n            }\n          }\n        },\n        \"GetAgentStates\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"authentication\"],\n            \"members\": {\n              \"authentication\": {\n                \"shape\": \"S2\"\n              },\n              \"nextToken\": {},\n              \"maxResults\": {\n                \"type\": \"integer\"\n              }\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"required\": [\"states\"],\n            \"members\": {\n              \"states\": {\n                \"type\": \"list\",\n                \"member\": {\n                  \"shape\": \"S20\"\n                }\n              },\n              \"nextToken\": {}\n            }\n          }\n        },\n        \"GetDialableCountryCodes\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"authentication\"],\n            \"members\": {\n              \"authentication\": {\n                \"shape\": \"S2\"\n              },\n              \"nextToken\": {},\n              \"maxResults\": {\n                \"type\": \"integer\"\n              }\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"required\": [\"countryCodes\"],\n            \"members\": {\n              \"countryCodes\": {\n                \"type\": \"list\",\n                \"member\": {}\n              },\n              \"nextToken\": {}\n            }\n          }\n        },\n        \"GetEndpoints\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"authentication\", \"queueARNs\"],\n            \"members\": {\n              \"authentication\": {\n                \"shape\": \"S2\"\n              },\n              \"queueARNs\": {\n                \"type\": \"list\",\n                \"member\": {}\n              },\n              \"nextToken\": {},\n              \"maxResults\": {\n                \"type\": \"integer\"\n              }\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {\n              \"endpoints\": {\n                \"type\": \"list\",\n                \"member\": {\n                  \"shape\": \"Se\"\n                }\n              },\n              \"nextToken\": {}\n            }\n          }\n        },\n        \"GetNewAuthToken\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"authentication\", \"refreshToken\"],\n            \"members\": {\n              \"authentication\": {\n                \"shape\": \"S2\"\n              },\n              \"refreshToken\": {}\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {\n              \"newAuthToken\": {},\n              \"expirationDateTime\": {\n                \"type\": \"timestamp\"\n              }\n            }\n          }\n        },\n        \"GetRoutingProfileQueues\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"authentication\", \"routingProfileARN\"],\n            \"members\": {\n              \"authentication\": {\n                \"shape\": \"S2\"\n              },\n              \"routingProfileARN\": {},\n              \"nextToken\": {},\n              \"maxResults\": {\n                \"type\": \"integer\"\n              }\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"required\": [\"queues\"],\n            \"members\": {\n              \"queues\": {\n                \"type\": \"list\",\n                \"member\": {\n                  \"shape\": \"Sk\"\n                }\n              },\n              \"nextToken\": {}\n            }\n          }\n        },\n        \"HoldConnection\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"authentication\", \"contactId\", \"connectionId\"],\n            \"members\": {\n              \"authentication\": {\n                \"shape\": \"S2\"\n              },\n              \"contactId\": {},\n              \"connectionId\": {}\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {}\n          }\n        },\n        \"MuteParticipant\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"authentication\", \"contactId\", \"connectionId\"],\n            \"members\": {\n              \"authentication\": {\n                \"shape\": \"S2\"\n              },\n              \"contactId\": {},\n              \"connectionId\": {}\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {}\n          }\n        },\n        \"NotifyContactIssue\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"authentication\", \"contactId\"],\n            \"members\": {\n              \"authentication\": {\n                \"shape\": \"S2\"\n              },\n              \"contactId\": {},\n              \"issueCode\": {},\n              \"description\": {},\n              \"clientLogs\": {}\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {}\n          }\n        },\n        \"PutAgentState\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"authentication\", \"state\"],\n            \"members\": {\n              \"authentication\": {\n                \"shape\": \"S2\"\n              },\n              \"state\": {\n                \"shape\": \"S20\"\n              },\n              \"enqueueNextState\": {\n                \"type\": \"boolean\"\n              }\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {}\n          }\n        },\n        \"RejectContact\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"contactId\"],\n            \"members\": {\n              \"contactId\": {}\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {}\n          }\n        },\n        \"ResumeConnection\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"authentication\", \"contactId\", \"connectionId\"],\n            \"members\": {\n              \"authentication\": {\n                \"shape\": \"S2\"\n              },\n              \"contactId\": {},\n              \"connectionId\": {}\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {}\n          }\n        },\n        \"SendClientLogs\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"authentication\", \"logEvents\"],\n            \"members\": {\n              \"authentication\": {\n                \"shape\": \"S2\"\n              },\n              \"logEvents\": {\n                \"type\": \"list\",\n                \"member\": {\n                  \"type\": \"structure\",\n                  \"members\": {\n                    \"timestamp\": {\n                      \"type\": \"timestamp\"\n                    },\n                    \"component\": {},\n                    \"message\": {}\n                  }\n                }\n              }\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {}\n          }\n        },\n        \"SendDigits\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"authentication\", \"contactId\", \"connectionId\", \"digits\"],\n            \"members\": {\n              \"authentication\": {\n                \"shape\": \"S2\"\n              },\n              \"contactId\": {},\n              \"connectionId\": {},\n              \"digits\": {}\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {}\n          }\n        },\n        \"SendSoftphoneCallMetrics\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"authentication\", \"contactId\", \"softphoneStreamStatistics\"],\n            \"members\": {\n              \"authentication\": {\n                \"shape\": \"S2\"\n              },\n              \"contactId\": {},\n              \"ccpVersion\": {},\n              \"softphoneStreamStatistics\": {\n                \"shape\": \"S3r\"\n              }\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {}\n          }\n        },\n        \"SendSoftphoneCallReport\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"authentication\", \"contactId\", \"report\"],\n            \"members\": {\n              \"authentication\": {\n                \"shape\": \"S2\"\n              },\n              \"contactId\": {},\n              \"ccpVersion\": {},\n              \"report\": {\n                \"type\": \"structure\",\n                \"members\": {\n                  \"callStartTime\": {\n                    \"type\": \"timestamp\"\n                  },\n                  \"callEndTime\": {\n                    \"type\": \"timestamp\"\n                  },\n                  \"softphoneStreamStatistics\": {\n                    \"shape\": \"S3r\"\n                  },\n                  \"gumTimeMillis\": {\n                    \"type\": \"long\"\n                  },\n                  \"initializationTimeMillis\": {\n                    \"type\": \"long\"\n                  },\n                  \"iceCollectionTimeMillis\": {\n                    \"type\": \"long\"\n                  },\n                  \"signallingConnectTimeMillis\": {\n                    \"type\": \"long\"\n                  },\n                  \"handshakeTimeMillis\": {\n                    \"type\": \"long\"\n                  },\n                  \"preTalkTimeMillis\": {\n                    \"type\": \"long\"\n                  },\n                  \"talkTimeMillis\": {\n                    \"type\": \"long\"\n                  },\n                  \"cleanupTimeMillis\": {\n                    \"type\": \"long\"\n                  },\n                  \"iceCollectionFailure\": {\n                    \"type\": \"boolean\"\n                  },\n                  \"signallingConnectionFailure\": {\n                    \"type\": \"boolean\"\n                  },\n                  \"handshakeFailure\": {\n                    \"type\": \"boolean\"\n                  },\n                  \"gumOtherFailure\": {\n                    \"type\": \"boolean\"\n                  },\n                  \"gumTimeoutFailure\": {\n                    \"type\": \"boolean\"\n                  },\n                  \"createOfferFailure\": {\n                    \"type\": \"boolean\"\n                  },\n                  \"setLocalDescriptionFailure\": {\n                    \"type\": \"boolean\"\n                  },\n                  \"userBusyFailure\": {\n                    \"type\": \"boolean\"\n                  },\n                  \"invalidRemoteSDPFailure\": {\n                    \"type\": \"boolean\"\n                  },\n                  \"noRemoteIceCandidateFailure\": {\n                    \"type\": \"boolean\"\n                  },\n                  \"setRemoteDescriptionFailure\": {\n                    \"type\": \"boolean\"\n                  }\n                }\n              }\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {}\n          }\n        },\n        \"ToggleActiveConnections\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"authentication\", \"contactId\", \"connectionId\"],\n            \"members\": {\n              \"authentication\": {\n                \"shape\": \"S2\"\n              },\n              \"contactId\": {},\n              \"connectionId\": {}\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {}\n          }\n        },\n        \"UnmuteParticipant\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"authentication\", \"contactId\", \"connectionId\"],\n            \"members\": {\n              \"authentication\": {\n                \"shape\": \"S2\"\n              },\n              \"contactId\": {},\n              \"connectionId\": {}\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {}\n          }\n        },\n        \"UpdateAgentConfiguration\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"authentication\", \"configuration\"],\n            \"members\": {\n              \"authentication\": {\n                \"shape\": \"S2\"\n              },\n              \"configuration\": {\n                \"shape\": \"S1h\"\n              }\n            }\n          },\n          \"output\": {\n            \"type\": \"structure\",\n            \"members\": {}\n          }\n        }\n      },\n      \"shapes\": {\n        \"S2\": {\n          \"type\": \"structure\",\n          \"members\": {\n            \"agentARN\": {},\n            \"authToken\": {}\n          }\n        },\n        \"Se\": {\n          \"type\": \"structure\",\n          \"required\": [\"type\"],\n          \"members\": {\n            \"endpointARN\": {},\n            \"type\": {},\n            \"name\": {},\n            \"phoneNumber\": {},\n            \"agentLogin\": {},\n            \"queue\": {\n              \"shape\": \"Sk\"\n            }\n          }\n        },\n        \"Sk\": {\n          \"type\": \"structure\",\n          \"members\": {\n            \"queueARN\": {},\n            \"name\": {}\n          }\n        },\n        \"Sr\": {\n          \"type\": \"map\",\n          \"key\": {},\n          \"value\": {\n            \"type\": \"structure\",\n            \"required\": [\"value\", \"type\"],\n            \"members\": {\n              \"value\": {},\n              \"type\": {}\n            }\n          }\n        },\n        \"S1h\": {\n          \"type\": \"structure\",\n          \"required\": [\"name\", \"softphoneEnabled\", \"softphoneAutoAccept\", \"extension\", \"routingProfile\"],\n          \"members\": {\n            \"name\": {},\n            \"username\": {},\n            \"softphoneEnabled\": {\n              \"type\": \"boolean\"\n            },\n            \"softphoneAutoAccept\": {\n              \"type\": \"boolean\"\n            },\n            \"extension\": {},\n            \"routingProfile\": {\n              \"type\": \"structure\",\n              \"members\": {\n                \"name\": {},\n                \"routingProfileARN\": {},\n                \"defaultOutboundQueue\": {\n                  \"shape\": \"Sk\"\n                },\n                \"channelConcurrencyMap\": {\n                  \"type\": \"map\",\n                  \"key\": {},\n                  \"value\": {\n                    \"type\": \"long\"\n                  }\n                }\n              }\n            },\n            \"agentPreferences\": {\n              \"type\": \"map\",\n              \"key\": {},\n              \"value\": {}\n            }\n          }\n        },\n        \"S20\": {\n          \"type\": \"structure\",\n          \"required\": [\"type\", \"name\"],\n          \"members\": {\n            \"agentStateARN\": {},\n            \"type\": {},\n            \"name\": {},\n            \"startTimestamp\": {\n              \"type\": \"timestamp\"\n            }\n          }\n        },\n        \"S3r\": {\n          \"type\": \"list\",\n          \"member\": {\n            \"type\": \"structure\",\n            \"members\": {\n              \"timestamp\": {\n                \"type\": \"timestamp\"\n              },\n              \"softphoneStreamType\": {},\n              \"packetCount\": {\n                \"type\": \"long\"\n              },\n              \"packetsLost\": {\n                \"type\": \"long\"\n              },\n              \"audioLevel\": {\n                \"type\": \"double\"\n              },\n              \"jitterBufferMillis\": {\n                \"type\": \"long\"\n              },\n              \"roundTripTimeMillis\": {\n                \"type\": \"long\"\n              }\n            }\n          }\n        }\n      }\n    };\n  }, {}],\n  4: [function (require, module, exports) {\n    module.exports = {\n      \"acm\": {\n        \"name\": \"ACM\",\n        \"cors\": true\n      },\n      \"apigateway\": {\n        \"name\": \"APIGateway\",\n        \"cors\": true\n      },\n      \"applicationautoscaling\": {\n        \"prefix\": \"application-autoscaling\",\n        \"name\": \"ApplicationAutoScaling\",\n        \"cors\": true\n      },\n      \"appstream\": {\n        \"name\": \"AppStream\"\n      },\n      \"autoscaling\": {\n        \"name\": \"AutoScaling\",\n        \"cors\": true\n      },\n      \"batch\": {\n        \"name\": \"Batch\"\n      },\n      \"budgets\": {\n        \"name\": \"Budgets\"\n      },\n      \"clouddirectory\": {\n        \"name\": \"CloudDirectory\",\n        \"versions\": [\"2016-05-10*\"]\n      },\n      \"cloudformation\": {\n        \"name\": \"CloudFormation\",\n        \"cors\": true\n      },\n      \"cloudfront\": {\n        \"name\": \"CloudFront\",\n        \"versions\": [\"2013-05-12*\", \"2013-11-11*\", \"2014-05-31*\", \"2014-10-21*\", \"2014-11-06*\", \"2015-04-17*\", \"2015-07-27*\", \"2015-09-17*\", \"2016-01-13*\", \"2016-01-28*\", \"2016-08-01*\", \"2016-08-20*\", \"2016-09-07*\", \"2016-09-29*\", \"2016-11-25*\", \"2017-03-25*\", \"2017-10-30*\", \"2018-06-18*\", \"2018-11-05*\"],\n        \"cors\": true\n      },\n      \"cloudhsm\": {\n        \"name\": \"CloudHSM\",\n        \"cors\": true\n      },\n      \"cloudsearch\": {\n        \"name\": \"CloudSearch\"\n      },\n      \"cloudsearchdomain\": {\n        \"name\": \"CloudSearchDomain\"\n      },\n      \"cloudtrail\": {\n        \"name\": \"CloudTrail\",\n        \"cors\": true\n      },\n      \"cloudwatch\": {\n        \"prefix\": \"monitoring\",\n        \"name\": \"CloudWatch\",\n        \"cors\": true\n      },\n      \"cloudwatchevents\": {\n        \"prefix\": \"events\",\n        \"name\": \"CloudWatchEvents\",\n        \"versions\": [\"2014-02-03*\"],\n        \"cors\": true\n      },\n      \"cloudwatchlogs\": {\n        \"prefix\": \"logs\",\n        \"name\": \"CloudWatchLogs\",\n        \"cors\": true\n      },\n      \"codebuild\": {\n        \"name\": \"CodeBuild\",\n        \"cors\": true\n      },\n      \"codecommit\": {\n        \"name\": \"CodeCommit\",\n        \"cors\": true\n      },\n      \"codedeploy\": {\n        \"name\": \"CodeDeploy\",\n        \"cors\": true\n      },\n      \"codepipeline\": {\n        \"name\": \"CodePipeline\",\n        \"cors\": true\n      },\n      \"cognitoidentity\": {\n        \"prefix\": \"cognito-identity\",\n        \"name\": \"CognitoIdentity\",\n        \"cors\": true\n      },\n      \"cognitoidentityserviceprovider\": {\n        \"prefix\": \"cognito-idp\",\n        \"name\": \"CognitoIdentityServiceProvider\",\n        \"cors\": true\n      },\n      \"cognitosync\": {\n        \"prefix\": \"cognito-sync\",\n        \"name\": \"CognitoSync\",\n        \"cors\": true\n      },\n      \"configservice\": {\n        \"prefix\": \"config\",\n        \"name\": \"ConfigService\",\n        \"cors\": true\n      },\n      \"connect\": {\n        \"name\": \"Connect\",\n        \"cors\": true\n      },\n      \"cur\": {\n        \"name\": \"CUR\",\n        \"cors\": true\n      },\n      \"datapipeline\": {\n        \"name\": \"DataPipeline\"\n      },\n      \"devicefarm\": {\n        \"name\": \"DeviceFarm\",\n        \"cors\": true\n      },\n      \"directconnect\": {\n        \"name\": \"DirectConnect\",\n        \"cors\": true\n      },\n      \"directoryservice\": {\n        \"prefix\": \"ds\",\n        \"name\": \"DirectoryService\"\n      },\n      \"discovery\": {\n        \"name\": \"Discovery\"\n      },\n      \"dms\": {\n        \"name\": \"DMS\"\n      },\n      \"dynamodb\": {\n        \"name\": \"DynamoDB\",\n        \"cors\": true\n      },\n      \"dynamodbstreams\": {\n        \"prefix\": \"streams.dynamodb\",\n        \"name\": \"DynamoDBStreams\",\n        \"cors\": true\n      },\n      \"ec2\": {\n        \"name\": \"EC2\",\n        \"versions\": [\"2013-06-15*\", \"2013-10-15*\", \"2014-02-01*\", \"2014-05-01*\", \"2014-06-15*\", \"2014-09-01*\", \"2014-10-01*\", \"2015-03-01*\", \"2015-04-15*\", \"2015-10-01*\", \"2016-04-01*\", \"2016-09-15*\"],\n        \"cors\": true\n      },\n      \"ecr\": {\n        \"name\": \"ECR\",\n        \"cors\": true\n      },\n      \"ecs\": {\n        \"name\": \"ECS\",\n        \"cors\": true\n      },\n      \"efs\": {\n        \"prefix\": \"elasticfilesystem\",\n        \"name\": \"EFS\",\n        \"cors\": true\n      },\n      \"elasticache\": {\n        \"name\": \"ElastiCache\",\n        \"versions\": [\"2012-11-15*\", \"2014-03-24*\", \"2014-07-15*\", \"2014-09-30*\"],\n        \"cors\": true\n      },\n      \"elasticbeanstalk\": {\n        \"name\": \"ElasticBeanstalk\",\n        \"cors\": true\n      },\n      \"elb\": {\n        \"prefix\": \"elasticloadbalancing\",\n        \"name\": \"ELB\",\n        \"cors\": true\n      },\n      \"elbv2\": {\n        \"prefix\": \"elasticloadbalancingv2\",\n        \"name\": \"ELBv2\",\n        \"cors\": true\n      },\n      \"emr\": {\n        \"prefix\": \"elasticmapreduce\",\n        \"name\": \"EMR\",\n        \"cors\": true\n      },\n      \"es\": {\n        \"name\": \"ES\"\n      },\n      \"elastictranscoder\": {\n        \"name\": \"ElasticTranscoder\",\n        \"cors\": true\n      },\n      \"firehose\": {\n        \"name\": \"Firehose\",\n        \"cors\": true\n      },\n      \"gamelift\": {\n        \"name\": \"GameLift\",\n        \"cors\": true\n      },\n      \"glacier\": {\n        \"name\": \"Glacier\"\n      },\n      \"health\": {\n        \"name\": \"Health\"\n      },\n      \"iam\": {\n        \"name\": \"IAM\",\n        \"cors\": true\n      },\n      \"importexport\": {\n        \"name\": \"ImportExport\"\n      },\n      \"inspector\": {\n        \"name\": \"Inspector\",\n        \"versions\": [\"2015-08-18*\"],\n        \"cors\": true\n      },\n      \"iot\": {\n        \"name\": \"Iot\",\n        \"cors\": true\n      },\n      \"iotdata\": {\n        \"prefix\": \"iot-data\",\n        \"name\": \"IotData\",\n        \"cors\": true\n      },\n      \"kinesis\": {\n        \"name\": \"Kinesis\",\n        \"cors\": true\n      },\n      \"kinesisanalytics\": {\n        \"name\": \"KinesisAnalytics\"\n      },\n      \"kms\": {\n        \"name\": \"KMS\",\n        \"cors\": true\n      },\n      \"lambda\": {\n        \"name\": \"Lambda\",\n        \"cors\": true\n      },\n      \"lexruntime\": {\n        \"prefix\": \"runtime.lex\",\n        \"name\": \"LexRuntime\",\n        \"cors\": true\n      },\n      \"lightsail\": {\n        \"name\": \"Lightsail\"\n      },\n      \"machinelearning\": {\n        \"name\": \"MachineLearning\",\n        \"cors\": true\n      },\n      \"marketplacecommerceanalytics\": {\n        \"name\": \"MarketplaceCommerceAnalytics\",\n        \"cors\": true\n      },\n      \"marketplacemetering\": {\n        \"prefix\": \"meteringmarketplace\",\n        \"name\": \"MarketplaceMetering\"\n      },\n      \"mturk\": {\n        \"prefix\": \"mturk-requester\",\n        \"name\": \"MTurk\",\n        \"cors\": true\n      },\n      \"mobileanalytics\": {\n        \"name\": \"MobileAnalytics\",\n        \"cors\": true\n      },\n      \"opsworks\": {\n        \"name\": \"OpsWorks\",\n        \"cors\": true\n      },\n      \"opsworkscm\": {\n        \"name\": \"OpsWorksCM\"\n      },\n      \"organizations\": {\n        \"name\": \"Organizations\"\n      },\n      \"pinpoint\": {\n        \"name\": \"Pinpoint\"\n      },\n      \"polly\": {\n        \"name\": \"Polly\",\n        \"cors\": true\n      },\n      \"rds\": {\n        \"name\": \"RDS\",\n        \"versions\": [\"2014-09-01*\"],\n        \"cors\": true\n      },\n      \"redshift\": {\n        \"name\": \"Redshift\",\n        \"cors\": true\n      },\n      \"rekognition\": {\n        \"name\": \"Rekognition\",\n        \"cors\": true\n      },\n      \"resourcegroupstaggingapi\": {\n        \"name\": \"ResourceGroupsTaggingAPI\"\n      },\n      \"route53\": {\n        \"name\": \"Route53\",\n        \"cors\": true\n      },\n      \"route53domains\": {\n        \"name\": \"Route53Domains\",\n        \"cors\": true\n      },\n      \"s3\": {\n        \"name\": \"S3\",\n        \"dualstackAvailable\": true,\n        \"cors\": true\n      },\n      \"s3control\": {\n        \"name\": \"S3Control\",\n        \"dualstackAvailable\": true\n      },\n      \"servicecatalog\": {\n        \"name\": \"ServiceCatalog\",\n        \"cors\": true\n      },\n      \"ses\": {\n        \"prefix\": \"email\",\n        \"name\": \"SES\",\n        \"cors\": true\n      },\n      \"shield\": {\n        \"name\": \"Shield\"\n      },\n      \"simpledb\": {\n        \"prefix\": \"sdb\",\n        \"name\": \"SimpleDB\"\n      },\n      \"sms\": {\n        \"name\": \"SMS\"\n      },\n      \"snowball\": {\n        \"name\": \"Snowball\"\n      },\n      \"sns\": {\n        \"name\": \"SNS\",\n        \"cors\": true\n      },\n      \"sqs\": {\n        \"name\": \"SQS\",\n        \"cors\": true\n      },\n      \"ssm\": {\n        \"name\": \"SSM\",\n        \"cors\": true\n      },\n      \"storagegateway\": {\n        \"name\": \"StorageGateway\",\n        \"cors\": true\n      },\n      \"stepfunctions\": {\n        \"prefix\": \"states\",\n        \"name\": \"StepFunctions\"\n      },\n      \"sts\": {\n        \"name\": \"STS\",\n        \"cors\": true\n      },\n      \"support\": {\n        \"name\": \"Support\"\n      },\n      \"swf\": {\n        \"name\": \"SWF\"\n      },\n      \"xray\": {\n        \"name\": \"XRay\",\n        \"cors\": true\n      },\n      \"waf\": {\n        \"name\": \"WAF\",\n        \"cors\": true\n      },\n      \"wafregional\": {\n        \"prefix\": \"waf-regional\",\n        \"name\": \"WAFRegional\"\n      },\n      \"workdocs\": {\n        \"name\": \"WorkDocs\",\n        \"cors\": true\n      },\n      \"workspaces\": {\n        \"name\": \"WorkSpaces\"\n      },\n      \"codestar\": {\n        \"name\": \"CodeStar\"\n      },\n      \"lexmodelbuildingservice\": {\n        \"prefix\": \"lex-models\",\n        \"name\": \"LexModelBuildingService\",\n        \"cors\": true\n      },\n      \"marketplaceentitlementservice\": {\n        \"prefix\": \"entitlement.marketplace\",\n        \"name\": \"MarketplaceEntitlementService\"\n      },\n      \"athena\": {\n        \"name\": \"Athena\"\n      },\n      \"greengrass\": {\n        \"name\": \"Greengrass\"\n      },\n      \"dax\": {\n        \"name\": \"DAX\"\n      },\n      \"migrationhub\": {\n        \"prefix\": \"AWSMigrationHub\",\n        \"name\": \"MigrationHub\"\n      },\n      \"cloudhsmv2\": {\n        \"name\": \"CloudHSMV2\"\n      },\n      \"glue\": {\n        \"name\": \"Glue\"\n      },\n      \"mobile\": {\n        \"name\": \"Mobile\"\n      },\n      \"pricing\": {\n        \"name\": \"Pricing\",\n        \"cors\": true\n      },\n      \"costexplorer\": {\n        \"prefix\": \"ce\",\n        \"name\": \"CostExplorer\",\n        \"cors\": true\n      },\n      \"mediaconvert\": {\n        \"name\": \"MediaConvert\"\n      },\n      \"medialive\": {\n        \"name\": \"MediaLive\"\n      },\n      \"mediapackage\": {\n        \"name\": \"MediaPackage\"\n      },\n      \"mediastore\": {\n        \"name\": \"MediaStore\"\n      },\n      \"mediastoredata\": {\n        \"prefix\": \"mediastore-data\",\n        \"name\": \"MediaStoreData\",\n        \"cors\": true\n      },\n      \"appsync\": {\n        \"name\": \"AppSync\"\n      },\n      \"guardduty\": {\n        \"name\": \"GuardDuty\"\n      },\n      \"mq\": {\n        \"name\": \"MQ\"\n      },\n      \"comprehend\": {\n        \"name\": \"Comprehend\",\n        \"cors\": true\n      },\n      \"iotjobsdataplane\": {\n        \"prefix\": \"iot-jobs-data\",\n        \"name\": \"IoTJobsDataPlane\"\n      },\n      \"kinesisvideoarchivedmedia\": {\n        \"prefix\": \"kinesis-video-archived-media\",\n        \"name\": \"KinesisVideoArchivedMedia\",\n        \"cors\": true\n      },\n      \"kinesisvideomedia\": {\n        \"prefix\": \"kinesis-video-media\",\n        \"name\": \"KinesisVideoMedia\",\n        \"cors\": true\n      },\n      \"kinesisvideo\": {\n        \"name\": \"KinesisVideo\",\n        \"cors\": true\n      },\n      \"sagemakerruntime\": {\n        \"prefix\": \"runtime.sagemaker\",\n        \"name\": \"SageMakerRuntime\"\n      },\n      \"sagemaker\": {\n        \"name\": \"SageMaker\"\n      },\n      \"translate\": {\n        \"name\": \"Translate\",\n        \"cors\": true\n      },\n      \"resourcegroups\": {\n        \"prefix\": \"resource-groups\",\n        \"name\": \"ResourceGroups\",\n        \"cors\": true\n      },\n      \"alexaforbusiness\": {\n        \"name\": \"AlexaForBusiness\"\n      },\n      \"cloud9\": {\n        \"name\": \"Cloud9\"\n      },\n      \"serverlessapplicationrepository\": {\n        \"prefix\": \"serverlessrepo\",\n        \"name\": \"ServerlessApplicationRepository\"\n      },\n      \"servicediscovery\": {\n        \"name\": \"ServiceDiscovery\"\n      },\n      \"workmail\": {\n        \"name\": \"WorkMail\"\n      },\n      \"autoscalingplans\": {\n        \"prefix\": \"autoscaling-plans\",\n        \"name\": \"AutoScalingPlans\"\n      },\n      \"transcribeservice\": {\n        \"prefix\": \"transcribe\",\n        \"name\": \"TranscribeService\"\n      },\n      \"acmpca\": {\n        \"prefix\": \"acm-pca\",\n        \"name\": \"ACMPCA\"\n      },\n      \"fms\": {\n        \"name\": \"FMS\"\n      },\n      \"secretsmanager\": {\n        \"name\": \"SecretsManager\",\n        \"cors\": true\n      },\n      \"iotanalytics\": {\n        \"name\": \"IoTAnalytics\",\n        \"cors\": true\n      },\n      \"iot1clickdevicesservice\": {\n        \"prefix\": \"iot1click-devices\",\n        \"name\": \"IoT1ClickDevicesService\"\n      },\n      \"iot1clickprojects\": {\n        \"prefix\": \"iot1click-projects\",\n        \"name\": \"IoT1ClickProjects\"\n      },\n      \"pi\": {\n        \"name\": \"PI\"\n      },\n      \"neptune\": {\n        \"name\": \"Neptune\"\n      },\n      \"mediatailor\": {\n        \"name\": \"MediaTailor\"\n      },\n      \"eks\": {\n        \"name\": \"EKS\"\n      },\n      \"macie\": {\n        \"name\": \"Macie\"\n      },\n      \"dlm\": {\n        \"name\": \"DLM\"\n      },\n      \"signer\": {\n        \"name\": \"Signer\"\n      },\n      \"chime\": {\n        \"name\": \"Chime\"\n      },\n      \"pinpointemail\": {\n        \"prefix\": \"pinpoint-email\",\n        \"name\": \"PinpointEmail\"\n      },\n      \"ram\": {\n        \"name\": \"RAM\"\n      },\n      \"route53resolver\": {\n        \"name\": \"Route53Resolver\"\n      },\n      \"pinpointsmsvoice\": {\n        \"prefix\": \"sms-voice\",\n        \"name\": \"PinpointSMSVoice\"\n      },\n      \"quicksight\": {\n        \"name\": \"QuickSight\"\n      },\n      \"rdsdataservice\": {\n        \"prefix\": \"rds-data\",\n        \"name\": \"RDSDataService\"\n      },\n      \"amplify\": {\n        \"name\": \"Amplify\"\n      },\n      \"datasync\": {\n        \"name\": \"DataSync\"\n      },\n      \"robomaker\": {\n        \"name\": \"RoboMaker\"\n      },\n      \"transfer\": {\n        \"name\": \"Transfer\"\n      },\n      \"globalaccelerator\": {\n        \"name\": \"GlobalAccelerator\"\n      },\n      \"comprehendmedical\": {\n        \"name\": \"ComprehendMedical\",\n        \"cors\": true\n      },\n      \"kinesisanalyticsv2\": {\n        \"name\": \"KinesisAnalyticsV2\"\n      },\n      \"mediaconnect\": {\n        \"name\": \"MediaConnect\"\n      },\n      \"fsx\": {\n        \"name\": \"FSx\"\n      },\n      \"securityhub\": {\n        \"name\": \"SecurityHub\"\n      },\n      \"appmesh\": {\n        \"name\": \"AppMesh\",\n        \"versions\": [\"2018-10-01*\"]\n      },\n      \"licensemanager\": {\n        \"prefix\": \"license-manager\",\n        \"name\": \"LicenseManager\"\n      },\n      \"kafka\": {\n        \"name\": \"Kafka\"\n      },\n      \"apigatewaymanagementapi\": {\n        \"name\": \"ApiGatewayManagementApi\"\n      },\n      \"apigatewayv2\": {\n        \"name\": \"ApiGatewayV2\"\n      },\n      \"docdb\": {\n        \"name\": \"DocDB\"\n      },\n      \"backup\": {\n        \"name\": \"Backup\"\n      },\n      \"worklink\": {\n        \"name\": \"WorkLink\"\n      },\n      \"textract\": {\n        \"name\": \"Textract\"\n      },\n      \"managedblockchain\": {\n        \"name\": \"ManagedBlockchain\"\n      },\n      \"mediapackagevod\": {\n        \"prefix\": \"mediapackage-vod\",\n        \"name\": \"MediaPackageVod\"\n      },\n      \"groundstation\": {\n        \"name\": \"GroundStation\"\n      },\n      \"iotthingsgraph\": {\n        \"name\": \"IoTThingsGraph\"\n      },\n      \"iotevents\": {\n        \"name\": \"IoTEvents\"\n      },\n      \"ioteventsdata\": {\n        \"prefix\": \"iotevents-data\",\n        \"name\": \"IoTEventsData\"\n      },\n      \"personalize\": {\n        \"name\": \"Personalize\",\n        \"cors\": true\n      },\n      \"personalizeevents\": {\n        \"prefix\": \"personalize-events\",\n        \"name\": \"PersonalizeEvents\",\n        \"cors\": true\n      },\n      \"personalizeruntime\": {\n        \"prefix\": \"personalize-runtime\",\n        \"name\": \"PersonalizeRuntime\",\n        \"cors\": true\n      },\n      \"applicationinsights\": {\n        \"prefix\": \"application-insights\",\n        \"name\": \"ApplicationInsights\"\n      },\n      \"servicequotas\": {\n        \"prefix\": \"service-quotas\",\n        \"name\": \"ServiceQuotas\"\n      },\n      \"ec2instanceconnect\": {\n        \"prefix\": \"ec2-instance-connect\",\n        \"name\": \"EC2InstanceConnect\"\n      },\n      \"eventbridge\": {\n        \"name\": \"EventBridge\"\n      },\n      \"lakeformation\": {\n        \"name\": \"LakeFormation\"\n      },\n      \"forecastservice\": {\n        \"prefix\": \"forecast\",\n        \"name\": \"ForecastService\",\n        \"cors\": true\n      },\n      \"forecastqueryservice\": {\n        \"prefix\": \"forecastquery\",\n        \"name\": \"ForecastQueryService\",\n        \"cors\": true\n      },\n      \"qldb\": {\n        \"name\": \"QLDB\"\n      },\n      \"qldbsession\": {\n        \"prefix\": \"qldb-session\",\n        \"name\": \"QLDBSession\"\n      },\n      \"workmailmessageflow\": {\n        \"name\": \"WorkMailMessageFlow\"\n      }\n    };\n  }, {}],\n  5: [function (require, module, exports) {\n    module.exports = {\n      \"version\": \"2.0\",\n      \"metadata\": {\n        \"apiVersion\": \"2011-06-15\",\n        \"endpointPrefix\": \"sts\",\n        \"globalEndpoint\": \"sts.amazonaws.com\",\n        \"protocol\": \"query\",\n        \"serviceAbbreviation\": \"AWS STS\",\n        \"serviceFullName\": \"AWS Security Token Service\",\n        \"serviceId\": \"STS\",\n        \"signatureVersion\": \"v4\",\n        \"uid\": \"sts-2011-06-15\",\n        \"xmlNamespace\": \"https://sts.amazonaws.com/doc/2011-06-15/\"\n      },\n      \"operations\": {\n        \"AssumeRole\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"RoleArn\", \"RoleSessionName\"],\n            \"members\": {\n              \"RoleArn\": {},\n              \"RoleSessionName\": {},\n              \"PolicyArns\": {\n                \"shape\": \"S4\"\n              },\n              \"Policy\": {},\n              \"DurationSeconds\": {\n                \"type\": \"integer\"\n              },\n              \"ExternalId\": {},\n              \"SerialNumber\": {},\n              \"TokenCode\": {}\n            }\n          },\n          \"output\": {\n            \"resultWrapper\": \"AssumeRoleResult\",\n            \"type\": \"structure\",\n            \"members\": {\n              \"Credentials\": {\n                \"shape\": \"Sc\"\n              },\n              \"AssumedRoleUser\": {\n                \"shape\": \"Sh\"\n              },\n              \"PackedPolicySize\": {\n                \"type\": \"integer\"\n              }\n            }\n          }\n        },\n        \"AssumeRoleWithSAML\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"RoleArn\", \"PrincipalArn\", \"SAMLAssertion\"],\n            \"members\": {\n              \"RoleArn\": {},\n              \"PrincipalArn\": {},\n              \"SAMLAssertion\": {},\n              \"PolicyArns\": {\n                \"shape\": \"S4\"\n              },\n              \"Policy\": {},\n              \"DurationSeconds\": {\n                \"type\": \"integer\"\n              }\n            }\n          },\n          \"output\": {\n            \"resultWrapper\": \"AssumeRoleWithSAMLResult\",\n            \"type\": \"structure\",\n            \"members\": {\n              \"Credentials\": {\n                \"shape\": \"Sc\"\n              },\n              \"AssumedRoleUser\": {\n                \"shape\": \"Sh\"\n              },\n              \"PackedPolicySize\": {\n                \"type\": \"integer\"\n              },\n              \"Subject\": {},\n              \"SubjectType\": {},\n              \"Issuer\": {},\n              \"Audience\": {},\n              \"NameQualifier\": {}\n            }\n          }\n        },\n        \"AssumeRoleWithWebIdentity\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"RoleArn\", \"RoleSessionName\", \"WebIdentityToken\"],\n            \"members\": {\n              \"RoleArn\": {},\n              \"RoleSessionName\": {},\n              \"WebIdentityToken\": {},\n              \"ProviderId\": {},\n              \"PolicyArns\": {\n                \"shape\": \"S4\"\n              },\n              \"Policy\": {},\n              \"DurationSeconds\": {\n                \"type\": \"integer\"\n              }\n            }\n          },\n          \"output\": {\n            \"resultWrapper\": \"AssumeRoleWithWebIdentityResult\",\n            \"type\": \"structure\",\n            \"members\": {\n              \"Credentials\": {\n                \"shape\": \"Sc\"\n              },\n              \"SubjectFromWebIdentityToken\": {},\n              \"AssumedRoleUser\": {\n                \"shape\": \"Sh\"\n              },\n              \"PackedPolicySize\": {\n                \"type\": \"integer\"\n              },\n              \"Provider\": {},\n              \"Audience\": {}\n            }\n          }\n        },\n        \"DecodeAuthorizationMessage\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"EncodedMessage\"],\n            \"members\": {\n              \"EncodedMessage\": {}\n            }\n          },\n          \"output\": {\n            \"resultWrapper\": \"DecodeAuthorizationMessageResult\",\n            \"type\": \"structure\",\n            \"members\": {\n              \"DecodedMessage\": {}\n            }\n          }\n        },\n        \"GetAccessKeyInfo\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"AccessKeyId\"],\n            \"members\": {\n              \"AccessKeyId\": {}\n            }\n          },\n          \"output\": {\n            \"resultWrapper\": \"GetAccessKeyInfoResult\",\n            \"type\": \"structure\",\n            \"members\": {\n              \"Account\": {}\n            }\n          }\n        },\n        \"GetCallerIdentity\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"members\": {}\n          },\n          \"output\": {\n            \"resultWrapper\": \"GetCallerIdentityResult\",\n            \"type\": \"structure\",\n            \"members\": {\n              \"UserId\": {},\n              \"Account\": {},\n              \"Arn\": {}\n            }\n          }\n        },\n        \"GetFederationToken\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"required\": [\"Name\"],\n            \"members\": {\n              \"Name\": {},\n              \"Policy\": {},\n              \"PolicyArns\": {\n                \"shape\": \"S4\"\n              },\n              \"DurationSeconds\": {\n                \"type\": \"integer\"\n              }\n            }\n          },\n          \"output\": {\n            \"resultWrapper\": \"GetFederationTokenResult\",\n            \"type\": \"structure\",\n            \"members\": {\n              \"Credentials\": {\n                \"shape\": \"Sc\"\n              },\n              \"FederatedUser\": {\n                \"type\": \"structure\",\n                \"required\": [\"FederatedUserId\", \"Arn\"],\n                \"members\": {\n                  \"FederatedUserId\": {},\n                  \"Arn\": {}\n                }\n              },\n              \"PackedPolicySize\": {\n                \"type\": \"integer\"\n              }\n            }\n          }\n        },\n        \"GetSessionToken\": {\n          \"input\": {\n            \"type\": \"structure\",\n            \"members\": {\n              \"DurationSeconds\": {\n                \"type\": \"integer\"\n              },\n              \"SerialNumber\": {},\n              \"TokenCode\": {}\n            }\n          },\n          \"output\": {\n            \"resultWrapper\": \"GetSessionTokenResult\",\n            \"type\": \"structure\",\n            \"members\": {\n              \"Credentials\": {\n                \"shape\": \"Sc\"\n              }\n            }\n          }\n        }\n      },\n      \"shapes\": {\n        \"S4\": {\n          \"type\": \"list\",\n          \"member\": {\n            \"type\": \"structure\",\n            \"members\": {\n              \"arn\": {}\n            }\n          }\n        },\n        \"Sc\": {\n          \"type\": \"structure\",\n          \"required\": [\"AccessKeyId\", \"SecretAccessKey\", \"SessionToken\", \"Expiration\"],\n          \"members\": {\n            \"AccessKeyId\": {},\n            \"SecretAccessKey\": {},\n            \"SessionToken\": {},\n            \"Expiration\": {\n              \"type\": \"timestamp\"\n            }\n          }\n        },\n        \"Sh\": {\n          \"type\": \"structure\",\n          \"required\": [\"AssumedRoleId\", \"Arn\"],\n          \"members\": {\n            \"AssumedRoleId\": {},\n            \"Arn\": {}\n          }\n        }\n      }\n    };\n  }, {}],\n  6: [function (require, module, exports) {\n    arguments[4][2][0].apply(exports, arguments);\n  }, {\n    \"dup\": 2\n  }],\n  7: [function (require, module, exports) {\n    require('../lib/node_loader');\n\n    var AWS = require('../lib/core');\n\n    var Service = AWS.Service;\n    var apiLoader = AWS.apiLoader;\n    apiLoader.services['cognitoidentity'] = {};\n    AWS.CognitoIdentity = Service.defineService('cognitoidentity', ['2014-06-30']);\n\n    require('../lib/services/cognitoidentity');\n\n    Object.defineProperty(apiLoader.services['cognitoidentity'], '2014-06-30', {\n      get: function get() {\n        var model = require('../apis/cognito-identity-2014-06-30.min.json');\n\n        model.paginators = require('../apis/cognito-identity-2014-06-30.paginators.json').pagination;\n        return model;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    module.exports = AWS.CognitoIdentity;\n  }, {\n    \"../apis/cognito-identity-2014-06-30.min.json\": 1,\n    \"../apis/cognito-identity-2014-06-30.paginators.json\": 2,\n    \"../lib/core\": 18,\n    \"../lib/node_loader\": 16,\n    \"../lib/services/cognitoidentity\": 60\n  }],\n  8: [function (require, module, exports) {\n    require('../lib/node_loader');\n\n    var AWS = require('../lib/core');\n\n    var Service = AWS.Service;\n    var apiLoader = AWS.apiLoader;\n    apiLoader.services['sts'] = {};\n    AWS.STS = Service.defineService('sts', ['2011-06-15']);\n\n    require('../lib/services/sts');\n\n    Object.defineProperty(apiLoader.services['sts'], '2011-06-15', {\n      get: function get() {\n        var model = require('../apis/sts-2011-06-15.min.json');\n\n        model.paginators = require('../apis/sts-2011-06-15.paginators.json').pagination;\n        return model;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    module.exports = AWS.STS;\n  }, {\n    \"../apis/sts-2011-06-15.min.json\": 5,\n    \"../apis/sts-2011-06-15.paginators.json\": 6,\n    \"../lib/core\": 18,\n    \"../lib/node_loader\": 16,\n    \"../lib/services/sts\": 61\n  }],\n  9: [function (require, module, exports) {\n    function apiLoader(svc, version) {\n      if (!apiLoader.services.hasOwnProperty(svc)) {\n        throw new Error('InvalidService: Failed to load api for ' + svc);\n      }\n\n      return apiLoader.services[svc][version];\n    }\n    /**\n     * @api private\n     *\n     * This member of AWS.apiLoader is private, but changing it will necessitate a\n     * change to ../scripts/services-table-generator.ts\n     */\n\n\n    apiLoader.services = {};\n    /**\n     * @api private\n     */\n\n    module.exports = apiLoader;\n  }, {}],\n  10: [function (require, module, exports) {\n    var Hmac = require('./browserHmac');\n\n    var Md5 = require('./browserMd5');\n\n    var Sha1 = require('./browserSha1');\n\n    var Sha256 = require('./browserSha256');\n    /**\n     * @api private\n     */\n\n\n    module.exports = exports = {\n      createHash: function createHash(alg) {\n        alg = alg.toLowerCase();\n\n        if (alg === 'md5') {\n          return new Md5();\n        } else if (alg === 'sha256') {\n          return new Sha256();\n        } else if (alg === 'sha1') {\n          return new Sha1();\n        }\n\n        throw new Error('Hash algorithm ' + alg + ' is not supported in the browser SDK');\n      },\n      createHmac: function createHmac(alg, key) {\n        alg = alg.toLowerCase();\n\n        if (alg === 'md5') {\n          return new Hmac(Md5, key);\n        } else if (alg === 'sha256') {\n          return new Hmac(Sha256, key);\n        } else if (alg === 'sha1') {\n          return new Hmac(Sha1, key);\n        }\n\n        throw new Error('HMAC algorithm ' + alg + ' is not supported in the browser SDK');\n      },\n      createSign: function () {\n        throw new Error('createSign is not implemented in the browser');\n      }\n    };\n  }, {\n    \"./browserHmac\": 12,\n    \"./browserMd5\": 13,\n    \"./browserSha1\": 14,\n    \"./browserSha256\": 15\n  }],\n  11: [function (require, module, exports) {\n    var Buffer = require('buffer/').Buffer;\n    /**\n     * This is a polyfill for the static method `isView` of `ArrayBuffer`, which is\n     * e.g. missing in IE 10.\n     *\n     * @api private\n     */\n\n\n    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'undefined') {\n      ArrayBuffer.isView = function (arg) {\n        return viewStrings.indexOf(Object.prototype.toString.call(arg)) > -1;\n      };\n    }\n    /**\n     * @api private\n     */\n\n\n    var viewStrings = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]', '[object DataView]'];\n    /**\n     * @api private\n     */\n\n    function isEmptyData(data) {\n      if (typeof data === 'string') {\n        return data.length === 0;\n      }\n\n      return data.byteLength === 0;\n    }\n    /**\n     * @api private\n     */\n\n\n    function convertToBuffer(data) {\n      if (typeof data === 'string') {\n        data = new Buffer(data, 'utf8');\n      }\n\n      if (ArrayBuffer.isView(data)) {\n        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);\n      }\n\n      return new Uint8Array(data);\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = exports = {\n      isEmptyData: isEmptyData,\n      convertToBuffer: convertToBuffer\n    };\n  }, {\n    \"buffer/\": 81\n  }],\n  12: [function (require, module, exports) {\n    var hashUtils = require('./browserHashUtils');\n    /**\n     * @api private\n     */\n\n\n    function Hmac(hashCtor, secret) {\n      this.hash = new hashCtor();\n      this.outer = new hashCtor();\n      var inner = bufferFromSecret(hashCtor, secret);\n      var outer = new Uint8Array(hashCtor.BLOCK_SIZE);\n      outer.set(inner);\n\n      for (var i = 0; i < hashCtor.BLOCK_SIZE; i++) {\n        inner[i] ^= 0x36;\n        outer[i] ^= 0x5c;\n      }\n\n      this.hash.update(inner);\n      this.outer.update(outer); // Zero out the copied key buffer.\n\n      for (var i = 0; i < inner.byteLength; i++) {\n        inner[i] = 0;\n      }\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = exports = Hmac;\n\n    Hmac.prototype.update = function (toHash) {\n      if (hashUtils.isEmptyData(toHash) || this.error) {\n        return this;\n      }\n\n      try {\n        this.hash.update(hashUtils.convertToBuffer(toHash));\n      } catch (e) {\n        this.error = e;\n      }\n\n      return this;\n    };\n\n    Hmac.prototype.digest = function (encoding) {\n      if (!this.outer.finished) {\n        this.outer.update(this.hash.digest());\n      }\n\n      return this.outer.digest(encoding);\n    };\n\n    function bufferFromSecret(hashCtor, secret) {\n      var input = hashUtils.convertToBuffer(secret);\n\n      if (input.byteLength > hashCtor.BLOCK_SIZE) {\n        var bufferHash = new hashCtor();\n        bufferHash.update(input);\n        input = bufferHash.digest();\n      }\n\n      var buffer = new Uint8Array(hashCtor.BLOCK_SIZE);\n      buffer.set(input);\n      return buffer;\n    }\n  }, {\n    \"./browserHashUtils\": 11\n  }],\n  13: [function (require, module, exports) {\n    var hashUtils = require('./browserHashUtils');\n\n    var Buffer = require('buffer/').Buffer;\n\n    var BLOCK_SIZE = 64;\n    var DIGEST_LENGTH = 16;\n    var INIT = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476];\n    /**\n     * @api private\n     */\n\n    function Md5() {\n      this.state = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476];\n      this.buffer = new DataView(new ArrayBuffer(BLOCK_SIZE));\n      this.bufferLength = 0;\n      this.bytesHashed = 0;\n      this.finished = false;\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = exports = Md5;\n    Md5.BLOCK_SIZE = BLOCK_SIZE;\n\n    Md5.prototype.update = function (sourceData) {\n      if (hashUtils.isEmptyData(sourceData)) {\n        return this;\n      } else if (this.finished) {\n        throw new Error('Attempted to update an already finished hash.');\n      }\n\n      var data = hashUtils.convertToBuffer(sourceData);\n      var position = 0;\n      var byteLength = data.byteLength;\n      this.bytesHashed += byteLength;\n\n      while (byteLength > 0) {\n        this.buffer.setUint8(this.bufferLength++, data[position++]);\n        byteLength--;\n\n        if (this.bufferLength === BLOCK_SIZE) {\n          this.hashBuffer();\n          this.bufferLength = 0;\n        }\n      }\n\n      return this;\n    };\n\n    Md5.prototype.digest = function (encoding) {\n      if (!this.finished) {\n        var _a = this,\n            buffer = _a.buffer,\n            undecoratedLength = _a.bufferLength,\n            bytesHashed = _a.bytesHashed;\n\n        var bitsHashed = bytesHashed * 8;\n        buffer.setUint8(this.bufferLength++, 128); // Ensure the final block has enough room for the hashed length\n\n        if (undecoratedLength % BLOCK_SIZE >= BLOCK_SIZE - 8) {\n          for (var i = this.bufferLength; i < BLOCK_SIZE; i++) {\n            buffer.setUint8(i, 0);\n          }\n\n          this.hashBuffer();\n          this.bufferLength = 0;\n        }\n\n        for (var i = this.bufferLength; i < BLOCK_SIZE - 8; i++) {\n          buffer.setUint8(i, 0);\n        }\n\n        buffer.setUint32(BLOCK_SIZE - 8, bitsHashed >>> 0, true);\n        buffer.setUint32(BLOCK_SIZE - 4, Math.floor(bitsHashed / 0x100000000), true);\n        this.hashBuffer();\n        this.finished = true;\n      }\n\n      var out = new DataView(new ArrayBuffer(DIGEST_LENGTH));\n\n      for (var i = 0; i < 4; i++) {\n        out.setUint32(i * 4, this.state[i], true);\n      }\n\n      var buff = new Buffer(out.buffer, out.byteOffset, out.byteLength);\n      return encoding ? buff.toString(encoding) : buff;\n    };\n\n    Md5.prototype.hashBuffer = function () {\n      var _a = this,\n          buffer = _a.buffer,\n          state = _a.state;\n\n      var a = state[0],\n          b = state[1],\n          c = state[2],\n          d = state[3];\n      a = ff(a, b, c, d, buffer.getUint32(0, true), 7, 0xd76aa478);\n      d = ff(d, a, b, c, buffer.getUint32(4, true), 12, 0xe8c7b756);\n      c = ff(c, d, a, b, buffer.getUint32(8, true), 17, 0x242070db);\n      b = ff(b, c, d, a, buffer.getUint32(12, true), 22, 0xc1bdceee);\n      a = ff(a, b, c, d, buffer.getUint32(16, true), 7, 0xf57c0faf);\n      d = ff(d, a, b, c, buffer.getUint32(20, true), 12, 0x4787c62a);\n      c = ff(c, d, a, b, buffer.getUint32(24, true), 17, 0xa8304613);\n      b = ff(b, c, d, a, buffer.getUint32(28, true), 22, 0xfd469501);\n      a = ff(a, b, c, d, buffer.getUint32(32, true), 7, 0x698098d8);\n      d = ff(d, a, b, c, buffer.getUint32(36, true), 12, 0x8b44f7af);\n      c = ff(c, d, a, b, buffer.getUint32(40, true), 17, 0xffff5bb1);\n      b = ff(b, c, d, a, buffer.getUint32(44, true), 22, 0x895cd7be);\n      a = ff(a, b, c, d, buffer.getUint32(48, true), 7, 0x6b901122);\n      d = ff(d, a, b, c, buffer.getUint32(52, true), 12, 0xfd987193);\n      c = ff(c, d, a, b, buffer.getUint32(56, true), 17, 0xa679438e);\n      b = ff(b, c, d, a, buffer.getUint32(60, true), 22, 0x49b40821);\n      a = gg(a, b, c, d, buffer.getUint32(4, true), 5, 0xf61e2562);\n      d = gg(d, a, b, c, buffer.getUint32(24, true), 9, 0xc040b340);\n      c = gg(c, d, a, b, buffer.getUint32(44, true), 14, 0x265e5a51);\n      b = gg(b, c, d, a, buffer.getUint32(0, true), 20, 0xe9b6c7aa);\n      a = gg(a, b, c, d, buffer.getUint32(20, true), 5, 0xd62f105d);\n      d = gg(d, a, b, c, buffer.getUint32(40, true), 9, 0x02441453);\n      c = gg(c, d, a, b, buffer.getUint32(60, true), 14, 0xd8a1e681);\n      b = gg(b, c, d, a, buffer.getUint32(16, true), 20, 0xe7d3fbc8);\n      a = gg(a, b, c, d, buffer.getUint32(36, true), 5, 0x21e1cde6);\n      d = gg(d, a, b, c, buffer.getUint32(56, true), 9, 0xc33707d6);\n      c = gg(c, d, a, b, buffer.getUint32(12, true), 14, 0xf4d50d87);\n      b = gg(b, c, d, a, buffer.getUint32(32, true), 20, 0x455a14ed);\n      a = gg(a, b, c, d, buffer.getUint32(52, true), 5, 0xa9e3e905);\n      d = gg(d, a, b, c, buffer.getUint32(8, true), 9, 0xfcefa3f8);\n      c = gg(c, d, a, b, buffer.getUint32(28, true), 14, 0x676f02d9);\n      b = gg(b, c, d, a, buffer.getUint32(48, true), 20, 0x8d2a4c8a);\n      a = hh(a, b, c, d, buffer.getUint32(20, true), 4, 0xfffa3942);\n      d = hh(d, a, b, c, buffer.getUint32(32, true), 11, 0x8771f681);\n      c = hh(c, d, a, b, buffer.getUint32(44, true), 16, 0x6d9d6122);\n      b = hh(b, c, d, a, buffer.getUint32(56, true), 23, 0xfde5380c);\n      a = hh(a, b, c, d, buffer.getUint32(4, true), 4, 0xa4beea44);\n      d = hh(d, a, b, c, buffer.getUint32(16, true), 11, 0x4bdecfa9);\n      c = hh(c, d, a, b, buffer.getUint32(28, true), 16, 0xf6bb4b60);\n      b = hh(b, c, d, a, buffer.getUint32(40, true), 23, 0xbebfbc70);\n      a = hh(a, b, c, d, buffer.getUint32(52, true), 4, 0x289b7ec6);\n      d = hh(d, a, b, c, buffer.getUint32(0, true), 11, 0xeaa127fa);\n      c = hh(c, d, a, b, buffer.getUint32(12, true), 16, 0xd4ef3085);\n      b = hh(b, c, d, a, buffer.getUint32(24, true), 23, 0x04881d05);\n      a = hh(a, b, c, d, buffer.getUint32(36, true), 4, 0xd9d4d039);\n      d = hh(d, a, b, c, buffer.getUint32(48, true), 11, 0xe6db99e5);\n      c = hh(c, d, a, b, buffer.getUint32(60, true), 16, 0x1fa27cf8);\n      b = hh(b, c, d, a, buffer.getUint32(8, true), 23, 0xc4ac5665);\n      a = ii(a, b, c, d, buffer.getUint32(0, true), 6, 0xf4292244);\n      d = ii(d, a, b, c, buffer.getUint32(28, true), 10, 0x432aff97);\n      c = ii(c, d, a, b, buffer.getUint32(56, true), 15, 0xab9423a7);\n      b = ii(b, c, d, a, buffer.getUint32(20, true), 21, 0xfc93a039);\n      a = ii(a, b, c, d, buffer.getUint32(48, true), 6, 0x655b59c3);\n      d = ii(d, a, b, c, buffer.getUint32(12, true), 10, 0x8f0ccc92);\n      c = ii(c, d, a, b, buffer.getUint32(40, true), 15, 0xffeff47d);\n      b = ii(b, c, d, a, buffer.getUint32(4, true), 21, 0x85845dd1);\n      a = ii(a, b, c, d, buffer.getUint32(32, true), 6, 0x6fa87e4f);\n      d = ii(d, a, b, c, buffer.getUint32(60, true), 10, 0xfe2ce6e0);\n      c = ii(c, d, a, b, buffer.getUint32(24, true), 15, 0xa3014314);\n      b = ii(b, c, d, a, buffer.getUint32(52, true), 21, 0x4e0811a1);\n      a = ii(a, b, c, d, buffer.getUint32(16, true), 6, 0xf7537e82);\n      d = ii(d, a, b, c, buffer.getUint32(44, true), 10, 0xbd3af235);\n      c = ii(c, d, a, b, buffer.getUint32(8, true), 15, 0x2ad7d2bb);\n      b = ii(b, c, d, a, buffer.getUint32(36, true), 21, 0xeb86d391);\n      state[0] = a + state[0] & 0xFFFFFFFF;\n      state[1] = b + state[1] & 0xFFFFFFFF;\n      state[2] = c + state[2] & 0xFFFFFFFF;\n      state[3] = d + state[3] & 0xFFFFFFFF;\n    };\n\n    function cmn(q, a, b, x, s, t) {\n      a = (a + q & 0xFFFFFFFF) + (x + t & 0xFFFFFFFF) & 0xFFFFFFFF;\n      return (a << s | a >>> 32 - s) + b & 0xFFFFFFFF;\n    }\n\n    function ff(a, b, c, d, x, s, t) {\n      return cmn(b & c | ~b & d, a, b, x, s, t);\n    }\n\n    function gg(a, b, c, d, x, s, t) {\n      return cmn(b & d | c & ~d, a, b, x, s, t);\n    }\n\n    function hh(a, b, c, d, x, s, t) {\n      return cmn(b ^ c ^ d, a, b, x, s, t);\n    }\n\n    function ii(a, b, c, d, x, s, t) {\n      return cmn(c ^ (b | ~d), a, b, x, s, t);\n    }\n  }, {\n    \"./browserHashUtils\": 11,\n    \"buffer/\": 81\n  }],\n  14: [function (require, module, exports) {\n    var Buffer = require('buffer/').Buffer;\n\n    var hashUtils = require('./browserHashUtils');\n\n    var BLOCK_SIZE = 64;\n    var DIGEST_LENGTH = 20;\n    var KEY = new Uint32Array([0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0]);\n    var INIT = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n    var MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;\n    /**\n     * @api private\n     */\n\n    function Sha1() {\n      this.h0 = 0x67452301;\n      this.h1 = 0xEFCDAB89;\n      this.h2 = 0x98BADCFE;\n      this.h3 = 0x10325476;\n      this.h4 = 0xC3D2E1F0; // The first 64 bytes (16 words) is the data chunk\n\n      this.block = new Uint32Array(80);\n      this.offset = 0;\n      this.shift = 24;\n      this.totalLength = 0;\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = exports = Sha1;\n    Sha1.BLOCK_SIZE = BLOCK_SIZE;\n\n    Sha1.prototype.update = function (data) {\n      if (this.finished) {\n        throw new Error('Attempted to update an already finished hash.');\n      }\n\n      if (hashUtils.isEmptyData(data)) {\n        return this;\n      }\n\n      data = hashUtils.convertToBuffer(data);\n      var length = data.length;\n      this.totalLength += length * 8;\n\n      for (var i = 0; i < length; i++) {\n        this.write(data[i]);\n      }\n\n      return this;\n    };\n\n    Sha1.prototype.write = function write(byte) {\n      this.block[this.offset] |= (byte & 0xff) << this.shift;\n\n      if (this.shift) {\n        this.shift -= 8;\n      } else {\n        this.offset++;\n        this.shift = 24;\n      }\n\n      if (this.offset === 16) this.processBlock();\n    };\n\n    Sha1.prototype.digest = function (encoding) {\n      // Pad\n      this.write(0x80);\n\n      if (this.offset > 14 || this.offset === 14 && this.shift < 24) {\n        this.processBlock();\n      }\n\n      this.offset = 14;\n      this.shift = 24; // 64-bit length big-endian\n\n      this.write(0x00); // numbers this big aren't accurate in javascript anyway\n\n      this.write(0x00); // ..So just hard-code to zero.\n\n      this.write(this.totalLength > 0xffffffffff ? this.totalLength / 0x10000000000 : 0x00);\n      this.write(this.totalLength > 0xffffffff ? this.totalLength / 0x100000000 : 0x00);\n\n      for (var s = 24; s >= 0; s -= 8) {\n        this.write(this.totalLength >> s);\n      } // The value in state is little-endian rather than big-endian, so flip\n      // each word into a new Uint8Array\n\n\n      var out = new Buffer(DIGEST_LENGTH);\n      var outView = new DataView(out.buffer);\n      outView.setUint32(0, this.h0, false);\n      outView.setUint32(4, this.h1, false);\n      outView.setUint32(8, this.h2, false);\n      outView.setUint32(12, this.h3, false);\n      outView.setUint32(16, this.h4, false);\n      return encoding ? out.toString(encoding) : out;\n    };\n\n    Sha1.prototype.processBlock = function processBlock() {\n      // Extend the sixteen 32-bit words into eighty 32-bit words:\n      for (var i = 16; i < 80; i++) {\n        var w = this.block[i - 3] ^ this.block[i - 8] ^ this.block[i - 14] ^ this.block[i - 16];\n        this.block[i] = w << 1 | w >>> 31;\n      } // Initialize hash value for this chunk:\n\n\n      var a = this.h0;\n      var b = this.h1;\n      var c = this.h2;\n      var d = this.h3;\n      var e = this.h4;\n      var f, k; // Main loop:\n\n      for (i = 0; i < 80; i++) {\n        if (i < 20) {\n          f = d ^ b & (c ^ d);\n          k = 0x5A827999;\n        } else if (i < 40) {\n          f = b ^ c ^ d;\n          k = 0x6ED9EBA1;\n        } else if (i < 60) {\n          f = b & c | d & (b | c);\n          k = 0x8F1BBCDC;\n        } else {\n          f = b ^ c ^ d;\n          k = 0xCA62C1D6;\n        }\n\n        var temp = (a << 5 | a >>> 27) + f + e + k + (this.block[i] | 0);\n        e = d;\n        d = c;\n        c = b << 30 | b >>> 2;\n        b = a;\n        a = temp;\n      } // Add this chunk's hash to result so far:\n\n\n      this.h0 = this.h0 + a | 0;\n      this.h1 = this.h1 + b | 0;\n      this.h2 = this.h2 + c | 0;\n      this.h3 = this.h3 + d | 0;\n      this.h4 = this.h4 + e | 0; // The block is now reusable.\n\n      this.offset = 0;\n\n      for (i = 0; i < 16; i++) {\n        this.block[i] = 0;\n      }\n    };\n  }, {\n    \"./browserHashUtils\": 11,\n    \"buffer/\": 81\n  }],\n  15: [function (require, module, exports) {\n    var Buffer = require('buffer/').Buffer;\n\n    var hashUtils = require('./browserHashUtils');\n\n    var BLOCK_SIZE = 64;\n    var DIGEST_LENGTH = 32;\n    var KEY = new Uint32Array([0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]);\n    var INIT = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n    var MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;\n    /**\n     * @private\n     */\n\n    function Sha256() {\n      this.state = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n      this.temp = new Int32Array(64);\n      this.buffer = new Uint8Array(64);\n      this.bufferLength = 0;\n      this.bytesHashed = 0;\n      /**\n       * @private\n       */\n\n      this.finished = false;\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = exports = Sha256;\n    Sha256.BLOCK_SIZE = BLOCK_SIZE;\n\n    Sha256.prototype.update = function (data) {\n      if (this.finished) {\n        throw new Error('Attempted to update an already finished hash.');\n      }\n\n      if (hashUtils.isEmptyData(data)) {\n        return this;\n      }\n\n      data = hashUtils.convertToBuffer(data);\n      var position = 0;\n      var byteLength = data.byteLength;\n      this.bytesHashed += byteLength;\n\n      if (this.bytesHashed * 8 > MAX_HASHABLE_LENGTH) {\n        throw new Error('Cannot hash more than 2^53 - 1 bits');\n      }\n\n      while (byteLength > 0) {\n        this.buffer[this.bufferLength++] = data[position++];\n        byteLength--;\n\n        if (this.bufferLength === BLOCK_SIZE) {\n          this.hashBuffer();\n          this.bufferLength = 0;\n        }\n      }\n\n      return this;\n    };\n\n    Sha256.prototype.digest = function (encoding) {\n      if (!this.finished) {\n        var bitsHashed = this.bytesHashed * 8;\n        var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);\n        var undecoratedLength = this.bufferLength;\n        bufferView.setUint8(this.bufferLength++, 0x80); // Ensure the final block has enough room for the hashed length\n\n        if (undecoratedLength % BLOCK_SIZE >= BLOCK_SIZE - 8) {\n          for (var i = this.bufferLength; i < BLOCK_SIZE; i++) {\n            bufferView.setUint8(i, 0);\n          }\n\n          this.hashBuffer();\n          this.bufferLength = 0;\n        }\n\n        for (var i = this.bufferLength; i < BLOCK_SIZE - 8; i++) {\n          bufferView.setUint8(i, 0);\n        }\n\n        bufferView.setUint32(BLOCK_SIZE - 8, Math.floor(bitsHashed / 0x100000000), true);\n        bufferView.setUint32(BLOCK_SIZE - 4, bitsHashed);\n        this.hashBuffer();\n        this.finished = true;\n      } // The value in state is little-endian rather than big-endian, so flip\n      // each word into a new Uint8Array\n\n\n      var out = new Buffer(DIGEST_LENGTH);\n\n      for (var i = 0; i < 8; i++) {\n        out[i * 4] = this.state[i] >>> 24 & 0xff;\n        out[i * 4 + 1] = this.state[i] >>> 16 & 0xff;\n        out[i * 4 + 2] = this.state[i] >>> 8 & 0xff;\n        out[i * 4 + 3] = this.state[i] >>> 0 & 0xff;\n      }\n\n      return encoding ? out.toString(encoding) : out;\n    };\n\n    Sha256.prototype.hashBuffer = function () {\n      var _a = this,\n          buffer = _a.buffer,\n          state = _a.state;\n\n      var state0 = state[0],\n          state1 = state[1],\n          state2 = state[2],\n          state3 = state[3],\n          state4 = state[4],\n          state5 = state[5],\n          state6 = state[6],\n          state7 = state[7];\n\n      for (var i = 0; i < BLOCK_SIZE; i++) {\n        if (i < 16) {\n          this.temp[i] = (buffer[i * 4] & 0xff) << 24 | (buffer[i * 4 + 1] & 0xff) << 16 | (buffer[i * 4 + 2] & 0xff) << 8 | buffer[i * 4 + 3] & 0xff;\n        } else {\n          var u = this.temp[i - 2];\n          var t1_1 = (u >>> 17 | u << 15) ^ (u >>> 19 | u << 13) ^ u >>> 10;\n          u = this.temp[i - 15];\n          var t2_1 = (u >>> 7 | u << 25) ^ (u >>> 18 | u << 14) ^ u >>> 3;\n          this.temp[i] = (t1_1 + this.temp[i - 7] | 0) + (t2_1 + this.temp[i - 16] | 0);\n        }\n\n        var t1 = (((state4 >>> 6 | state4 << 26) ^ (state4 >>> 11 | state4 << 21) ^ (state4 >>> 25 | state4 << 7)) + (state4 & state5 ^ ~state4 & state6) | 0) + (state7 + (KEY[i] + this.temp[i] | 0) | 0) | 0;\n        var t2 = ((state0 >>> 2 | state0 << 30) ^ (state0 >>> 13 | state0 << 19) ^ (state0 >>> 22 | state0 << 10)) + (state0 & state1 ^ state0 & state2 ^ state1 & state2) | 0;\n        state7 = state6;\n        state6 = state5;\n        state5 = state4;\n        state4 = state3 + t1 | 0;\n        state3 = state2;\n        state2 = state1;\n        state1 = state0;\n        state0 = t1 + t2 | 0;\n      }\n\n      state[0] += state0;\n      state[1] += state1;\n      state[2] += state2;\n      state[3] += state3;\n      state[4] += state4;\n      state[5] += state5;\n      state[6] += state6;\n      state[7] += state7;\n    };\n  }, {\n    \"./browserHashUtils\": 11,\n    \"buffer/\": 81\n  }],\n  16: [function (require, module, exports) {\n    (function (process) {\n      (function () {\n        var util = require('./util'); // browser specific modules\n\n\n        util.crypto.lib = require('./browserCryptoLib');\n        util.Buffer = require('buffer/').Buffer;\n        util.url = require('url/');\n        util.querystring = require('querystring/');\n        util.realClock = require('./realclock/browserClock');\n        util.environment = 'js';\n        util.createEventStream = require('./event-stream/buffered-create-event-stream').createEventStream;\n\n        util.isBrowser = function () {\n          return true;\n        };\n\n        util.isNode = function () {\n          return false;\n        };\n\n        var AWS = require('./core');\n        /**\n         * @api private\n         */\n\n\n        module.exports = AWS;\n\n        require('./credentials');\n\n        require('./credentials/credential_provider_chain');\n\n        require('./credentials/temporary_credentials');\n\n        require('./credentials/chainable_temporary_credentials');\n\n        require('./credentials/web_identity_credentials');\n\n        require('./credentials/cognito_identity_credentials');\n\n        require('./credentials/saml_credentials'); // Load the DOMParser XML parser\n\n\n        AWS.XML.Parser = require('./xml/browser_parser'); // Load the XHR HttpClient\n\n        require('./http/xhr');\n\n        if (typeof process === 'undefined') {\n          var process = {\n            browser: true\n          };\n        }\n      }).call(this);\n    }).call(this, require('_process'));\n  }, {\n    \"./browserCryptoLib\": 10,\n    \"./core\": 18,\n    \"./credentials\": 19,\n    \"./credentials/chainable_temporary_credentials\": 20,\n    \"./credentials/cognito_identity_credentials\": 21,\n    \"./credentials/credential_provider_chain\": 22,\n    \"./credentials/saml_credentials\": 23,\n    \"./credentials/temporary_credentials\": 24,\n    \"./credentials/web_identity_credentials\": 25,\n    \"./event-stream/buffered-create-event-stream\": 27,\n    \"./http/xhr\": 35,\n    \"./realclock/browserClock\": 52,\n    \"./util\": 71,\n    \"./xml/browser_parser\": 72,\n    \"_process\": 86,\n    \"buffer/\": 81,\n    \"querystring/\": 92,\n    \"url/\": 94\n  }],\n  17: [function (require, module, exports) {\n    var AWS = require('./core');\n\n    require('./credentials');\n\n    require('./credentials/credential_provider_chain');\n\n    var PromisesDependency;\n    /**\n     * The main configuration class used by all service objects to set\n     * the region, credentials, and other options for requests.\n     *\n     * By default, credentials and region settings are left unconfigured.\n     * This should be configured by the application before using any\n     * AWS service APIs.\n     *\n     * In order to set global configuration options, properties should\n     * be assigned to the global {AWS.config} object.\n     *\n     * @see AWS.config\n     *\n     * @!group General Configuration Options\n     *\n     * @!attribute credentials\n     *   @return [AWS.Credentials] the AWS credentials to sign requests with.\n     *\n     * @!attribute region\n     *   @example Set the global region setting to us-west-2\n     *     AWS.config.update({region: 'us-west-2'});\n     *   @return [AWS.Credentials] The region to send service requests to.\n     *   @see http://docs.amazonwebservices.com/general/latest/gr/rande.html\n     *     A list of available endpoints for each AWS service\n     *\n     * @!attribute maxRetries\n     *   @return [Integer] the maximum amount of retries to perform for a\n     *     service request. By default this value is calculated by the specific\n     *     service object that the request is being made to.\n     *\n     * @!attribute maxRedirects\n     *   @return [Integer] the maximum amount of redirects to follow for a\n     *     service request. Defaults to 10.\n     *\n     * @!attribute paramValidation\n     *   @return [Boolean|map] whether input parameters should be validated against\n     *     the operation description before sending the request. Defaults to true.\n     *     Pass a map to enable any of the following specific validation features:\n     *\n     *     * **min** [Boolean] &mdash; Validates that a value meets the min\n     *       constraint. This is enabled by default when paramValidation is set\n     *       to `true`.\n     *     * **max** [Boolean] &mdash; Validates that a value meets the max\n     *       constraint.\n     *     * **pattern** [Boolean] &mdash; Validates that a string value matches a\n     *       regular expression.\n     *     * **enum** [Boolean] &mdash; Validates that a string value matches one\n     *       of the allowable enum values.\n     *\n     * @!attribute computeChecksums\n     *   @return [Boolean] whether to compute checksums for payload bodies when\n     *     the service accepts it (currently supported in S3 only).\n     *\n     * @!attribute convertResponseTypes\n     *   @return [Boolean] whether types are converted when parsing response data.\n     *     Currently only supported for JSON based services. Turning this off may\n     *     improve performance on large response payloads. Defaults to `true`.\n     *\n     * @!attribute correctClockSkew\n     *   @return [Boolean] whether to apply a clock skew correction and retry\n     *     requests that fail because of an skewed client clock. Defaults to\n     *     `false`.\n     *\n     * @!attribute sslEnabled\n     *   @return [Boolean] whether SSL is enabled for requests\n     *\n     * @!attribute s3ForcePathStyle\n     *   @return [Boolean] whether to force path style URLs for S3 objects\n     *\n     * @!attribute s3BucketEndpoint\n     *   @note Setting this configuration option requires an `endpoint` to be\n     *     provided explicitly to the service constructor.\n     *   @return [Boolean] whether the provided endpoint addresses an individual\n     *     bucket (false if it addresses the root API endpoint).\n     *\n     * @!attribute s3DisableBodySigning\n     *   @return [Boolean] whether to disable S3 body signing when using signature version `v4`.\n     *     Body signing can only be disabled when using https. Defaults to `true`.\n     *\n     * @!attribute useAccelerateEndpoint\n     *   @note This configuration option is only compatible with S3 while accessing\n     *     dns-compatible buckets.\n     *   @return [Boolean] Whether to use the Accelerate endpoint with the S3 service.\n     *     Defaults to `false`.\n     *\n     * @!attribute retryDelayOptions\n     *   @example Set the base retry delay for all services to 300 ms\n     *     AWS.config.update({retryDelayOptions: {base: 300}});\n     *     // Delays with maxRetries = 3: 300, 600, 1200\n     *   @example Set a custom backoff function to provide delay values on retries\n     *     AWS.config.update({retryDelayOptions: {customBackoff: function(retryCount) {\n     *       // returns delay in ms\n     *     }}});\n     *   @return [map] A set of options to configure the retry delay on retryable errors.\n     *     Currently supported options are:\n     *\n     *     * **base** [Integer] &mdash; The base number of milliseconds to use in the\n     *       exponential backoff for operation retries. Defaults to 100 ms for all services except\n     *       DynamoDB, where it defaults to 50ms.\n     *     * **customBackoff ** [function] &mdash; A custom function that accepts a retry count\n     *       and returns the amount of time to delay in milliseconds. The `base` option will be\n     *       ignored if this option is supplied.\n     *\n     * @!attribute httpOptions\n     *   @return [map] A set of options to pass to the low-level HTTP request.\n     *     Currently supported options are:\n     *\n     *     * **proxy** [String] &mdash; the URL to proxy requests through\n     *     * **agent** [http.Agent, https.Agent] &mdash; the Agent object to perform\n     *       HTTP requests with. Used for connection pooling. Note that for\n     *       SSL connections, a special Agent object is used in order to enable\n     *       peer certificate verification. This feature is only supported in the\n     *       Node.js environment.\n     *     * **connectTimeout** [Integer] &mdash; Sets the socket to timeout after\n     *       failing to establish a connection with the server after\n     *       `connectTimeout` milliseconds. This timeout has no effect once a socket\n     *       connection has been established.\n     *     * **timeout** [Integer] &mdash; Sets the socket to timeout after timeout\n     *       milliseconds of inactivity on the socket. Defaults to two minutes\n     *       (120000)\n     *     * **xhrAsync** [Boolean] &mdash; Whether the SDK will send asynchronous\n     *       HTTP requests. Used in the browser environment only. Set to false to\n     *       send requests synchronously. Defaults to true (async on).\n     *     * **xhrWithCredentials** [Boolean] &mdash; Sets the \"withCredentials\"\n     *       property of an XMLHttpRequest object. Used in the browser environment\n     *       only. Defaults to false.\n     * @!attribute logger\n     *   @return [#write,#log] an object that responds to .write() (like a stream)\n     *     or .log() (like the console object) in order to log information about\n     *     requests\n     *\n     * @!attribute systemClockOffset\n     *   @return [Number] an offset value in milliseconds to apply to all signing\n     *     times. Use this to compensate for clock skew when your system may be\n     *     out of sync with the service time. Note that this configuration option\n     *     can only be applied to the global `AWS.config` object and cannot be\n     *     overridden in service-specific configuration. Defaults to 0 milliseconds.\n     *\n     * @!attribute signatureVersion\n     *   @return [String] the signature version to sign requests with (overriding\n     *     the API configuration). Possible values are: 'v2', 'v3', 'v4'.\n     *\n     * @!attribute signatureCache\n     *   @return [Boolean] whether the signature to sign requests with (overriding\n     *     the API configuration) is cached. Only applies to the signature version 'v4'.\n     *     Defaults to `true`.\n     *\n     * @!attribute endpointDiscoveryEnabled\n     *   @return [Boolean] whether to enable endpoint discovery for operations that\n     *     allow optionally using an endpoint returned by the service.\n     *     Defaults to 'false'\n     *\n     * @!attribute endpointCacheSize\n     *   @return [Number] the size of the global cache storing endpoints from endpoint\n     *     discovery operations. Once endpoint cache is created, updating this setting\n     *     cannot change existing cache size.\n     *     Defaults to 1000\n     *\n     * @!attribute hostPrefixEnabled\n     *   @return [Boolean] whether to marshal request parameters to the prefix of\n     *     hostname. Defaults to `true`.\n     *\n     * @!attribute stsRegionalEndpoints\n     *   @return ['legacy'|'regional'] whether to send sts request to global endpoints or\n     *     regional endpoints.\n     *     Defaults to 'legacy'\n     */\n\n    AWS.Config = AWS.util.inherit({\n      /**\n       * @!endgroup\n       */\n\n      /**\n       * Creates a new configuration object. This is the object that passes\n       * option data along to service requests, including credentials, security,\n       * region information, and some service specific settings.\n       *\n       * @example Creating a new configuration object with credentials and region\n       *   var config = new AWS.Config({\n       *     accessKeyId: 'AKID', secretAccessKey: 'SECRET', region: 'us-west-2'\n       *   });\n       * @option options accessKeyId [String] your AWS access key ID.\n       * @option options secretAccessKey [String] your AWS secret access key.\n       * @option options sessionToken [AWS.Credentials] the optional AWS\n       *   session token to sign requests with.\n       * @option options credentials [AWS.Credentials] the AWS credentials\n       *   to sign requests with. You can either specify this object, or\n       *   specify the accessKeyId and secretAccessKey options directly.\n       * @option options credentialProvider [AWS.CredentialProviderChain] the\n       *   provider chain used to resolve credentials if no static `credentials`\n       *   property is set.\n       * @option options region [String] the region to send service requests to.\n       *   See {region} for more information.\n       * @option options maxRetries [Integer] the maximum amount of retries to\n       *   attempt with a request. See {maxRetries} for more information.\n       * @option options maxRedirects [Integer] the maximum amount of redirects to\n       *   follow with a request. See {maxRedirects} for more information.\n       * @option options sslEnabled [Boolean] whether to enable SSL for\n       *   requests.\n       * @option options paramValidation [Boolean|map] whether input parameters\n       *   should be validated against the operation description before sending\n       *   the request. Defaults to true. Pass a map to enable any of the\n       *   following specific validation features:\n       *\n       *   * **min** [Boolean] &mdash; Validates that a value meets the min\n       *     constraint. This is enabled by default when paramValidation is set\n       *     to `true`.\n       *   * **max** [Boolean] &mdash; Validates that a value meets the max\n       *     constraint.\n       *   * **pattern** [Boolean] &mdash; Validates that a string value matches a\n       *     regular expression.\n       *   * **enum** [Boolean] &mdash; Validates that a string value matches one\n       *     of the allowable enum values.\n       * @option options computeChecksums [Boolean] whether to compute checksums\n       *   for payload bodies when the service accepts it (currently supported\n       *   in S3 only)\n       * @option options convertResponseTypes [Boolean] whether types are converted\n       *     when parsing response data. Currently only supported for JSON based\n       *     services. Turning this off may improve performance on large response\n       *     payloads. Defaults to `true`.\n       * @option options correctClockSkew [Boolean] whether to apply a clock skew\n       *     correction and retry requests that fail because of an skewed client\n       *     clock. Defaults to `false`.\n       * @option options s3ForcePathStyle [Boolean] whether to force path\n       *   style URLs for S3 objects.\n       * @option options s3BucketEndpoint [Boolean] whether the provided endpoint\n       *   addresses an individual bucket (false if it addresses the root API\n       *   endpoint). Note that setting this configuration option requires an\n       *   `endpoint` to be provided explicitly to the service constructor.\n       * @option options s3DisableBodySigning [Boolean] whether S3 body signing\n       *   should be disabled when using signature version `v4`. Body signing\n       *   can only be disabled when using https. Defaults to `true`.\n       *\n       * @option options retryDelayOptions [map] A set of options to configure\n       *   the retry delay on retryable errors. Currently supported options are:\n       *\n       *   * **base** [Integer] &mdash; The base number of milliseconds to use in the\n       *     exponential backoff for operation retries. Defaults to 100 ms for all\n       *     services except DynamoDB, where it defaults to 50ms.\n       *   * **customBackoff ** [function] &mdash; A custom function that accepts a retry count\n       *     and returns the amount of time to delay in milliseconds. The `base` option will be\n       *     ignored if this option is supplied.\n       * @option options httpOptions [map] A set of options to pass to the low-level\n       *   HTTP request. Currently supported options are:\n       *\n       *   * **proxy** [String] &mdash; the URL to proxy requests through\n       *   * **agent** [http.Agent, https.Agent] &mdash; the Agent object to perform\n       *     HTTP requests with. Used for connection pooling. Defaults to the global\n       *     agent (`http.globalAgent`) for non-SSL connections. Note that for\n       *     SSL connections, a special Agent object is used in order to enable\n       *     peer certificate verification. This feature is only available in the\n       *     Node.js environment.\n       *   * **connectTimeout** [Integer] &mdash; Sets the socket to timeout after\n       *     failing to establish a connection with the server after\n       *     `connectTimeout` milliseconds. This timeout has no effect once a socket\n       *     connection has been established.\n       *   * **timeout** [Integer] &mdash; Sets the socket to timeout after timeout\n       *     milliseconds of inactivity on the socket. Defaults to two minutes\n       *     (120000).\n       *   * **xhrAsync** [Boolean] &mdash; Whether the SDK will send asynchronous\n       *     HTTP requests. Used in the browser environment only. Set to false to\n       *     send requests synchronously. Defaults to true (async on).\n       *   * **xhrWithCredentials** [Boolean] &mdash; Sets the \"withCredentials\"\n       *     property of an XMLHttpRequest object. Used in the browser environment\n       *     only. Defaults to false.\n       * @option options apiVersion [String, Date] a String in YYYY-MM-DD format\n       *   (or a date) that represents the latest possible API version that can be\n       *   used in all services (unless overridden by `apiVersions`). Specify\n       *   'latest' to use the latest possible version.\n       * @option options apiVersions [map<String, String|Date>] a map of service\n       *   identifiers (the lowercase service class name) with the API version to\n       *   use when instantiating a service. Specify 'latest' for each individual\n       *   that can use the latest available version.\n       * @option options logger [#write,#log] an object that responds to .write()\n       *   (like a stream) or .log() (like the console object) in order to log\n       *   information about requests\n       * @option options systemClockOffset [Number] an offset value in milliseconds\n       *   to apply to all signing times. Use this to compensate for clock skew\n       *   when your system may be out of sync with the service time. Note that\n       *   this configuration option can only be applied to the global `AWS.config`\n       *   object and cannot be overridden in service-specific configuration.\n       *   Defaults to 0 milliseconds.\n       * @option options signatureVersion [String] the signature version to sign\n       *   requests with (overriding the API configuration). Possible values are:\n       *   'v2', 'v3', 'v4'.\n       * @option options signatureCache [Boolean] whether the signature to sign\n       *   requests with (overriding the API configuration) is cached. Only applies\n       *   to the signature version 'v4'. Defaults to `true`.\n       * @option options dynamoDbCrc32 [Boolean] whether to validate the CRC32\n       *   checksum of HTTP response bodies returned by DynamoDB. Default: `true`.\n       * @option options useAccelerateEndpoint [Boolean] Whether to use the\n       *   S3 Transfer Acceleration endpoint with the S3 service. Default: `false`.\n       * @option options clientSideMonitoring [Boolean] whether to collect and\n       *   publish this client's performance metrics of all its API requests.\n       * @option options endpointDiscoveryEnabled [Boolean] whether to enable endpoint\n       *   discovery for operations that allow optionally using an endpoint returned by\n       *   the service.\n       *   Defaults to 'false'\n       * @option options endpointCacheSize [Number] the size of the global cache storing\n       *   endpoints from endpoint discovery operations. Once endpoint cache is created,\n       *   updating this setting cannot change existing cache size.\n       *   Defaults to 1000\n       * @option options hostPrefixEnabled [Boolean] whether to marshal request\n       *   parameters to the prefix of hostname.\n       *   Defaults to `true`.\n       * @option options stsRegionalEndpoints ['legacy'|'regional'] whether to send sts request\n       *   to global endpoints or regional endpoints.\n       *   Defaults to 'legacy'.\n       */\n      constructor: function Config(options) {\n        if (options === undefined) options = {};\n        options = this.extractCredentials(options);\n        AWS.util.each.call(this, this.keys, function (key, value) {\n          this.set(key, options[key], value);\n        });\n      },\n\n      /**\n       * @!group Managing Credentials\n       */\n\n      /**\n       * Loads credentials from the configuration object. This is used internally\n       * by the SDK to ensure that refreshable {Credentials} objects are properly\n       * refreshed and loaded when sending a request. If you want to ensure that\n       * your credentials are loaded prior to a request, you can use this method\n       * directly to provide accurate credential data stored in the object.\n       *\n       * @note If you configure the SDK with static or environment credentials,\n       *   the credential data should already be present in {credentials} attribute.\n       *   This method is primarily necessary to load credentials from asynchronous\n       *   sources, or sources that can refresh credentials periodically.\n       * @example Getting your access key\n       *   AWS.config.getCredentials(function(err) {\n       *     if (err) console.log(err.stack); // credentials not loaded\n       *     else console.log(\"Access Key:\", AWS.config.credentials.accessKeyId);\n       *   })\n       * @callback callback function(err)\n       *   Called when the {credentials} have been properly set on the configuration\n       *   object.\n       *\n       *   @param err [Error] if this is set, credentials were not successfully\n       *     loaded and this error provides information why.\n       * @see credentials\n       * @see Credentials\n       */\n      getCredentials: function getCredentials(callback) {\n        var self = this;\n\n        function finish(err) {\n          callback(err, err ? null : self.credentials);\n        }\n\n        function credError(msg, err) {\n          return new AWS.util.error(err || new Error(), {\n            code: 'CredentialsError',\n            message: msg,\n            name: 'CredentialsError'\n          });\n        }\n\n        function getAsyncCredentials() {\n          self.credentials.get(function (err) {\n            if (err) {\n              var msg = 'Could not load credentials from ' + self.credentials.constructor.name;\n              err = credError(msg, err);\n            }\n\n            finish(err);\n          });\n        }\n\n        function getStaticCredentials() {\n          var err = null;\n\n          if (!self.credentials.accessKeyId || !self.credentials.secretAccessKey) {\n            err = credError('Missing credentials');\n          }\n\n          finish(err);\n        }\n\n        if (self.credentials) {\n          if (typeof self.credentials.get === 'function') {\n            getAsyncCredentials();\n          } else {\n            // static credentials\n            getStaticCredentials();\n          }\n        } else if (self.credentialProvider) {\n          self.credentialProvider.resolve(function (err, creds) {\n            if (err) {\n              err = credError('Could not load credentials from any providers', err);\n            }\n\n            self.credentials = creds;\n            finish(err);\n          });\n        } else {\n          finish(credError('No credentials to load'));\n        }\n      },\n\n      /**\n       * @!group Loading and Setting Configuration Options\n       */\n\n      /**\n       * @overload update(options, allowUnknownKeys = false)\n       *   Updates the current configuration object with new options.\n       *\n       *   @example Update maxRetries property of a configuration object\n       *     config.update({maxRetries: 10});\n       *   @param [Object] options a map of option keys and values.\n       *   @param [Boolean] allowUnknownKeys whether unknown keys can be set on\n       *     the configuration object. Defaults to `false`.\n       *   @see constructor\n       */\n      update: function update(options, allowUnknownKeys) {\n        allowUnknownKeys = allowUnknownKeys || false;\n        options = this.extractCredentials(options);\n        AWS.util.each.call(this, options, function (key, value) {\n          if (allowUnknownKeys || Object.prototype.hasOwnProperty.call(this.keys, key) || AWS.Service.hasService(key)) {\n            this.set(key, value);\n          }\n        });\n      },\n\n      /**\n       * Loads configuration data from a JSON file into this config object.\n       * @note Loading configuration will reset all existing configuration\n       *   on the object.\n       * @!macro nobrowser\n       * @param path [String] the path relative to your process's current\n       *    working directory to load configuration from.\n       * @return [AWS.Config] the same configuration object\n       */\n      loadFromPath: function loadFromPath(path) {\n        this.clear();\n        var options = JSON.parse(AWS.util.readFileSync(path));\n        var fileSystemCreds = new AWS.FileSystemCredentials(path);\n        var chain = new AWS.CredentialProviderChain();\n        chain.providers.unshift(fileSystemCreds);\n        chain.resolve(function (err, creds) {\n          if (err) throw err;else options.credentials = creds;\n        });\n        this.constructor(options);\n        return this;\n      },\n\n      /**\n       * Clears configuration data on this object\n       *\n       * @api private\n       */\n      clear: function clear() {\n        /*jshint forin:false */\n        AWS.util.each.call(this, this.keys, function (key) {\n          delete this[key];\n        }); // reset credential provider\n\n        this.set('credentials', undefined);\n        this.set('credentialProvider', undefined);\n      },\n\n      /**\n       * Sets a property on the configuration object, allowing for a\n       * default value\n       * @api private\n       */\n      set: function set(property, value, defaultValue) {\n        if (value === undefined) {\n          if (defaultValue === undefined) {\n            defaultValue = this.keys[property];\n          }\n\n          if (typeof defaultValue === 'function') {\n            this[property] = defaultValue.call(this);\n          } else {\n            this[property] = defaultValue;\n          }\n        } else if (property === 'httpOptions' && this[property]) {\n          // deep merge httpOptions\n          this[property] = AWS.util.merge(this[property], value);\n        } else {\n          this[property] = value;\n        }\n      },\n\n      /**\n       * All of the keys with their default values.\n       *\n       * @constant\n       * @api private\n       */\n      keys: {\n        credentials: null,\n        credentialProvider: null,\n        region: null,\n        logger: null,\n        apiVersions: {},\n        apiVersion: null,\n        endpoint: undefined,\n        httpOptions: {\n          timeout: 120000\n        },\n        maxRetries: undefined,\n        maxRedirects: 10,\n        paramValidation: true,\n        sslEnabled: true,\n        s3ForcePathStyle: false,\n        s3BucketEndpoint: false,\n        s3DisableBodySigning: true,\n        computeChecksums: true,\n        convertResponseTypes: true,\n        correctClockSkew: false,\n        customUserAgent: null,\n        dynamoDbCrc32: true,\n        systemClockOffset: 0,\n        signatureVersion: null,\n        signatureCache: true,\n        retryDelayOptions: {},\n        useAccelerateEndpoint: false,\n        clientSideMonitoring: false,\n        endpointDiscoveryEnabled: false,\n        endpointCacheSize: 1000,\n        hostPrefixEnabled: true,\n        stsRegionalEndpoints: null\n      },\n\n      /**\n       * Extracts accessKeyId, secretAccessKey and sessionToken\n       * from a configuration hash.\n       *\n       * @api private\n       */\n      extractCredentials: function extractCredentials(options) {\n        if (options.accessKeyId && options.secretAccessKey) {\n          options = AWS.util.copy(options);\n          options.credentials = new AWS.Credentials(options);\n        }\n\n        return options;\n      },\n\n      /**\n       * Sets the promise dependency the SDK will use wherever Promises are returned.\n       * Passing `null` will force the SDK to use native Promises if they are available.\n       * If native Promises are not available, passing `null` will have no effect.\n       * @param [Constructor] dep A reference to a Promise constructor\n       */\n      setPromisesDependency: function setPromisesDependency(dep) {\n        PromisesDependency = dep; // if null was passed in, we should try to use native promises\n\n        if (dep === null && typeof Promise === 'function') {\n          PromisesDependency = Promise;\n        }\n\n        var constructors = [AWS.Request, AWS.Credentials, AWS.CredentialProviderChain];\n\n        if (AWS.S3) {\n          constructors.push(AWS.S3);\n\n          if (AWS.S3.ManagedUpload) {\n            constructors.push(AWS.S3.ManagedUpload);\n          }\n        }\n\n        AWS.util.addPromises(constructors, PromisesDependency);\n      },\n\n      /**\n       * Gets the promise dependency set by `AWS.config.setPromisesDependency`.\n       */\n      getPromisesDependency: function getPromisesDependency() {\n        return PromisesDependency;\n      }\n    });\n    /**\n     * @return [AWS.Config] The global configuration object singleton instance\n     * @readonly\n     * @see AWS.Config\n     */\n\n    AWS.config = new AWS.Config();\n  }, {\n    \"./core\": 18,\n    \"./credentials\": 19,\n    \"./credentials/credential_provider_chain\": 22\n  }],\n  18: [function (require, module, exports) {\n    /**\n     * The main AWS namespace\n     */\n    var AWS = {\n      util: require('./util')\n    };\n    /**\n     * @api private\n     * @!macro [new] nobrowser\n     *   @note This feature is not supported in the browser environment of the SDK.\n     */\n\n    var _hidden = {};\n\n    _hidden.toString(); // hack to parse macro\n\n    /**\n     * @api private\n     */\n\n\n    module.exports = AWS;\n    AWS.util.update(AWS, {\n      /**\n       * @constant\n       */\n      VERSION: '2.553.0',\n\n      /**\n       * @api private\n       */\n      Signers: {},\n\n      /**\n       * @api private\n       */\n      Protocol: {\n        Json: require('./protocol/json'),\n        Query: require('./protocol/query'),\n        Rest: require('./protocol/rest'),\n        RestJson: require('./protocol/rest_json'),\n        RestXml: require('./protocol/rest_xml')\n      },\n\n      /**\n       * @api private\n       */\n      XML: {\n        Builder: require('./xml/builder'),\n        Parser: null // conditionally set based on environment\n\n      },\n\n      /**\n       * @api private\n       */\n      JSON: {\n        Builder: require('./json/builder'),\n        Parser: require('./json/parser')\n      },\n\n      /**\n       * @api private\n       */\n      Model: {\n        Api: require('./model/api'),\n        Operation: require('./model/operation'),\n        Shape: require('./model/shape'),\n        Paginator: require('./model/paginator'),\n        ResourceWaiter: require('./model/resource_waiter')\n      },\n\n      /**\n       * @api private\n       */\n      apiLoader: require('./api_loader'),\n\n      /**\n       * @api private\n       */\n      EndpointCache: require('../vendor/endpoint-cache').EndpointCache\n    });\n\n    require('./sequential_executor');\n\n    require('./service');\n\n    require('./config');\n\n    require('./http');\n\n    require('./event_listeners');\n\n    require('./request');\n\n    require('./response');\n\n    require('./resource_waiter');\n\n    require('./signers/request_signer');\n\n    require('./param_validator');\n    /**\n     * @readonly\n     * @return [AWS.SequentialExecutor] a collection of global event listeners that\n     *   are attached to every sent request.\n     * @see AWS.Request AWS.Request for a list of events to listen for\n     * @example Logging the time taken to send a request\n     *   AWS.events.on('send', function startSend(resp) {\n     *     resp.startTime = new Date().getTime();\n     *   }).on('complete', function calculateTime(resp) {\n     *     var time = (new Date().getTime() - resp.startTime) / 1000;\n     *     console.log('Request took ' + time + ' seconds');\n     *   });\n     *\n     *   new AWS.S3().listBuckets(); // prints 'Request took 0.285 seconds'\n     */\n\n\n    AWS.events = new AWS.SequentialExecutor(); //create endpoint cache lazily\n\n    AWS.util.memoizedProperty(AWS, 'endpointCache', function () {\n      return new AWS.EndpointCache(AWS.config.endpointCacheSize);\n    }, true);\n  }, {\n    \"../vendor/endpoint-cache\": 103,\n    \"./api_loader\": 9,\n    \"./config\": 17,\n    \"./event_listeners\": 33,\n    \"./http\": 34,\n    \"./json/builder\": 36,\n    \"./json/parser\": 37,\n    \"./model/api\": 38,\n    \"./model/operation\": 40,\n    \"./model/paginator\": 41,\n    \"./model/resource_waiter\": 42,\n    \"./model/shape\": 43,\n    \"./param_validator\": 44,\n    \"./protocol/json\": 46,\n    \"./protocol/query\": 47,\n    \"./protocol/rest\": 48,\n    \"./protocol/rest_json\": 49,\n    \"./protocol/rest_xml\": 50,\n    \"./request\": 55,\n    \"./resource_waiter\": 56,\n    \"./response\": 57,\n    \"./sequential_executor\": 58,\n    \"./service\": 59,\n    \"./signers/request_signer\": 63,\n    \"./util\": 71,\n    \"./xml/builder\": 73\n  }],\n  19: [function (require, module, exports) {\n    var AWS = require('./core');\n    /**\n     * Represents your AWS security credentials, specifically the\n     * {accessKeyId}, {secretAccessKey}, and optional {sessionToken}.\n     * Creating a `Credentials` object allows you to pass around your\n     * security information to configuration and service objects.\n     *\n     * Note that this class typically does not need to be constructed manually,\n     * as the {AWS.Config} and {AWS.Service} classes both accept simple\n     * options hashes with the three keys. These structures will be converted\n     * into Credentials objects automatically.\n     *\n     * ## Expiring and Refreshing Credentials\n     *\n     * Occasionally credentials can expire in the middle of a long-running\n     * application. In this case, the SDK will automatically attempt to\n     * refresh the credentials from the storage location if the Credentials\n     * class implements the {refresh} method.\n     *\n     * If you are implementing a credential storage location, you\n     * will want to create a subclass of the `Credentials` class and\n     * override the {refresh} method. This method allows credentials to be\n     * retrieved from the backing store, be it a file system, database, or\n     * some network storage. The method should reset the credential attributes\n     * on the object.\n     *\n     * @!attribute expired\n     *   @return [Boolean] whether the credentials have been expired and\n     *     require a refresh. Used in conjunction with {expireTime}.\n     * @!attribute expireTime\n     *   @return [Date] a time when credentials should be considered expired. Used\n     *     in conjunction with {expired}.\n     * @!attribute accessKeyId\n     *   @return [String] the AWS access key ID\n     * @!attribute secretAccessKey\n     *   @return [String] the AWS secret access key\n     * @!attribute sessionToken\n     *   @return [String] an optional AWS session token\n     */\n\n\n    AWS.Credentials = AWS.util.inherit({\n      /**\n       * A credentials object can be created using positional arguments or an options\n       * hash.\n       *\n       * @overload AWS.Credentials(accessKeyId, secretAccessKey, sessionToken=null)\n       *   Creates a Credentials object with a given set of credential information\n       *   as positional arguments.\n       *   @param accessKeyId [String] the AWS access key ID\n       *   @param secretAccessKey [String] the AWS secret access key\n       *   @param sessionToken [String] the optional AWS session token\n       *   @example Create a credentials object with AWS credentials\n       *     var creds = new AWS.Credentials('akid', 'secret', 'session');\n       * @overload AWS.Credentials(options)\n       *   Creates a Credentials object with a given set of credential information\n       *   as an options hash.\n       *   @option options accessKeyId [String] the AWS access key ID\n       *   @option options secretAccessKey [String] the AWS secret access key\n       *   @option options sessionToken [String] the optional AWS session token\n       *   @example Create a credentials object with AWS credentials\n       *     var creds = new AWS.Credentials({\n       *       accessKeyId: 'akid', secretAccessKey: 'secret', sessionToken: 'session'\n       *     });\n       */\n      constructor: function Credentials() {\n        // hide secretAccessKey from being displayed with util.inspect\n        AWS.util.hideProperties(this, ['secretAccessKey']);\n        this.expired = false;\n        this.expireTime = null;\n        this.refreshCallbacks = [];\n\n        if (arguments.length === 1 && typeof arguments[0] === 'object') {\n          var creds = arguments[0].credentials || arguments[0];\n          this.accessKeyId = creds.accessKeyId;\n          this.secretAccessKey = creds.secretAccessKey;\n          this.sessionToken = creds.sessionToken;\n        } else {\n          this.accessKeyId = arguments[0];\n          this.secretAccessKey = arguments[1];\n          this.sessionToken = arguments[2];\n        }\n      },\n\n      /**\n       * @return [Integer] the number of seconds before {expireTime} during which\n       *   the credentials will be considered expired.\n       */\n      expiryWindow: 15,\n\n      /**\n       * @return [Boolean] whether the credentials object should call {refresh}\n       * @note Subclasses should override this method to provide custom refresh\n       *   logic.\n       */\n      needsRefresh: function needsRefresh() {\n        var currentTime = AWS.util.date.getDate().getTime();\n        var adjustedTime = new Date(currentTime + this.expiryWindow * 1000);\n\n        if (this.expireTime && adjustedTime > this.expireTime) {\n          return true;\n        } else {\n          return this.expired || !this.accessKeyId || !this.secretAccessKey;\n        }\n      },\n\n      /**\n       * Gets the existing credentials, refreshing them if they are not yet loaded\n       * or have expired. Users should call this method before using {refresh},\n       * as this will not attempt to reload credentials when they are already\n       * loaded into the object.\n       *\n       * @callback callback function(err)\n       *   When this callback is called with no error, it means either credentials\n       *   do not need to be refreshed or refreshed credentials information has\n       *   been loaded into the object (as the `accessKeyId`, `secretAccessKey`,\n       *   and `sessionToken` properties).\n       *   @param err [Error] if an error occurred, this value will be filled\n       */\n      get: function get(callback) {\n        var self = this;\n\n        if (this.needsRefresh()) {\n          this.refresh(function (err) {\n            if (!err) self.expired = false; // reset expired flag\n\n            if (callback) callback(err);\n          });\n        } else if (callback) {\n          callback();\n        }\n      },\n\n      /**\n       * @!method  getPromise()\n       *   Returns a 'thenable' promise.\n       *   Gets the existing credentials, refreshing them if they are not yet loaded\n       *   or have expired. Users should call this method before using {refresh},\n       *   as this will not attempt to reload credentials when they are already\n       *   loaded into the object.\n       *\n       *   Two callbacks can be provided to the `then` method on the returned promise.\n       *   The first callback will be called if the promise is fulfilled, and the second\n       *   callback will be called if the promise is rejected.\n       *   @callback fulfilledCallback function()\n       *     Called if the promise is fulfilled. When this callback is called, it\n       *     means either credentials do not need to be refreshed or refreshed\n       *     credentials information has been loaded into the object (as the\n       *     `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).\n       *   @callback rejectedCallback function(err)\n       *     Called if the promise is rejected.\n       *     @param err [Error] if an error occurred, this value will be filled\n       *   @return [Promise] A promise that represents the state of the `get` call.\n       *   @example Calling the `getPromise` method.\n       *     var promise = credProvider.getPromise();\n       *     promise.then(function() { ... }, function(err) { ... });\n       */\n\n      /**\n       * @!method  refreshPromise()\n       *   Returns a 'thenable' promise.\n       *   Refreshes the credentials. Users should call {get} before attempting\n       *   to forcibly refresh credentials.\n       *\n       *   Two callbacks can be provided to the `then` method on the returned promise.\n       *   The first callback will be called if the promise is fulfilled, and the second\n       *   callback will be called if the promise is rejected.\n       *   @callback fulfilledCallback function()\n       *     Called if the promise is fulfilled. When this callback is called, it\n       *     means refreshed credentials information has been loaded into the object\n       *     (as the `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).\n       *   @callback rejectedCallback function(err)\n       *     Called if the promise is rejected.\n       *     @param err [Error] if an error occurred, this value will be filled\n       *   @return [Promise] A promise that represents the state of the `refresh` call.\n       *   @example Calling the `refreshPromise` method.\n       *     var promise = credProvider.refreshPromise();\n       *     promise.then(function() { ... }, function(err) { ... });\n       */\n\n      /**\n       * Refreshes the credentials. Users should call {get} before attempting\n       * to forcibly refresh credentials.\n       *\n       * @callback callback function(err)\n       *   When this callback is called with no error, it means refreshed\n       *   credentials information has been loaded into the object (as the\n       *   `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).\n       *   @param err [Error] if an error occurred, this value will be filled\n       * @note Subclasses should override this class to reset the\n       *   {accessKeyId}, {secretAccessKey} and optional {sessionToken}\n       *   on the credentials object and then call the callback with\n       *   any error information.\n       * @see get\n       */\n      refresh: function refresh(callback) {\n        this.expired = false;\n        callback();\n      },\n\n      /**\n       * @api private\n       * @param callback\n       */\n      coalesceRefresh: function coalesceRefresh(callback, sync) {\n        var self = this;\n\n        if (self.refreshCallbacks.push(callback) === 1) {\n          self.load(function onLoad(err) {\n            AWS.util.arrayEach(self.refreshCallbacks, function (callback) {\n              if (sync) {\n                callback(err);\n              } else {\n                // callback could throw, so defer to ensure all callbacks are notified\n                AWS.util.defer(function () {\n                  callback(err);\n                });\n              }\n            });\n            self.refreshCallbacks.length = 0;\n          });\n        }\n      },\n\n      /**\n       * @api private\n       * @param callback\n       */\n      load: function load(callback) {\n        callback();\n      }\n    });\n    /**\n     * @api private\n     */\n\n    AWS.Credentials.addPromisesToClass = function addPromisesToClass(PromiseDependency) {\n      this.prototype.getPromise = AWS.util.promisifyMethod('get', PromiseDependency);\n      this.prototype.refreshPromise = AWS.util.promisifyMethod('refresh', PromiseDependency);\n    };\n    /**\n     * @api private\n     */\n\n\n    AWS.Credentials.deletePromisesFromClass = function deletePromisesFromClass() {\n      delete this.prototype.getPromise;\n      delete this.prototype.refreshPromise;\n    };\n\n    AWS.util.addPromises(AWS.Credentials);\n  }, {\n    \"./core\": 18\n  }],\n  20: [function (require, module, exports) {\n    var AWS = require('../core');\n\n    var STS = require('../../clients/sts');\n    /**\n     * Represents temporary credentials retrieved from {AWS.STS}. Without any\n     * extra parameters, credentials will be fetched from the\n     * {AWS.STS.getSessionToken} operation. If an IAM role is provided, the\n     * {AWS.STS.assumeRole} operation will be used to fetch credentials for the\n     * role instead.\n     *\n     * AWS.ChainableTemporaryCredentials differs from AWS.TemporaryCredentials in\n     * the way masterCredentials and refreshes are handled.\n     * AWS.ChainableTemporaryCredentials refreshes expired credentials using the\n     * masterCredentials passed by the user to support chaining of STS credentials.\n     * However, AWS.TemporaryCredentials recursively collapses the masterCredentials\n     * during instantiation, precluding the ability to refresh credentials which\n     * require intermediate, temporary credentials.\n     *\n     * For example, if the application should use RoleA, which must be assumed from\n     * RoleB, and the environment provides credentials which can assume RoleB, then\n     * AWS.ChainableTemporaryCredentials must be used to support refreshing the\n     * temporary credentials for RoleA:\n     *\n     * ```javascript\n     * var roleACreds = new AWS.ChainableTemporaryCredentials({\n     *   params: {RoleArn: 'RoleA'},\n     *   masterCredentials: new AWS.ChainableTemporaryCredentials({\n     *     params: {RoleArn: 'RoleB'},\n     *     masterCredentials: new AWS.EnvironmentCredentials('AWS')\n     *   })\n     * });\n     * ```\n     *\n     * If AWS.TemporaryCredentials had been used in the previous example,\n     * `roleACreds` would fail to refresh because `roleACreds` would\n     * use the environment credentials for the AssumeRole request.\n     *\n     * Another difference is that AWS.ChainableTemporaryCredentials creates the STS\n     * service instance during instantiation while AWS.TemporaryCredentials creates\n     * the STS service instance during the first refresh. Creating the service\n     * instance during instantiation effectively captures the master credentials\n     * from the global config, so that subsequent changes to the global config do\n     * not affect the master credentials used to refresh the temporary credentials.\n     *\n     * This allows an instance of AWS.ChainableTemporaryCredentials to be assigned\n     * to AWS.config.credentials:\n     *\n     * ```javascript\n     * var envCreds = new AWS.EnvironmentCredentials('AWS');\n     * AWS.config.credentials = envCreds;\n     * // masterCredentials will be envCreds\n     * AWS.config.credentials = new AWS.ChainableTemporaryCredentials({\n     *   params: {RoleArn: '...'}\n     * });\n     * ```\n     *\n     * Similarly, to use the CredentialProviderChain's default providers as the\n     * master credentials, simply create a new instance of\n     * AWS.ChainableTemporaryCredentials:\n     *\n     * ```javascript\n     * AWS.config.credentials = new ChainableTemporaryCredentials({\n     *   params: {RoleArn: '...'}\n     * });\n     * ```\n     *\n     * @!attribute service\n     *   @return [AWS.STS] the STS service instance used to\n     *     get and refresh temporary credentials from AWS STS.\n     * @note (see constructor)\n     */\n\n\n    AWS.ChainableTemporaryCredentials = AWS.util.inherit(AWS.Credentials, {\n      /**\n       * Creates a new temporary credentials object.\n       *\n       * @param options [map] a set of options\n       * @option options params [map] ({}) a map of options that are passed to the\n       *   {AWS.STS.assumeRole} or {AWS.STS.getSessionToken} operations.\n       *   If a `RoleArn` parameter is passed in, credentials will be based on the\n       *   IAM role. If a `SerialNumber` parameter is passed in, {tokenCodeFn} must\n       *   also be passed in or an error will be thrown.\n       * @option options masterCredentials [AWS.Credentials] the master credentials\n       *   used to get and refresh temporary credentials from AWS STS. By default,\n       *   AWS.config.credentials or AWS.config.credentialProvider will be used.\n       * @option options tokenCodeFn [Function] (null) Function to provide\n       *   `TokenCode`, if `SerialNumber` is provided for profile in {params}. Function\n       *   is called with value of `SerialNumber` and `callback`, and should provide\n       *   the `TokenCode` or an error to the callback in the format\n       *   `callback(err, token)`.\n       * @example Creating a new credentials object for generic temporary credentials\n       *   AWS.config.credentials = new AWS.ChainableTemporaryCredentials();\n       * @example Creating a new credentials object for an IAM role\n       *   AWS.config.credentials = new AWS.ChainableTemporaryCredentials({\n       *     params: {\n       *       RoleArn: 'arn:aws:iam::1234567890:role/TemporaryCredentials'\n       *     }\n       *   });\n       * @see AWS.STS.assumeRole\n       * @see AWS.STS.getSessionToken\n       */\n      constructor: function ChainableTemporaryCredentials(options) {\n        AWS.Credentials.call(this);\n        options = options || {};\n        this.errorCode = 'ChainableTemporaryCredentialsProviderFailure';\n        this.expired = true;\n        this.tokenCodeFn = null;\n        var params = AWS.util.copy(options.params) || {};\n\n        if (params.RoleArn) {\n          params.RoleSessionName = params.RoleSessionName || 'temporary-credentials';\n        }\n\n        if (params.SerialNumber) {\n          if (!options.tokenCodeFn || typeof options.tokenCodeFn !== 'function') {\n            throw new AWS.util.error(new Error('tokenCodeFn must be a function when params.SerialNumber is given'), {\n              code: this.errorCode\n            });\n          } else {\n            this.tokenCodeFn = options.tokenCodeFn;\n          }\n        }\n\n        var config = AWS.util.merge({\n          params: params,\n          credentials: options.masterCredentials || AWS.config.credentials\n        }, options.stsConfig || {});\n        this.service = new STS(config);\n      },\n\n      /**\n       * Refreshes credentials using {AWS.STS.assumeRole} or\n       * {AWS.STS.getSessionToken}, depending on whether an IAM role ARN was passed\n       * to the credentials {constructor}.\n       *\n       * @callback callback function(err)\n       *   Called when the STS service responds (or fails). When\n       *   this callback is called with no error, it means that the credentials\n       *   information has been loaded into the object (as the `accessKeyId`,\n       *   `secretAccessKey`, and `sessionToken` properties).\n       *   @param err [Error] if an error occurred, this value will be filled\n       * @see AWS.Credentials.get\n       */\n      refresh: function refresh(callback) {\n        this.coalesceRefresh(callback || AWS.util.fn.callback);\n      },\n\n      /**\n       * @api private\n       * @param callback\n       */\n      load: function load(callback) {\n        var self = this;\n        var operation = self.service.config.params.RoleArn ? 'assumeRole' : 'getSessionToken';\n        this.getTokenCode(function (err, tokenCode) {\n          var params = {};\n\n          if (err) {\n            callback(err);\n            return;\n          }\n\n          if (tokenCode) {\n            params.TokenCode = tokenCode;\n          }\n\n          self.service[operation](params, function (err, data) {\n            if (!err) {\n              self.service.credentialsFrom(data, self);\n            }\n\n            callback(err);\n          });\n        });\n      },\n\n      /**\n       * @api private\n       */\n      getTokenCode: function getTokenCode(callback) {\n        var self = this;\n\n        if (this.tokenCodeFn) {\n          this.tokenCodeFn(this.service.config.params.SerialNumber, function (err, token) {\n            if (err) {\n              var message = err;\n\n              if (err instanceof Error) {\n                message = err.message;\n              }\n\n              callback(AWS.util.error(new Error('Error fetching MFA token: ' + message), {\n                code: self.errorCode\n              }));\n              return;\n            }\n\n            callback(null, token);\n          });\n        } else {\n          callback(null);\n        }\n      }\n    });\n  }, {\n    \"../../clients/sts\": 8,\n    \"../core\": 18\n  }],\n  21: [function (require, module, exports) {\n    var AWS = require('../core');\n\n    var CognitoIdentity = require('../../clients/cognitoidentity');\n\n    var STS = require('../../clients/sts');\n    /**\n     * Represents credentials retrieved from STS Web Identity Federation using\n     * the Amazon Cognito Identity service.\n     *\n     * By default this provider gets credentials using the\n     * {AWS.CognitoIdentity.getCredentialsForIdentity} service operation, which\n     * requires either an `IdentityId` or an `IdentityPoolId` (Amazon Cognito\n     * Identity Pool ID), which is used to call {AWS.CognitoIdentity.getId} to\n     * obtain an `IdentityId`. If the identity or identity pool is not configured in\n     * the Amazon Cognito Console to use IAM roles with the appropriate permissions,\n     * then additionally a `RoleArn` is required containing the ARN of the IAM trust\n     * policy for the Amazon Cognito role that the user will log into. If a `RoleArn`\n     * is provided, then this provider gets credentials using the\n     * {AWS.STS.assumeRoleWithWebIdentity} service operation, after first getting an\n     * Open ID token from {AWS.CognitoIdentity.getOpenIdToken}.\n     *\n     * In addition, if this credential provider is used to provide authenticated\n     * login, the `Logins` map may be set to the tokens provided by the respective\n     * identity providers. See {constructor} for an example on creating a credentials\n     * object with proper property values.\n     *\n     * ## Refreshing Credentials from Identity Service\n     *\n     * In addition to AWS credentials expiring after a given amount of time, the\n     * login token from the identity provider will also expire. Once this token\n     * expires, it will not be usable to refresh AWS credentials, and another\n     * token will be needed. The SDK does not manage refreshing of the token value,\n     * but this can be done through a \"refresh token\" supported by most identity\n     * providers. Consult the documentation for the identity provider for refreshing\n     * tokens. Once the refreshed token is acquired, you should make sure to update\n     * this new token in the credentials object's {params} property. The following\n     * code will update the WebIdentityToken, assuming you have retrieved an updated\n     * token from the identity provider:\n     *\n     * ```javascript\n     * AWS.config.credentials.params.Logins['graph.facebook.com'] = updatedToken;\n     * ```\n     *\n     * Future calls to `credentials.refresh()` will now use the new token.\n     *\n     * @!attribute params\n     *   @return [map] the map of params passed to\n     *     {AWS.CognitoIdentity.getId},\n     *     {AWS.CognitoIdentity.getOpenIdToken}, and\n     *     {AWS.STS.assumeRoleWithWebIdentity}. To update the token, set the\n     *     `params.WebIdentityToken` property.\n     * @!attribute data\n     *   @return [map] the raw data response from the call to\n     *     {AWS.CognitoIdentity.getCredentialsForIdentity}, or\n     *     {AWS.STS.assumeRoleWithWebIdentity}. Use this if you want to get\n     *     access to other properties from the response.\n     * @!attribute identityId\n     *   @return [String] the Cognito ID returned by the last call to\n     *     {AWS.CognitoIdentity.getOpenIdToken}. This ID represents the actual\n     *     final resolved identity ID from Amazon Cognito.\n     */\n\n\n    AWS.CognitoIdentityCredentials = AWS.util.inherit(AWS.Credentials, {\n      /**\n       * @api private\n       */\n      localStorageKey: {\n        id: 'aws.cognito.identity-id.',\n        providers: 'aws.cognito.identity-providers.'\n      },\n\n      /**\n       * Creates a new credentials object.\n       * @example Creating a new credentials object\n       *   AWS.config.credentials = new AWS.CognitoIdentityCredentials({\n       *\n       *     // either IdentityPoolId or IdentityId is required\n       *     // See the IdentityPoolId param for AWS.CognitoIdentity.getID (linked below)\n       *     // See the IdentityId param for AWS.CognitoIdentity.getCredentialsForIdentity\n       *     // or AWS.CognitoIdentity.getOpenIdToken (linked below)\n       *     IdentityPoolId: 'us-east-1:1699ebc0-7900-4099-b910-2df94f52a030',\n       *     IdentityId: 'us-east-1:128d0a74-c82f-4553-916d-90053e4a8b0f'\n       *\n       *     // optional, only necessary when the identity pool is not configured\n       *     // to use IAM roles in the Amazon Cognito Console\n       *     // See the RoleArn param for AWS.STS.assumeRoleWithWebIdentity (linked below)\n       *     RoleArn: 'arn:aws:iam::1234567890:role/MYAPP-CognitoIdentity',\n       *\n       *     // optional tokens, used for authenticated login\n       *     // See the Logins param for AWS.CognitoIdentity.getID (linked below)\n       *     Logins: {\n       *       'graph.facebook.com': 'FBTOKEN',\n       *       'www.amazon.com': 'AMAZONTOKEN',\n       *       'accounts.google.com': 'GOOGLETOKEN',\n       *       'api.twitter.com': 'TWITTERTOKEN',\n       *       'www.digits.com': 'DIGITSTOKEN'\n       *     },\n       *\n       *     // optional name, defaults to web-identity\n       *     // See the RoleSessionName param for AWS.STS.assumeRoleWithWebIdentity (linked below)\n       *     RoleSessionName: 'web',\n       *\n       *     // optional, only necessary when application runs in a browser\n       *     // and multiple users are signed in at once, used for caching\n       *     LoginId: 'example@gmail.com'\n       *\n       *   }, {\n       *      // optionally provide configuration to apply to the underlying service clients\n       *      // if configuration is not provided, then configuration will be pulled from AWS.config\n       *\n       *      // region should match the region your identity pool is located in\n       *      region: 'us-east-1',\n       *\n       *      // specify timeout options\n       *      httpOptions: {\n       *        timeout: 100\n       *      }\n       *   });\n       * @see AWS.CognitoIdentity.getId\n       * @see AWS.CognitoIdentity.getCredentialsForIdentity\n       * @see AWS.STS.assumeRoleWithWebIdentity\n       * @see AWS.CognitoIdentity.getOpenIdToken\n       * @see AWS.Config\n       * @note If a region is not provided in the global AWS.config, or\n       *   specified in the `clientConfig` to the CognitoIdentityCredentials\n       *   constructor, you may encounter a 'Missing credentials in config' error\n       *   when calling making a service call.\n       */\n      constructor: function CognitoIdentityCredentials(params, clientConfig) {\n        AWS.Credentials.call(this);\n        this.expired = true;\n        this.params = params;\n        this.data = null;\n        this._identityId = null;\n        this._clientConfig = AWS.util.copy(clientConfig || {});\n        this.loadCachedId();\n        var self = this;\n        Object.defineProperty(this, 'identityId', {\n          get: function () {\n            self.loadCachedId();\n            return self._identityId || self.params.IdentityId;\n          },\n          set: function (identityId) {\n            self._identityId = identityId;\n          }\n        });\n      },\n\n      /**\n       * Refreshes credentials using {AWS.CognitoIdentity.getCredentialsForIdentity},\n       * or {AWS.STS.assumeRoleWithWebIdentity}.\n       *\n       * @callback callback function(err)\n       *   Called when the STS service responds (or fails). When\n       *   this callback is called with no error, it means that the credentials\n       *   information has been loaded into the object (as the `accessKeyId`,\n       *   `secretAccessKey`, and `sessionToken` properties).\n       *   @param err [Error] if an error occurred, this value will be filled\n       * @see AWS.Credentials.get\n       */\n      refresh: function refresh(callback) {\n        this.coalesceRefresh(callback || AWS.util.fn.callback);\n      },\n\n      /**\n       * @api private\n       * @param callback\n       */\n      load: function load(callback) {\n        var self = this;\n        self.createClients();\n        self.data = null;\n        self._identityId = null;\n        self.getId(function (err) {\n          if (!err) {\n            if (!self.params.RoleArn) {\n              self.getCredentialsForIdentity(callback);\n            } else {\n              self.getCredentialsFromSTS(callback);\n            }\n          } else {\n            self.clearIdOnNotAuthorized(err);\n            callback(err);\n          }\n        });\n      },\n\n      /**\n       * Clears the cached Cognito ID associated with the currently configured\n       * identity pool ID. Use this to manually invalidate your cache if\n       * the identity pool ID was deleted.\n       */\n      clearCachedId: function clearCache() {\n        this._identityId = null;\n        delete this.params.IdentityId;\n        var poolId = this.params.IdentityPoolId;\n        var loginId = this.params.LoginId || '';\n        delete this.storage[this.localStorageKey.id + poolId + loginId];\n        delete this.storage[this.localStorageKey.providers + poolId + loginId];\n      },\n\n      /**\n       * @api private\n       */\n      clearIdOnNotAuthorized: function clearIdOnNotAuthorized(err) {\n        var self = this;\n\n        if (err.code == 'NotAuthorizedException') {\n          self.clearCachedId();\n        }\n      },\n\n      /**\n       * Retrieves a Cognito ID, loading from cache if it was already retrieved\n       * on this device.\n       *\n       * @callback callback function(err, identityId)\n       *   @param err [Error, null] an error object if the call failed or null if\n       *     it succeeded.\n       *   @param identityId [String, null] if successful, the callback will return\n       *     the Cognito ID.\n       * @note If not loaded explicitly, the Cognito ID is loaded and stored in\n       *   localStorage in the browser environment of a device.\n       * @api private\n       */\n      getId: function getId(callback) {\n        var self = this;\n\n        if (typeof self.params.IdentityId === 'string') {\n          return callback(null, self.params.IdentityId);\n        }\n\n        self.cognito.getId(function (err, data) {\n          if (!err && data.IdentityId) {\n            self.params.IdentityId = data.IdentityId;\n            callback(null, data.IdentityId);\n          } else {\n            callback(err);\n          }\n        });\n      },\n\n      /**\n       * @api private\n       */\n      loadCredentials: function loadCredentials(data, credentials) {\n        if (!data || !credentials) return;\n        credentials.expired = false;\n        credentials.accessKeyId = data.Credentials.AccessKeyId;\n        credentials.secretAccessKey = data.Credentials.SecretKey;\n        credentials.sessionToken = data.Credentials.SessionToken;\n        credentials.expireTime = data.Credentials.Expiration;\n      },\n\n      /**\n       * @api private\n       */\n      getCredentialsForIdentity: function getCredentialsForIdentity(callback) {\n        var self = this;\n        self.cognito.getCredentialsForIdentity(function (err, data) {\n          if (!err) {\n            self.cacheId(data);\n            self.data = data;\n            self.loadCredentials(self.data, self);\n          } else {\n            self.clearIdOnNotAuthorized(err);\n          }\n\n          callback(err);\n        });\n      },\n\n      /**\n       * @api private\n       */\n      getCredentialsFromSTS: function getCredentialsFromSTS(callback) {\n        var self = this;\n        self.cognito.getOpenIdToken(function (err, data) {\n          if (!err) {\n            self.cacheId(data);\n            self.params.WebIdentityToken = data.Token;\n            self.webIdentityCredentials.refresh(function (webErr) {\n              if (!webErr) {\n                self.data = self.webIdentityCredentials.data;\n                self.sts.credentialsFrom(self.data, self);\n              }\n\n              callback(webErr);\n            });\n          } else {\n            self.clearIdOnNotAuthorized(err);\n            callback(err);\n          }\n        });\n      },\n\n      /**\n       * @api private\n       */\n      loadCachedId: function loadCachedId() {\n        var self = this; // in the browser we source default IdentityId from localStorage\n\n        if (AWS.util.isBrowser() && !self.params.IdentityId) {\n          var id = self.getStorage('id');\n\n          if (id && self.params.Logins) {\n            var actualProviders = Object.keys(self.params.Logins);\n            var cachedProviders = (self.getStorage('providers') || '').split(','); // only load ID if at least one provider used this ID before\n\n            var intersect = cachedProviders.filter(function (n) {\n              return actualProviders.indexOf(n) !== -1;\n            });\n\n            if (intersect.length !== 0) {\n              self.params.IdentityId = id;\n            }\n          } else if (id) {\n            self.params.IdentityId = id;\n          }\n        }\n      },\n\n      /**\n       * @api private\n       */\n      createClients: function () {\n        var clientConfig = this._clientConfig;\n        this.webIdentityCredentials = this.webIdentityCredentials || new AWS.WebIdentityCredentials(this.params, clientConfig);\n\n        if (!this.cognito) {\n          var cognitoConfig = AWS.util.merge({}, clientConfig);\n          cognitoConfig.params = this.params;\n          this.cognito = new CognitoIdentity(cognitoConfig);\n        }\n\n        this.sts = this.sts || new STS(clientConfig);\n      },\n\n      /**\n       * @api private\n       */\n      cacheId: function cacheId(data) {\n        this._identityId = data.IdentityId;\n        this.params.IdentityId = this._identityId; // cache this IdentityId in browser localStorage if possible\n\n        if (AWS.util.isBrowser()) {\n          this.setStorage('id', data.IdentityId);\n\n          if (this.params.Logins) {\n            this.setStorage('providers', Object.keys(this.params.Logins).join(','));\n          }\n        }\n      },\n\n      /**\n       * @api private\n       */\n      getStorage: function getStorage(key) {\n        return this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || '')];\n      },\n\n      /**\n       * @api private\n       */\n      setStorage: function setStorage(key, val) {\n        try {\n          this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || '')] = val;\n        } catch (_) {}\n      },\n\n      /**\n       * @api private\n       */\n      storage: function () {\n        try {\n          var storage = AWS.util.isBrowser() && window.localStorage !== null && typeof window.localStorage === 'object' ? window.localStorage : {}; // Test set/remove which would throw an error in Safari's private browsing\n\n          storage['aws.test-storage'] = 'foobar';\n          delete storage['aws.test-storage'];\n          return storage;\n        } catch (_) {\n          return {};\n        }\n      }()\n    });\n  }, {\n    \"../../clients/cognitoidentity\": 7,\n    \"../../clients/sts\": 8,\n    \"../core\": 18\n  }],\n  22: [function (require, module, exports) {\n    var AWS = require('../core');\n    /**\n     * Creates a credential provider chain that searches for AWS credentials\n     * in a list of credential providers specified by the {providers} property.\n     *\n     * By default, the chain will use the {defaultProviders} to resolve credentials.\n     * These providers will look in the environment using the\n     * {AWS.EnvironmentCredentials} class with the 'AWS' and 'AMAZON' prefixes.\n     *\n     * ## Setting Providers\n     *\n     * Each provider in the {providers} list should be a function that returns\n     * a {AWS.Credentials} object, or a hardcoded credentials object. The function\n     * form allows for delayed execution of the credential construction.\n     *\n     * ## Resolving Credentials from a Chain\n     *\n     * Call {resolve} to return the first valid credential object that can be\n     * loaded by the provider chain.\n     *\n     * For example, to resolve a chain with a custom provider that checks a file\n     * on disk after the set of {defaultProviders}:\n     *\n     * ```javascript\n     * var diskProvider = new AWS.FileSystemCredentials('./creds.json');\n     * var chain = new AWS.CredentialProviderChain();\n     * chain.providers.push(diskProvider);\n     * chain.resolve();\n     * ```\n     *\n     * The above code will return the `diskProvider` object if the\n     * file contains credentials and the `defaultProviders` do not contain\n     * any credential settings.\n     *\n     * @!attribute providers\n     *   @return [Array<AWS.Credentials, Function>]\n     *     a list of credentials objects or functions that return credentials\n     *     objects. If the provider is a function, the function will be\n     *     executed lazily when the provider needs to be checked for valid\n     *     credentials. By default, this object will be set to the\n     *     {defaultProviders}.\n     *   @see defaultProviders\n     */\n\n\n    AWS.CredentialProviderChain = AWS.util.inherit(AWS.Credentials, {\n      /**\n       * Creates a new CredentialProviderChain with a default set of providers\n       * specified by {defaultProviders}.\n       */\n      constructor: function CredentialProviderChain(providers) {\n        if (providers) {\n          this.providers = providers;\n        } else {\n          this.providers = AWS.CredentialProviderChain.defaultProviders.slice(0);\n        }\n\n        this.resolveCallbacks = [];\n      },\n\n      /**\n       * @!method  resolvePromise()\n       *   Returns a 'thenable' promise.\n       *   Resolves the provider chain by searching for the first set of\n       *   credentials in {providers}.\n       *\n       *   Two callbacks can be provided to the `then` method on the returned promise.\n       *   The first callback will be called if the promise is fulfilled, and the second\n       *   callback will be called if the promise is rejected.\n       *   @callback fulfilledCallback function(credentials)\n       *     Called if the promise is fulfilled and the provider resolves the chain\n       *     to a credentials object\n       *     @param credentials [AWS.Credentials] the credentials object resolved\n       *       by the provider chain.\n       *   @callback rejectedCallback function(error)\n       *     Called if the promise is rejected.\n       *     @param err [Error] the error object returned if no credentials are found.\n       *   @return [Promise] A promise that represents the state of the `resolve` method call.\n       *   @example Calling the `resolvePromise` method.\n       *     var promise = chain.resolvePromise();\n       *     promise.then(function(credentials) { ... }, function(err) { ... });\n       */\n\n      /**\n       * Resolves the provider chain by searching for the first set of\n       * credentials in {providers}.\n       *\n       * @callback callback function(err, credentials)\n       *   Called when the provider resolves the chain to a credentials object\n       *   or null if no credentials can be found.\n       *\n       *   @param err [Error] the error object returned if no credentials are\n       *     found.\n       *   @param credentials [AWS.Credentials] the credentials object resolved\n       *     by the provider chain.\n       * @return [AWS.CredentialProviderChain] the provider, for chaining.\n       */\n      resolve: function resolve(callback) {\n        var self = this;\n\n        if (self.providers.length === 0) {\n          callback(new Error('No providers'));\n          return self;\n        }\n\n        if (self.resolveCallbacks.push(callback) === 1) {\n          var index = 0;\n          var providers = self.providers.slice(0);\n\n          function resolveNext(err, creds) {\n            if (!err && creds || index === providers.length) {\n              AWS.util.arrayEach(self.resolveCallbacks, function (callback) {\n                callback(err, creds);\n              });\n              self.resolveCallbacks.length = 0;\n              return;\n            }\n\n            var provider = providers[index++];\n\n            if (typeof provider === 'function') {\n              creds = provider.call();\n            } else {\n              creds = provider;\n            }\n\n            if (creds.get) {\n              creds.get(function (getErr) {\n                resolveNext(getErr, getErr ? null : creds);\n              });\n            } else {\n              resolveNext(null, creds);\n            }\n          }\n\n          resolveNext();\n        }\n\n        return self;\n      }\n    });\n    /**\n     * The default set of providers used by a vanilla CredentialProviderChain.\n     *\n     * In the browser:\n     *\n     * ```javascript\n     * AWS.CredentialProviderChain.defaultProviders = []\n     * ```\n     *\n     * In Node.js:\n     *\n     * ```javascript\n     * AWS.CredentialProviderChain.defaultProviders = [\n     *   function () { return new AWS.EnvironmentCredentials('AWS'); },\n     *   function () { return new AWS.EnvironmentCredentials('AMAZON'); },\n     *   function () { return new AWS.SharedIniFileCredentials(); },\n     *   function () { return new AWS.ECSCredentials(); },\n     *   function () { return new AWS.ProcessCredentials(); },\n     *   function () { return new AWS.TokenFileWebIdentityCredentials(); },\n     *   function () { return new AWS.EC2MetadataCredentials() }\n     * ]\n     * ```\n     */\n\n    AWS.CredentialProviderChain.defaultProviders = [];\n    /**\n     * @api private\n     */\n\n    AWS.CredentialProviderChain.addPromisesToClass = function addPromisesToClass(PromiseDependency) {\n      this.prototype.resolvePromise = AWS.util.promisifyMethod('resolve', PromiseDependency);\n    };\n    /**\n     * @api private\n     */\n\n\n    AWS.CredentialProviderChain.deletePromisesFromClass = function deletePromisesFromClass() {\n      delete this.prototype.resolvePromise;\n    };\n\n    AWS.util.addPromises(AWS.CredentialProviderChain);\n  }, {\n    \"../core\": 18\n  }],\n  23: [function (require, module, exports) {\n    var AWS = require('../core');\n\n    var STS = require('../../clients/sts');\n    /**\n     * Represents credentials retrieved from STS SAML support.\n     *\n     * By default this provider gets credentials using the\n     * {AWS.STS.assumeRoleWithSAML} service operation. This operation\n     * requires a `RoleArn` containing the ARN of the IAM trust policy for the\n     * application for which credentials will be given, as well as a `PrincipalArn`\n     * representing the ARN for the SAML identity provider. In addition, the\n     * `SAMLAssertion` must be set to the token provided by the identity\n     * provider. See {constructor} for an example on creating a credentials\n     * object with proper `RoleArn`, `PrincipalArn`, and `SAMLAssertion` values.\n     *\n     * ## Refreshing Credentials from Identity Service\n     *\n     * In addition to AWS credentials expiring after a given amount of time, the\n     * login token from the identity provider will also expire. Once this token\n     * expires, it will not be usable to refresh AWS credentials, and another\n     * token will be needed. The SDK does not manage refreshing of the token value,\n     * but this can be done through a \"refresh token\" supported by most identity\n     * providers. Consult the documentation for the identity provider for refreshing\n     * tokens. Once the refreshed token is acquired, you should make sure to update\n     * this new token in the credentials object's {params} property. The following\n     * code will update the SAMLAssertion, assuming you have retrieved an updated\n     * token from the identity provider:\n     *\n     * ```javascript\n     * AWS.config.credentials.params.SAMLAssertion = updatedToken;\n     * ```\n     *\n     * Future calls to `credentials.refresh()` will now use the new token.\n     *\n     * @!attribute params\n     *   @return [map] the map of params passed to\n     *     {AWS.STS.assumeRoleWithSAML}. To update the token, set the\n     *     `params.SAMLAssertion` property.\n     */\n\n\n    AWS.SAMLCredentials = AWS.util.inherit(AWS.Credentials, {\n      /**\n       * Creates a new credentials object.\n       * @param (see AWS.STS.assumeRoleWithSAML)\n       * @example Creating a new credentials object\n       *   AWS.config.credentials = new AWS.SAMLCredentials({\n       *     RoleArn: 'arn:aws:iam::1234567890:role/SAMLRole',\n       *     PrincipalArn: 'arn:aws:iam::1234567890:role/SAMLPrincipal',\n       *     SAMLAssertion: 'base64-token', // base64-encoded token from IdP\n       *   });\n       * @see AWS.STS.assumeRoleWithSAML\n       */\n      constructor: function SAMLCredentials(params) {\n        AWS.Credentials.call(this);\n        this.expired = true;\n        this.params = params;\n      },\n\n      /**\n       * Refreshes credentials using {AWS.STS.assumeRoleWithSAML}\n       *\n       * @callback callback function(err)\n       *   Called when the STS service responds (or fails). When\n       *   this callback is called with no error, it means that the credentials\n       *   information has been loaded into the object (as the `accessKeyId`,\n       *   `secretAccessKey`, and `sessionToken` properties).\n       *   @param err [Error] if an error occurred, this value will be filled\n       * @see get\n       */\n      refresh: function refresh(callback) {\n        this.coalesceRefresh(callback || AWS.util.fn.callback);\n      },\n\n      /**\n       * @api private\n       */\n      load: function load(callback) {\n        var self = this;\n        self.createClients();\n        self.service.assumeRoleWithSAML(function (err, data) {\n          if (!err) {\n            self.service.credentialsFrom(data, self);\n          }\n\n          callback(err);\n        });\n      },\n\n      /**\n       * @api private\n       */\n      createClients: function () {\n        this.service = this.service || new STS({\n          params: this.params\n        });\n      }\n    });\n  }, {\n    \"../../clients/sts\": 8,\n    \"../core\": 18\n  }],\n  24: [function (require, module, exports) {\n    var AWS = require('../core');\n\n    var STS = require('../../clients/sts');\n    /**\n     * Represents temporary credentials retrieved from {AWS.STS}. Without any\n     * extra parameters, credentials will be fetched from the\n     * {AWS.STS.getSessionToken} operation. If an IAM role is provided, the\n     * {AWS.STS.assumeRole} operation will be used to fetch credentials for the\n     * role instead.\n     *\n     * @note AWS.TemporaryCredentials is deprecated, but remains available for\n     *   backwards compatibility. {AWS.ChainableTemporaryCredentials} is the\n     *   preferred class for temporary credentials.\n     *\n     * To setup temporary credentials, configure a set of master credentials\n     * using the standard credentials providers (environment, EC2 instance metadata,\n     * or from the filesystem), then set the global credentials to a new\n     * temporary credentials object:\n     *\n     * ```javascript\n     * // Note that environment credentials are loaded by default,\n     * // the following line is shown for clarity:\n     * AWS.config.credentials = new AWS.EnvironmentCredentials('AWS');\n     *\n     * // Now set temporary credentials seeded from the master credentials\n     * AWS.config.credentials = new AWS.TemporaryCredentials();\n     *\n     * // subsequent requests will now use temporary credentials from AWS STS.\n     * new AWS.S3().listBucket(function(err, data) { ... });\n     * ```\n     *\n     * @!attribute masterCredentials\n     *   @return [AWS.Credentials] the master (non-temporary) credentials used to\n     *     get and refresh temporary credentials from AWS STS.\n     * @note (see constructor)\n     */\n\n\n    AWS.TemporaryCredentials = AWS.util.inherit(AWS.Credentials, {\n      /**\n       * Creates a new temporary credentials object.\n       *\n       * @note In order to create temporary credentials, you first need to have\n       *   \"master\" credentials configured in {AWS.Config.credentials}. These\n       *   master credentials are necessary to retrieve the temporary credentials,\n       *   as well as refresh the credentials when they expire.\n       * @param params [map] a map of options that are passed to the\n       *   {AWS.STS.assumeRole} or {AWS.STS.getSessionToken} operations.\n       *   If a `RoleArn` parameter is passed in, credentials will be based on the\n       *   IAM role.\n       * @param masterCredentials [AWS.Credentials] the master (non-temporary) credentials\n       *  used to get and refresh temporary credentials from AWS STS.\n       * @example Creating a new credentials object for generic temporary credentials\n       *   AWS.config.credentials = new AWS.TemporaryCredentials();\n       * @example Creating a new credentials object for an IAM role\n       *   AWS.config.credentials = new AWS.TemporaryCredentials({\n       *     RoleArn: 'arn:aws:iam::1234567890:role/TemporaryCredentials',\n       *   });\n       * @see AWS.STS.assumeRole\n       * @see AWS.STS.getSessionToken\n       */\n      constructor: function TemporaryCredentials(params, masterCredentials) {\n        AWS.Credentials.call(this);\n        this.loadMasterCredentials(masterCredentials);\n        this.expired = true;\n        this.params = params || {};\n\n        if (this.params.RoleArn) {\n          this.params.RoleSessionName = this.params.RoleSessionName || 'temporary-credentials';\n        }\n      },\n\n      /**\n       * Refreshes credentials using {AWS.STS.assumeRole} or\n       * {AWS.STS.getSessionToken}, depending on whether an IAM role ARN was passed\n       * to the credentials {constructor}.\n       *\n       * @callback callback function(err)\n       *   Called when the STS service responds (or fails). When\n       *   this callback is called with no error, it means that the credentials\n       *   information has been loaded into the object (as the `accessKeyId`,\n       *   `secretAccessKey`, and `sessionToken` properties).\n       *   @param err [Error] if an error occurred, this value will be filled\n       * @see get\n       */\n      refresh: function refresh(callback) {\n        this.coalesceRefresh(callback || AWS.util.fn.callback);\n      },\n\n      /**\n       * @api private\n       */\n      load: function load(callback) {\n        var self = this;\n        self.createClients();\n        self.masterCredentials.get(function () {\n          self.service.config.credentials = self.masterCredentials;\n          var operation = self.params.RoleArn ? self.service.assumeRole : self.service.getSessionToken;\n          operation.call(self.service, function (err, data) {\n            if (!err) {\n              self.service.credentialsFrom(data, self);\n            }\n\n            callback(err);\n          });\n        });\n      },\n\n      /**\n       * @api private\n       */\n      loadMasterCredentials: function loadMasterCredentials(masterCredentials) {\n        this.masterCredentials = masterCredentials || AWS.config.credentials;\n\n        while (this.masterCredentials.masterCredentials) {\n          this.masterCredentials = this.masterCredentials.masterCredentials;\n        }\n\n        if (typeof this.masterCredentials.get !== 'function') {\n          this.masterCredentials = new AWS.Credentials(this.masterCredentials);\n        }\n      },\n\n      /**\n       * @api private\n       */\n      createClients: function () {\n        this.service = this.service || new STS({\n          params: this.params\n        });\n      }\n    });\n  }, {\n    \"../../clients/sts\": 8,\n    \"../core\": 18\n  }],\n  25: [function (require, module, exports) {\n    var AWS = require('../core');\n\n    var STS = require('../../clients/sts');\n    /**\n     * Represents credentials retrieved from STS Web Identity Federation support.\n     *\n     * By default this provider gets credentials using the\n     * {AWS.STS.assumeRoleWithWebIdentity} service operation. This operation\n     * requires a `RoleArn` containing the ARN of the IAM trust policy for the\n     * application for which credentials will be given. In addition, the\n     * `WebIdentityToken` must be set to the token provided by the identity\n     * provider. See {constructor} for an example on creating a credentials\n     * object with proper `RoleArn` and `WebIdentityToken` values.\n     *\n     * ## Refreshing Credentials from Identity Service\n     *\n     * In addition to AWS credentials expiring after a given amount of time, the\n     * login token from the identity provider will also expire. Once this token\n     * expires, it will not be usable to refresh AWS credentials, and another\n     * token will be needed. The SDK does not manage refreshing of the token value,\n     * but this can be done through a \"refresh token\" supported by most identity\n     * providers. Consult the documentation for the identity provider for refreshing\n     * tokens. Once the refreshed token is acquired, you should make sure to update\n     * this new token in the credentials object's {params} property. The following\n     * code will update the WebIdentityToken, assuming you have retrieved an updated\n     * token from the identity provider:\n     *\n     * ```javascript\n     * AWS.config.credentials.params.WebIdentityToken = updatedToken;\n     * ```\n     *\n     * Future calls to `credentials.refresh()` will now use the new token.\n     *\n     * @!attribute params\n     *   @return [map] the map of params passed to\n     *     {AWS.STS.assumeRoleWithWebIdentity}. To update the token, set the\n     *     `params.WebIdentityToken` property.\n     * @!attribute data\n     *   @return [map] the raw data response from the call to\n     *     {AWS.STS.assumeRoleWithWebIdentity}. Use this if you want to get\n     *     access to other properties from the response.\n     */\n\n\n    AWS.WebIdentityCredentials = AWS.util.inherit(AWS.Credentials, {\n      /**\n       * Creates a new credentials object.\n       * @param (see AWS.STS.assumeRoleWithWebIdentity)\n       * @example Creating a new credentials object\n       *   AWS.config.credentials = new AWS.WebIdentityCredentials({\n       *     RoleArn: 'arn:aws:iam::1234567890:role/WebIdentity',\n       *     WebIdentityToken: 'ABCDEFGHIJKLMNOP', // token from identity service\n       *     RoleSessionName: 'web' // optional name, defaults to web-identity\n       *   }, {\n       *     // optionally provide configuration to apply to the underlying AWS.STS service client\n       *     // if configuration is not provided, then configuration will be pulled from AWS.config\n       *\n       *     // specify timeout options\n       *     httpOptions: {\n       *       timeout: 100\n       *     }\n       *   });\n       * @see AWS.STS.assumeRoleWithWebIdentity\n       * @see AWS.Config\n       */\n      constructor: function WebIdentityCredentials(params, clientConfig) {\n        AWS.Credentials.call(this);\n        this.expired = true;\n        this.params = params;\n        this.params.RoleSessionName = this.params.RoleSessionName || 'web-identity';\n        this.data = null;\n        this._clientConfig = AWS.util.copy(clientConfig || {});\n      },\n\n      /**\n       * Refreshes credentials using {AWS.STS.assumeRoleWithWebIdentity}\n       *\n       * @callback callback function(err)\n       *   Called when the STS service responds (or fails). When\n       *   this callback is called with no error, it means that the credentials\n       *   information has been loaded into the object (as the `accessKeyId`,\n       *   `secretAccessKey`, and `sessionToken` properties).\n       *   @param err [Error] if an error occurred, this value will be filled\n       * @see get\n       */\n      refresh: function refresh(callback) {\n        this.coalesceRefresh(callback || AWS.util.fn.callback);\n      },\n\n      /**\n       * @api private\n       */\n      load: function load(callback) {\n        var self = this;\n        self.createClients();\n        self.service.assumeRoleWithWebIdentity(function (err, data) {\n          self.data = null;\n\n          if (!err) {\n            self.data = data;\n            self.service.credentialsFrom(data, self);\n          }\n\n          callback(err);\n        });\n      },\n\n      /**\n       * @api private\n       */\n      createClients: function () {\n        if (!this.service) {\n          var stsConfig = AWS.util.merge({}, this._clientConfig);\n          stsConfig.params = this.params;\n          this.service = new STS(stsConfig);\n        }\n      }\n    });\n  }, {\n    \"../../clients/sts\": 8,\n    \"../core\": 18\n  }],\n  26: [function (require, module, exports) {\n    (function (process) {\n      (function () {\n        var AWS = require('./core');\n\n        var util = require('./util');\n\n        var endpointDiscoveryEnabledEnvs = ['AWS_ENABLE_ENDPOINT_DISCOVERY', 'AWS_ENDPOINT_DISCOVERY_ENABLED'];\n        /**\n         * Generate key (except resources and operation part) to index the endpoints in the cache\n         * If input shape has endpointdiscoveryid trait then use\n         *   accessKey + operation + resources + region + service as cache key\n         * If input shape doesn't have endpointdiscoveryid trait then use\n         *   accessKey + region + service as cache key\n         * @return [map<String,String>] object with keys to index endpoints.\n         * @api private\n         */\n\n        function getCacheKey(request) {\n          var service = request.service;\n          var api = service.api || {};\n          var operations = api.operations;\n          var identifiers = {};\n\n          if (service.config.region) {\n            identifiers.region = service.config.region;\n          }\n\n          if (api.serviceId) {\n            identifiers.serviceId = api.serviceId;\n          }\n\n          if (service.config.credentials.accessKeyId) {\n            identifiers.accessKeyId = service.config.credentials.accessKeyId;\n          }\n\n          return identifiers;\n        }\n        /**\n         * Recursive helper for marshallCustomIdentifiers().\n         * Looks for required string input members that have 'endpointdiscoveryid' trait.\n         * @api private\n         */\n\n\n        function marshallCustomIdentifiersHelper(result, params, shape) {\n          if (!shape || params === undefined || params === null) return;\n\n          if (shape.type === 'structure' && shape.required && shape.required.length > 0) {\n            util.arrayEach(shape.required, function (name) {\n              var memberShape = shape.members[name];\n\n              if (memberShape.endpointDiscoveryId === true) {\n                var locationName = memberShape.isLocationName ? memberShape.name : name;\n                result[locationName] = String(params[name]);\n              } else {\n                marshallCustomIdentifiersHelper(result, params[name], memberShape);\n              }\n            });\n          }\n        }\n        /**\n         * Get custom identifiers for cache key.\n         * Identifies custom identifiers by checking each shape's `endpointDiscoveryId` trait.\n         * @param [object] request object\n         * @param [object] input shape of the given operation's api\n         * @api private\n         */\n\n\n        function marshallCustomIdentifiers(request, shape) {\n          var identifiers = {};\n          marshallCustomIdentifiersHelper(identifiers, request.params, shape);\n          return identifiers;\n        }\n        /**\n         * Call endpoint discovery operation when it's optional.\n         * When endpoint is available in cache then use the cached endpoints. If endpoints\n         * are unavailable then use regional endpoints and call endpoint discovery operation\n         * asynchronously. This is turned off by default.\n         * @param [object] request object\n         * @api private\n         */\n\n\n        function optionalDiscoverEndpoint(request) {\n          var service = request.service;\n          var api = service.api;\n          var operationModel = api.operations ? api.operations[request.operation] : undefined;\n          var inputShape = operationModel ? operationModel.input : undefined;\n          var identifiers = marshallCustomIdentifiers(request, inputShape);\n          var cacheKey = getCacheKey(request);\n\n          if (Object.keys(identifiers).length > 0) {\n            cacheKey = util.update(cacheKey, identifiers);\n            if (operationModel) cacheKey.operation = operationModel.name;\n          }\n\n          var endpoints = AWS.endpointCache.get(cacheKey);\n\n          if (endpoints && endpoints.length === 1 && endpoints[0].Address === '') {\n            //endpoint operation is being made but response not yet received\n            //or endpoint operation just failed in 1 minute\n            return;\n          } else if (endpoints && endpoints.length > 0) {\n            //found endpoint record from cache\n            request.httpRequest.updateEndpoint(endpoints[0].Address);\n          } else {\n            //endpoint record not in cache or outdated. make discovery operation\n            var endpointRequest = service.makeRequest(api.endpointOperation, {\n              Operation: operationModel.name,\n              Identifiers: identifiers\n            });\n            addApiVersionHeader(endpointRequest);\n            endpointRequest.removeListener('validate', AWS.EventListeners.Core.VALIDATE_PARAMETERS);\n            endpointRequest.removeListener('retry', AWS.EventListeners.Core.RETRY_CHECK); //put in a placeholder for endpoints already requested, prevent\n            //too much in-flight calls\n\n            AWS.endpointCache.put(cacheKey, [{\n              Address: '',\n              CachePeriodInMinutes: 1\n            }]);\n            endpointRequest.send(function (err, data) {\n              if (data && data.Endpoints) {\n                AWS.endpointCache.put(cacheKey, data.Endpoints);\n              } else if (err) {\n                AWS.endpointCache.put(cacheKey, [{\n                  Address: '',\n                  CachePeriodInMinutes: 1 //not to make more endpoint operation in next 1 minute\n\n                }]);\n              }\n            });\n          }\n        }\n\n        var requestQueue = {};\n        /**\n         * Call endpoint discovery operation when it's required.\n         * When endpoint is available in cache then use cached ones. If endpoints are\n         * unavailable then SDK should call endpoint operation then use returned new\n         * endpoint for the api call. SDK will automatically attempt to do endpoint\n         * discovery. This is turned off by default\n         * @param [object] request object\n         * @api private\n         */\n\n        function requiredDiscoverEndpoint(request, done) {\n          var service = request.service;\n          var api = service.api;\n          var operationModel = api.operations ? api.operations[request.operation] : undefined;\n          var inputShape = operationModel ? operationModel.input : undefined;\n          var identifiers = marshallCustomIdentifiers(request, inputShape);\n          var cacheKey = getCacheKey(request);\n\n          if (Object.keys(identifiers).length > 0) {\n            cacheKey = util.update(cacheKey, identifiers);\n            if (operationModel) cacheKey.operation = operationModel.name;\n          }\n\n          var cacheKeyStr = AWS.EndpointCache.getKeyString(cacheKey);\n          var endpoints = AWS.endpointCache.get(cacheKeyStr); //endpoint cache also accepts string keys\n\n          if (endpoints && endpoints.length === 1 && endpoints[0].Address === '') {\n            //endpoint operation is being made but response not yet received\n            //push request object to a pending queue\n            if (!requestQueue[cacheKeyStr]) requestQueue[cacheKeyStr] = [];\n            requestQueue[cacheKeyStr].push({\n              request: request,\n              callback: done\n            });\n            return;\n          } else if (endpoints && endpoints.length > 0) {\n            request.httpRequest.updateEndpoint(endpoints[0].Address);\n            done();\n          } else {\n            var endpointRequest = service.makeRequest(api.endpointOperation, {\n              Operation: operationModel.name,\n              Identifiers: identifiers\n            });\n            endpointRequest.removeListener('validate', AWS.EventListeners.Core.VALIDATE_PARAMETERS);\n            addApiVersionHeader(endpointRequest); //put in a placeholder for endpoints already requested, prevent\n            //too much in-flight calls\n\n            AWS.endpointCache.put(cacheKeyStr, [{\n              Address: '',\n              CachePeriodInMinutes: 60 //long-live cache\n\n            }]);\n            endpointRequest.send(function (err, data) {\n              if (err) {\n                var errorParams = {\n                  code: 'EndpointDiscoveryException',\n                  message: 'Request cannot be fulfilled without specifying an endpoint',\n                  retryable: false\n                };\n                request.response.error = util.error(err, errorParams);\n                AWS.endpointCache.remove(cacheKey); //fail all the pending requests in batch\n\n                if (requestQueue[cacheKeyStr]) {\n                  var pendingRequests = requestQueue[cacheKeyStr];\n                  util.arrayEach(pendingRequests, function (requestContext) {\n                    requestContext.request.response.error = util.error(err, errorParams);\n                    requestContext.callback();\n                  });\n                  delete requestQueue[cacheKeyStr];\n                }\n              } else if (data) {\n                AWS.endpointCache.put(cacheKeyStr, data.Endpoints);\n                request.httpRequest.updateEndpoint(data.Endpoints[0].Address); //update the endpoint for all the pending requests in batch\n\n                if (requestQueue[cacheKeyStr]) {\n                  var pendingRequests = requestQueue[cacheKeyStr];\n                  util.arrayEach(pendingRequests, function (requestContext) {\n                    requestContext.request.httpRequest.updateEndpoint(data.Endpoints[0].Address);\n                    requestContext.callback();\n                  });\n                  delete requestQueue[cacheKeyStr];\n                }\n              }\n\n              done();\n            });\n          }\n        }\n        /**\n         * add api version header to endpoint operation\n         * @api private\n         */\n\n\n        function addApiVersionHeader(endpointRequest) {\n          var api = endpointRequest.service.api;\n          var apiVersion = api.apiVersion;\n\n          if (apiVersion && !endpointRequest.httpRequest.headers['x-amz-api-version']) {\n            endpointRequest.httpRequest.headers['x-amz-api-version'] = apiVersion;\n          }\n        }\n        /**\n         * If api call gets invalid endpoint exception, SDK should attempt to remove the invalid\n         * endpoint from cache.\n         * @api private\n         */\n\n\n        function invalidateCachedEndpoints(response) {\n          var error = response.error;\n          var httpResponse = response.httpResponse;\n\n          if (error && (error.code === 'InvalidEndpointException' || httpResponse.statusCode === 421)) {\n            var request = response.request;\n            var operations = request.service.api.operations || {};\n            var inputShape = operations[request.operation] ? operations[request.operation].input : undefined;\n            var identifiers = marshallCustomIdentifiers(request, inputShape);\n            var cacheKey = getCacheKey(request);\n\n            if (Object.keys(identifiers).length > 0) {\n              cacheKey = util.update(cacheKey, identifiers);\n              if (operations[request.operation]) cacheKey.operation = operations[request.operation].name;\n            }\n\n            AWS.endpointCache.remove(cacheKey);\n          }\n        }\n        /**\n         * If endpoint is explicitly configured, SDK should not do endpoint discovery in anytime.\n         * @param [object] client Service client object.\n         * @api private\n         */\n\n\n        function hasCustomEndpoint(client) {\n          //if set endpoint is set for specific client, enable endpoint discovery will raise an error.\n          if (client._originalConfig && client._originalConfig.endpoint && client._originalConfig.endpointDiscoveryEnabled === true) {\n            throw util.error(new Error(), {\n              code: 'ConfigurationException',\n              message: 'Custom endpoint is supplied; endpointDiscoveryEnabled must not be true.'\n            });\n          }\n\n          ;\n          var svcConfig = AWS.config[client.serviceIdentifier] || {};\n          return Boolean(AWS.config.endpoint || svcConfig.endpoint || client._originalConfig && client._originalConfig.endpoint);\n        }\n        /**\n         * @api private\n         */\n\n\n        function isFalsy(value) {\n          return ['false', '0'].indexOf(value) >= 0;\n        }\n        /**\n         * If endpoint discovery should perform for this request when endpoint discovery is optional.\n         * SDK performs config resolution in order like below:\n         * 1. If turned on client configuration(default to off) then turn on endpoint discovery.\n         * 2. If turned on in env AWS_ENABLE_ENDPOINT_DISCOVERY then turn on endpoint discovery.\n         * 3. If turned on in shared ini config file with key 'endpoint_discovery_enabled', then\n         *   turn on endpoint discovery.\n         * @param [object] request request object.\n         * @api private\n         */\n\n\n        function isEndpointDiscoveryApplicable(request) {\n          var service = request.service || {};\n          if (service.config.endpointDiscoveryEnabled === true) return true; //shared ini file is only available in Node\n          //not to check env in browser\n\n          if (util.isBrowser()) return false;\n\n          for (var i = 0; i < endpointDiscoveryEnabledEnvs.length; i++) {\n            var env = endpointDiscoveryEnabledEnvs[i];\n\n            if (Object.prototype.hasOwnProperty.call(process.env, env)) {\n              if (process.env[env] === '' || process.env[env] === undefined) {\n                throw util.error(new Error(), {\n                  code: 'ConfigurationException',\n                  message: 'environmental variable ' + env + ' cannot be set to nothing'\n                });\n              }\n\n              if (!isFalsy(process.env[env])) return true;\n            }\n          }\n\n          var configFile = {};\n\n          try {\n            configFile = AWS.util.iniLoader ? AWS.util.iniLoader.loadFrom({\n              isConfig: true,\n              filename: process.env[AWS.util.sharedConfigFileEnv]\n            }) : {};\n          } catch (e) {}\n\n          var sharedFileConfig = configFile[process.env.AWS_PROFILE || AWS.util.defaultProfile] || {};\n\n          if (Object.prototype.hasOwnProperty.call(sharedFileConfig, 'endpoint_discovery_enabled')) {\n            if (sharedFileConfig.endpoint_discovery_enabled === undefined) {\n              throw util.error(new Error(), {\n                code: 'ConfigurationException',\n                message: 'config file entry \\'endpoint_discovery_enabled\\' cannot be set to nothing'\n              });\n            }\n\n            if (!isFalsy(sharedFileConfig.endpoint_discovery_enabled)) return true;\n          }\n\n          return false;\n        }\n        /**\n         * attach endpoint discovery logic to request object\n         * @param [object] request\n         * @api private\n         */\n\n\n        function discoverEndpoint(request, done) {\n          var service = request.service || {};\n          if (hasCustomEndpoint(service) || request.isPresigned()) return done();\n          if (!isEndpointDiscoveryApplicable(request)) return done();\n          request.httpRequest.appendToUserAgent('endpoint-discovery');\n          var operations = service.api.operations || {};\n          var operationModel = operations[request.operation];\n          var isEndpointDiscoveryRequired = operationModel ? operationModel.endpointDiscoveryRequired : 'NULL';\n\n          switch (isEndpointDiscoveryRequired) {\n            case 'OPTIONAL':\n              optionalDiscoverEndpoint(request);\n              request.addNamedListener('INVALIDATE_CACHED_ENDPOINTS', 'extractError', invalidateCachedEndpoints);\n              done();\n              break;\n\n            case 'REQUIRED':\n              request.addNamedListener('INVALIDATE_CACHED_ENDPOINTS', 'extractError', invalidateCachedEndpoints);\n              requiredDiscoverEndpoint(request, done);\n              break;\n\n            case 'NULL':\n            default:\n              done();\n              break;\n          }\n        }\n\n        module.exports = {\n          discoverEndpoint: discoverEndpoint,\n          requiredDiscoverEndpoint: requiredDiscoverEndpoint,\n          optionalDiscoverEndpoint: optionalDiscoverEndpoint,\n          marshallCustomIdentifiers: marshallCustomIdentifiers,\n          getCacheKey: getCacheKey,\n          invalidateCachedEndpoint: invalidateCachedEndpoints\n        };\n      }).call(this);\n    }).call(this, require('_process'));\n  }, {\n    \"./core\": 18,\n    \"./util\": 71,\n    \"_process\": 86\n  }],\n  27: [function (require, module, exports) {\n    var eventMessageChunker = require('../event-stream/event-message-chunker').eventMessageChunker;\n\n    var parseEvent = require('./parse-event').parseEvent;\n\n    function createEventStream(body, parser, model) {\n      var eventMessages = eventMessageChunker(body);\n      var events = [];\n\n      for (var i = 0; i < eventMessages.length; i++) {\n        events.push(parseEvent(parser, eventMessages[i], model));\n      }\n\n      return events;\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = {\n      createEventStream: createEventStream\n    };\n  }, {\n    \"../event-stream/event-message-chunker\": 28,\n    \"./parse-event\": 30\n  }],\n  28: [function (require, module, exports) {\n    /**\n     * Takes in a buffer of event messages and splits them into individual messages.\n     * @param {Buffer} buffer\n     * @api private\n     */\n    function eventMessageChunker(buffer) {\n      /** @type Buffer[] */\n      var messages = [];\n      var offset = 0;\n\n      while (offset < buffer.length) {\n        var totalLength = buffer.readInt32BE(offset); // create new buffer for individual message (shares memory with original)\n\n        var message = buffer.slice(offset, totalLength + offset); // increment offset to it starts at the next message\n\n        offset += totalLength;\n        messages.push(message);\n      }\n\n      return messages;\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = {\n      eventMessageChunker: eventMessageChunker\n    };\n  }, {}],\n  29: [function (require, module, exports) {\n    var util = require('../core').util;\n\n    var toBuffer = util.buffer.toBuffer;\n    /**\n     * A lossless representation of a signed, 64-bit integer. Instances of this\n     * class may be used in arithmetic expressions as if they were numeric\n     * primitives, but the binary representation will be preserved unchanged as the\n     * `bytes` property of the object. The bytes should be encoded as big-endian,\n     * two's complement integers.\n     * @param {Buffer} bytes\n     *\n     * @api private\n     */\n\n    function Int64(bytes) {\n      if (bytes.length !== 8) {\n        throw new Error('Int64 buffers must be exactly 8 bytes');\n      }\n\n      if (!util.Buffer.isBuffer(bytes)) bytes = toBuffer(bytes);\n      this.bytes = bytes;\n    }\n    /**\n     * @param {number} number\n     * @returns {Int64}\n     *\n     * @api private\n     */\n\n\n    Int64.fromNumber = function (number) {\n      if (number > 9223372036854775807 || number < -9223372036854775808) {\n        throw new Error(number + ' is too large (or, if negative, too small) to represent as an Int64');\n      }\n\n      var bytes = new Uint8Array(8);\n\n      for (var i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {\n        bytes[i] = remaining;\n      }\n\n      if (number < 0) {\n        negate(bytes);\n      }\n\n      return new Int64(bytes);\n    };\n    /**\n     * @returns {number}\n     *\n     * @api private\n     */\n\n\n    Int64.prototype.valueOf = function () {\n      var bytes = this.bytes.slice(0);\n      var negative = bytes[0] & 128;\n\n      if (negative) {\n        negate(bytes);\n      }\n\n      return parseInt(bytes.toString('hex'), 16) * (negative ? -1 : 1);\n    };\n\n    Int64.prototype.toString = function () {\n      return String(this.valueOf());\n    };\n    /**\n     * @param {Buffer} bytes\n     *\n     * @api private\n     */\n\n\n    function negate(bytes) {\n      for (var i = 0; i < 8; i++) {\n        bytes[i] ^= 0xFF;\n      }\n\n      for (var i = 7; i > -1; i--) {\n        bytes[i]++;\n\n        if (bytes[i] !== 0) {\n          break;\n        }\n      }\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = {\n      Int64: Int64\n    };\n  }, {\n    \"../core\": 18\n  }],\n  30: [function (require, module, exports) {\n    var parseMessage = require('./parse-message').parseMessage;\n    /**\n     *\n     * @param {*} parser\n     * @param {Buffer} message\n     * @param {*} shape\n     * @api private\n     */\n\n\n    function parseEvent(parser, message, shape) {\n      var parsedMessage = parseMessage(message); // check if message is an event or error\n\n      var messageType = parsedMessage.headers[':message-type'];\n\n      if (messageType) {\n        if (messageType.value === 'error') {\n          throw parseError(parsedMessage);\n        } else if (messageType.value !== 'event') {\n          // not sure how to parse non-events/non-errors, ignore for now\n          return;\n        }\n      } // determine event type\n\n\n      var eventType = parsedMessage.headers[':event-type']; // check that the event type is modeled\n\n      var eventModel = shape.members[eventType.value];\n\n      if (!eventModel) {\n        return;\n      }\n\n      var result = {}; // check if an event payload exists\n\n      var eventPayloadMemberName = eventModel.eventPayloadMemberName;\n\n      if (eventPayloadMemberName) {\n        var payloadShape = eventModel.members[eventPayloadMemberName]; // if the shape is binary, return the byte array\n\n        if (payloadShape.type === 'binary') {\n          result[eventPayloadMemberName] = parsedMessage.body;\n        } else {\n          result[eventPayloadMemberName] = parser.parse(parsedMessage.body.toString(), payloadShape);\n        }\n      } // read event headers\n\n\n      var eventHeaderNames = eventModel.eventHeaderMemberNames;\n\n      for (var i = 0; i < eventHeaderNames.length; i++) {\n        var name = eventHeaderNames[i];\n\n        if (parsedMessage.headers[name]) {\n          // parse the header!\n          result[name] = eventModel.members[name].toType(parsedMessage.headers[name].value);\n        }\n      }\n\n      var output = {};\n      output[eventType.value] = result;\n      return output;\n    }\n\n    function parseError(message) {\n      var errorCode = message.headers[':error-code'];\n      var errorMessage = message.headers[':error-message'];\n      var error = new Error(errorMessage.value || errorMessage);\n      error.code = error.name = errorCode.value || errorCode;\n      return error;\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = {\n      parseEvent: parseEvent\n    };\n  }, {\n    \"./parse-message\": 31\n  }],\n  31: [function (require, module, exports) {\n    var Int64 = require('./int64').Int64;\n\n    var splitMessage = require('./split-message').splitMessage;\n\n    var BOOLEAN_TAG = 'boolean';\n    var BYTE_TAG = 'byte';\n    var SHORT_TAG = 'short';\n    var INT_TAG = 'integer';\n    var LONG_TAG = 'long';\n    var BINARY_TAG = 'binary';\n    var STRING_TAG = 'string';\n    var TIMESTAMP_TAG = 'timestamp';\n    var UUID_TAG = 'uuid';\n    /**\n     * @api private\n     *\n     * @param {Buffer} headers\n     */\n\n    function parseHeaders(headers) {\n      var out = {};\n      var position = 0;\n\n      while (position < headers.length) {\n        var nameLength = headers.readUInt8(position++);\n        var name = headers.slice(position, position + nameLength).toString();\n        position += nameLength;\n\n        switch (headers.readUInt8(position++)) {\n          case 0\n          /* boolTrue */\n          :\n            out[name] = {\n              type: BOOLEAN_TAG,\n              value: true\n            };\n            break;\n\n          case 1\n          /* boolFalse */\n          :\n            out[name] = {\n              type: BOOLEAN_TAG,\n              value: false\n            };\n            break;\n\n          case 2\n          /* byte */\n          :\n            out[name] = {\n              type: BYTE_TAG,\n              value: headers.readInt8(position++)\n            };\n            break;\n\n          case 3\n          /* short */\n          :\n            out[name] = {\n              type: SHORT_TAG,\n              value: headers.readInt16BE(position)\n            };\n            position += 2;\n            break;\n\n          case 4\n          /* integer */\n          :\n            out[name] = {\n              type: INT_TAG,\n              value: headers.readInt32BE(position)\n            };\n            position += 4;\n            break;\n\n          case 5\n          /* long */\n          :\n            out[name] = {\n              type: LONG_TAG,\n              value: new Int64(headers.slice(position, position + 8))\n            };\n            position += 8;\n            break;\n\n          case 6\n          /* byteArray */\n          :\n            var binaryLength = headers.readUInt16BE(position);\n            position += 2;\n            out[name] = {\n              type: BINARY_TAG,\n              value: headers.slice(position, position + binaryLength)\n            };\n            position += binaryLength;\n            break;\n\n          case 7\n          /* string */\n          :\n            var stringLength = headers.readUInt16BE(position);\n            position += 2;\n            out[name] = {\n              type: STRING_TAG,\n              value: headers.slice(position, position + stringLength).toString()\n            };\n            position += stringLength;\n            break;\n\n          case 8\n          /* timestamp */\n          :\n            out[name] = {\n              type: TIMESTAMP_TAG,\n              value: new Date(new Int64(headers.slice(position, position + 8)).valueOf())\n            };\n            position += 8;\n            break;\n\n          case 9\n          /* uuid */\n          :\n            var uuidChars = headers.slice(position, position + 16).toString('hex');\n            position += 16;\n            out[name] = {\n              type: UUID_TAG,\n              value: uuidChars.substr(0, 8) + '-' + uuidChars.substr(8, 4) + '-' + uuidChars.substr(12, 4) + '-' + uuidChars.substr(16, 4) + '-' + uuidChars.substr(20)\n            };\n            break;\n\n          default:\n            throw new Error('Unrecognized header type tag');\n        }\n      }\n\n      return out;\n    }\n\n    function parseMessage(message) {\n      var parsed = splitMessage(message);\n      return {\n        headers: parseHeaders(parsed.headers),\n        body: parsed.body\n      };\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = {\n      parseMessage: parseMessage\n    };\n  }, {\n    \"./int64\": 29,\n    \"./split-message\": 32\n  }],\n  32: [function (require, module, exports) {\n    var util = require('../core').util;\n\n    var toBuffer = util.buffer.toBuffer; // All prelude components are unsigned, 32-bit integers\n\n    var PRELUDE_MEMBER_LENGTH = 4; // The prelude consists of two components\n\n    var PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2; // Checksums are always CRC32 hashes.\n\n    var CHECKSUM_LENGTH = 4; // Messages must include a full prelude, a prelude checksum, and a message checksum\n\n    var MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;\n    /**\n     * @api private\n     *\n     * @param {Buffer} message\n     */\n\n    function splitMessage(message) {\n      if (!util.Buffer.isBuffer(message)) message = toBuffer(message);\n\n      if (message.length < MINIMUM_MESSAGE_LENGTH) {\n        throw new Error('Provided message too short to accommodate event stream message overhead');\n      }\n\n      if (message.length !== message.readUInt32BE(0)) {\n        throw new Error('Reported message length does not match received message length');\n      }\n\n      var expectedPreludeChecksum = message.readUInt32BE(PRELUDE_LENGTH);\n\n      if (expectedPreludeChecksum !== util.crypto.crc32(message.slice(0, PRELUDE_LENGTH))) {\n        throw new Error('The prelude checksum specified in the message (' + expectedPreludeChecksum + ') does not match the calculated CRC32 checksum.');\n      }\n\n      var expectedMessageChecksum = message.readUInt32BE(message.length - CHECKSUM_LENGTH);\n\n      if (expectedMessageChecksum !== util.crypto.crc32(message.slice(0, message.length - CHECKSUM_LENGTH))) {\n        throw new Error('The message checksum did not match the expected value of ' + expectedMessageChecksum);\n      }\n\n      var headersStart = PRELUDE_LENGTH + CHECKSUM_LENGTH;\n      var headersEnd = headersStart + message.readUInt32BE(PRELUDE_MEMBER_LENGTH);\n      return {\n        headers: message.slice(headersStart, headersEnd),\n        body: message.slice(headersEnd, message.length - CHECKSUM_LENGTH)\n      };\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = {\n      splitMessage: splitMessage\n    };\n  }, {\n    \"../core\": 18\n  }],\n  33: [function (require, module, exports) {\n    var AWS = require('./core');\n\n    var SequentialExecutor = require('./sequential_executor');\n\n    var DISCOVER_ENDPOINT = require('./discover_endpoint').discoverEndpoint;\n    /**\n     * The namespace used to register global event listeners for request building\n     * and sending.\n     */\n\n\n    AWS.EventListeners = {\n      /**\n       * @!attribute VALIDATE_CREDENTIALS\n       *   A request listener that validates whether the request is being\n       *   sent with credentials.\n       *   Handles the {AWS.Request~validate 'validate' Request event}\n       *   @example Sending a request without validating credentials\n       *     var listener = AWS.EventListeners.Core.VALIDATE_CREDENTIALS;\n       *     request.removeListener('validate', listener);\n       *   @readonly\n       *   @return [Function]\n       * @!attribute VALIDATE_REGION\n       *   A request listener that validates whether the region is set\n       *   for a request.\n       *   Handles the {AWS.Request~validate 'validate' Request event}\n       *   @example Sending a request without validating region configuration\n       *     var listener = AWS.EventListeners.Core.VALIDATE_REGION;\n       *     request.removeListener('validate', listener);\n       *   @readonly\n       *   @return [Function]\n       * @!attribute VALIDATE_PARAMETERS\n       *   A request listener that validates input parameters in a request.\n       *   Handles the {AWS.Request~validate 'validate' Request event}\n       *   @example Sending a request without validating parameters\n       *     var listener = AWS.EventListeners.Core.VALIDATE_PARAMETERS;\n       *     request.removeListener('validate', listener);\n       *   @example Disable parameter validation globally\n       *     AWS.EventListeners.Core.removeListener('validate',\n       *       AWS.EventListeners.Core.VALIDATE_REGION);\n       *   @readonly\n       *   @return [Function]\n       * @!attribute SEND\n       *   A request listener that initiates the HTTP connection for a\n       *   request being sent. Handles the {AWS.Request~send 'send' Request event}\n       *   @example Replacing the HTTP handler\n       *     var listener = AWS.EventListeners.Core.SEND;\n       *     request.removeListener('send', listener);\n       *     request.on('send', function(response) {\n       *       customHandler.send(response);\n       *     });\n       *   @return [Function]\n       *   @readonly\n       * @!attribute HTTP_DATA\n       *   A request listener that reads data from the HTTP connection in order\n       *   to build the response data.\n       *   Handles the {AWS.Request~httpData 'httpData' Request event}.\n       *   Remove this handler if you are overriding the 'httpData' event and\n       *   do not want extra data processing and buffering overhead.\n       *   @example Disabling default data processing\n       *     var listener = AWS.EventListeners.Core.HTTP_DATA;\n       *     request.removeListener('httpData', listener);\n       *   @return [Function]\n       *   @readonly\n       */\n      Core: {}\n      /* doc hack */\n\n    };\n    /**\n     * @api private\n     */\n\n    function getOperationAuthtype(req) {\n      if (!req.service.api.operations) {\n        return '';\n      }\n\n      var operation = req.service.api.operations[req.operation];\n      return operation ? operation.authtype : '';\n    }\n\n    AWS.EventListeners = {\n      Core: new SequentialExecutor().addNamedListeners(function (add, addAsync) {\n        addAsync('VALIDATE_CREDENTIALS', 'validate', function VALIDATE_CREDENTIALS(req, done) {\n          if (!req.service.api.signatureVersion && !req.service.config.signatureVersion) return done(); // none\n\n          req.service.config.getCredentials(function (err) {\n            if (err) {\n              req.response.error = AWS.util.error(err, {\n                code: 'CredentialsError',\n                message: 'Missing credentials in config'\n              });\n            }\n\n            done();\n          });\n        });\n        add('VALIDATE_REGION', 'validate', function VALIDATE_REGION(req) {\n          if (!req.service.config.region && !req.service.isGlobalEndpoint) {\n            req.response.error = AWS.util.error(new Error(), {\n              code: 'ConfigError',\n              message: 'Missing region in config'\n            });\n          }\n        });\n        add('BUILD_IDEMPOTENCY_TOKENS', 'validate', function BUILD_IDEMPOTENCY_TOKENS(req) {\n          if (!req.service.api.operations) {\n            return;\n          }\n\n          var operation = req.service.api.operations[req.operation];\n\n          if (!operation) {\n            return;\n          }\n\n          var idempotentMembers = operation.idempotentMembers;\n\n          if (!idempotentMembers.length) {\n            return;\n          } // creates a copy of params so user's param object isn't mutated\n\n\n          var params = AWS.util.copy(req.params);\n\n          for (var i = 0, iLen = idempotentMembers.length; i < iLen; i++) {\n            if (!params[idempotentMembers[i]]) {\n              // add the member\n              params[idempotentMembers[i]] = AWS.util.uuid.v4();\n            }\n          }\n\n          req.params = params;\n        });\n        add('VALIDATE_PARAMETERS', 'validate', function VALIDATE_PARAMETERS(req) {\n          if (!req.service.api.operations) {\n            return;\n          }\n\n          var rules = req.service.api.operations[req.operation].input;\n          var validation = req.service.config.paramValidation;\n          new AWS.ParamValidator(validation).validate(rules, req.params);\n        });\n        addAsync('COMPUTE_SHA256', 'afterBuild', function COMPUTE_SHA256(req, done) {\n          req.haltHandlersOnError();\n\n          if (!req.service.api.operations) {\n            return;\n          }\n\n          var operation = req.service.api.operations[req.operation];\n          var authtype = operation ? operation.authtype : '';\n          if (!req.service.api.signatureVersion && !authtype && !req.service.config.signatureVersion) return done(); // none\n\n          if (req.service.getSignerClass(req) === AWS.Signers.V4) {\n            var body = req.httpRequest.body || '';\n\n            if (authtype.indexOf('unsigned-body') >= 0) {\n              req.httpRequest.headers['X-Amz-Content-Sha256'] = 'UNSIGNED-PAYLOAD';\n              return done();\n            }\n\n            AWS.util.computeSha256(body, function (err, sha) {\n              if (err) {\n                done(err);\n              } else {\n                req.httpRequest.headers['X-Amz-Content-Sha256'] = sha;\n                done();\n              }\n            });\n          } else {\n            done();\n          }\n        });\n        add('SET_CONTENT_LENGTH', 'afterBuild', function SET_CONTENT_LENGTH(req) {\n          var authtype = getOperationAuthtype(req);\n          var payloadMember = AWS.util.getRequestPayloadShape(req);\n\n          if (req.httpRequest.headers['Content-Length'] === undefined) {\n            try {\n              var length = AWS.util.string.byteLength(req.httpRequest.body);\n              req.httpRequest.headers['Content-Length'] = length;\n            } catch (err) {\n              if (payloadMember && payloadMember.isStreaming) {\n                if (payloadMember.requiresLength) {\n                  //streaming payload requires length(s3, glacier)\n                  throw err;\n                } else if (authtype.indexOf('unsigned-body') >= 0) {\n                  //unbounded streaming payload(lex, mediastore)\n                  req.httpRequest.headers['Transfer-Encoding'] = 'chunked';\n                  return;\n                } else {\n                  throw err;\n                }\n              }\n\n              throw err;\n            }\n          }\n        });\n        add('SET_HTTP_HOST', 'afterBuild', function SET_HTTP_HOST(req) {\n          req.httpRequest.headers['Host'] = req.httpRequest.endpoint.host;\n        });\n        add('RESTART', 'restart', function RESTART() {\n          var err = this.response.error;\n          if (!err || !err.retryable) return;\n          this.httpRequest = new AWS.HttpRequest(this.service.endpoint, this.service.region);\n\n          if (this.response.retryCount < this.service.config.maxRetries) {\n            this.response.retryCount++;\n          } else {\n            this.response.error = null;\n          }\n        });\n        var addToHead = true;\n        addAsync('DISCOVER_ENDPOINT', 'sign', DISCOVER_ENDPOINT, addToHead);\n        addAsync('SIGN', 'sign', function SIGN(req, done) {\n          var service = req.service;\n          var operations = req.service.api.operations || {};\n          var operation = operations[req.operation];\n          var authtype = operation ? operation.authtype : '';\n          if (!service.api.signatureVersion && !authtype && !service.config.signatureVersion) return done(); // none\n\n          service.config.getCredentials(function (err, credentials) {\n            if (err) {\n              req.response.error = err;\n              return done();\n            }\n\n            try {\n              var date = service.getSkewCorrectedDate();\n              var SignerClass = service.getSignerClass(req);\n              var signer = new SignerClass(req.httpRequest, service.api.signingName || service.api.endpointPrefix, {\n                signatureCache: service.config.signatureCache,\n                operation: operation,\n                signatureVersion: service.api.signatureVersion\n              });\n              signer.setServiceClientId(service._clientId); // clear old authorization headers\n\n              delete req.httpRequest.headers['Authorization'];\n              delete req.httpRequest.headers['Date'];\n              delete req.httpRequest.headers['X-Amz-Date']; // add new authorization\n\n              signer.addAuthorization(credentials, date);\n              req.signedAt = date;\n            } catch (e) {\n              req.response.error = e;\n            }\n\n            done();\n          });\n        });\n        add('VALIDATE_RESPONSE', 'validateResponse', function VALIDATE_RESPONSE(resp) {\n          if (this.service.successfulResponse(resp, this)) {\n            resp.data = {};\n            resp.error = null;\n          } else {\n            resp.data = null;\n            resp.error = AWS.util.error(new Error(), {\n              code: 'UnknownError',\n              message: 'An unknown error occurred.'\n            });\n          }\n        });\n        addAsync('SEND', 'send', function SEND(resp, done) {\n          resp.httpResponse._abortCallback = done;\n          resp.error = null;\n          resp.data = null;\n\n          function callback(httpResp) {\n            resp.httpResponse.stream = httpResp;\n            var stream = resp.request.httpRequest.stream;\n            var service = resp.request.service;\n            var api = service.api;\n            var operationName = resp.request.operation;\n            var operation = api.operations[operationName] || {};\n            httpResp.on('headers', function onHeaders(statusCode, headers, statusMessage) {\n              resp.request.emit('httpHeaders', [statusCode, headers, resp, statusMessage]);\n\n              if (!resp.httpResponse.streaming) {\n                if (AWS.HttpClient.streamsApiVersion === 2) {\n                  // streams2 API check\n                  // if we detect event streams, we're going to have to\n                  // return the stream immediately\n                  if (operation.hasEventOutput && service.successfulResponse(resp)) {\n                    // skip reading the IncomingStream\n                    resp.request.emit('httpDone');\n                    done();\n                    return;\n                  }\n\n                  httpResp.on('readable', function onReadable() {\n                    var data = httpResp.read();\n\n                    if (data !== null) {\n                      resp.request.emit('httpData', [data, resp]);\n                    }\n                  });\n                } else {\n                  // legacy streams API\n                  httpResp.on('data', function onData(data) {\n                    resp.request.emit('httpData', [data, resp]);\n                  });\n                }\n              }\n            });\n            httpResp.on('end', function onEnd() {\n              if (!stream || !stream.didCallback) {\n                if (AWS.HttpClient.streamsApiVersion === 2 && operation.hasEventOutput && service.successfulResponse(resp)) {\n                  // don't concatenate response chunks when streaming event stream data when response is successful\n                  return;\n                }\n\n                resp.request.emit('httpDone');\n                done();\n              }\n            });\n          }\n\n          function progress(httpResp) {\n            httpResp.on('sendProgress', function onSendProgress(value) {\n              resp.request.emit('httpUploadProgress', [value, resp]);\n            });\n            httpResp.on('receiveProgress', function onReceiveProgress(value) {\n              resp.request.emit('httpDownloadProgress', [value, resp]);\n            });\n          }\n\n          function error(err) {\n            if (err.code !== 'RequestAbortedError') {\n              var errCode = err.code === 'TimeoutError' ? err.code : 'NetworkingError';\n              err = AWS.util.error(err, {\n                code: errCode,\n                region: resp.request.httpRequest.region,\n                hostname: resp.request.httpRequest.endpoint.hostname,\n                retryable: true\n              });\n            }\n\n            resp.error = err;\n            resp.request.emit('httpError', [resp.error, resp], function () {\n              done();\n            });\n          }\n\n          function executeSend() {\n            var http = AWS.HttpClient.getInstance();\n            var httpOptions = resp.request.service.config.httpOptions || {};\n\n            try {\n              var stream = http.handleRequest(resp.request.httpRequest, httpOptions, callback, error);\n              progress(stream);\n            } catch (err) {\n              error(err);\n            }\n          }\n\n          var timeDiff = (resp.request.service.getSkewCorrectedDate() - this.signedAt) / 1000;\n\n          if (timeDiff >= 60 * 10) {\n            // if we signed 10min ago, re-sign\n            this.emit('sign', [this], function (err) {\n              if (err) done(err);else executeSend();\n            });\n          } else {\n            executeSend();\n          }\n        });\n        add('HTTP_HEADERS', 'httpHeaders', function HTTP_HEADERS(statusCode, headers, resp, statusMessage) {\n          resp.httpResponse.statusCode = statusCode;\n          resp.httpResponse.statusMessage = statusMessage;\n          resp.httpResponse.headers = headers;\n          resp.httpResponse.body = AWS.util.buffer.toBuffer('');\n          resp.httpResponse.buffers = [];\n          resp.httpResponse.numBytes = 0;\n          var dateHeader = headers.date || headers.Date;\n          var service = resp.request.service;\n\n          if (dateHeader) {\n            var serverTime = Date.parse(dateHeader);\n\n            if (service.config.correctClockSkew && service.isClockSkewed(serverTime)) {\n              service.applyClockOffset(serverTime);\n            }\n          }\n        });\n        add('HTTP_DATA', 'httpData', function HTTP_DATA(chunk, resp) {\n          if (chunk) {\n            if (AWS.util.isNode()) {\n              resp.httpResponse.numBytes += chunk.length;\n              var total = resp.httpResponse.headers['content-length'];\n              var progress = {\n                loaded: resp.httpResponse.numBytes,\n                total: total\n              };\n              resp.request.emit('httpDownloadProgress', [progress, resp]);\n            }\n\n            resp.httpResponse.buffers.push(AWS.util.buffer.toBuffer(chunk));\n          }\n        });\n        add('HTTP_DONE', 'httpDone', function HTTP_DONE(resp) {\n          // convert buffers array into single buffer\n          if (resp.httpResponse.buffers && resp.httpResponse.buffers.length > 0) {\n            var body = AWS.util.buffer.concat(resp.httpResponse.buffers);\n            resp.httpResponse.body = body;\n          }\n\n          delete resp.httpResponse.numBytes;\n          delete resp.httpResponse.buffers;\n        });\n        add('FINALIZE_ERROR', 'retry', function FINALIZE_ERROR(resp) {\n          if (resp.httpResponse.statusCode) {\n            resp.error.statusCode = resp.httpResponse.statusCode;\n\n            if (resp.error.retryable === undefined) {\n              resp.error.retryable = this.service.retryableError(resp.error, this);\n            }\n          }\n        });\n        add('INVALIDATE_CREDENTIALS', 'retry', function INVALIDATE_CREDENTIALS(resp) {\n          if (!resp.error) return;\n\n          switch (resp.error.code) {\n            case 'RequestExpired': // EC2 only\n\n            case 'ExpiredTokenException':\n            case 'ExpiredToken':\n              resp.error.retryable = true;\n              resp.request.service.config.credentials.expired = true;\n          }\n        });\n        add('EXPIRED_SIGNATURE', 'retry', function EXPIRED_SIGNATURE(resp) {\n          var err = resp.error;\n          if (!err) return;\n\n          if (typeof err.code === 'string' && typeof err.message === 'string') {\n            if (err.code.match(/Signature/) && err.message.match(/expired/)) {\n              resp.error.retryable = true;\n            }\n          }\n        });\n        add('CLOCK_SKEWED', 'retry', function CLOCK_SKEWED(resp) {\n          if (!resp.error) return;\n\n          if (this.service.clockSkewError(resp.error) && this.service.config.correctClockSkew) {\n            resp.error.retryable = true;\n          }\n        });\n        add('REDIRECT', 'retry', function REDIRECT(resp) {\n          if (resp.error && resp.error.statusCode >= 300 && resp.error.statusCode < 400 && resp.httpResponse.headers['location']) {\n            this.httpRequest.endpoint = new AWS.Endpoint(resp.httpResponse.headers['location']);\n            this.httpRequest.headers['Host'] = this.httpRequest.endpoint.host;\n            resp.error.redirect = true;\n            resp.error.retryable = true;\n          }\n        });\n        add('RETRY_CHECK', 'retry', function RETRY_CHECK(resp) {\n          if (resp.error) {\n            if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {\n              resp.error.retryDelay = 0;\n            } else if (resp.retryCount < resp.maxRetries) {\n              resp.error.retryDelay = this.service.retryDelays(resp.retryCount) || 0;\n            }\n          }\n        });\n        addAsync('RESET_RETRY_STATE', 'afterRetry', function RESET_RETRY_STATE(resp, done) {\n          var delay,\n              willRetry = false;\n\n          if (resp.error) {\n            delay = resp.error.retryDelay || 0;\n\n            if (resp.error.retryable && resp.retryCount < resp.maxRetries) {\n              resp.retryCount++;\n              willRetry = true;\n            } else if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {\n              resp.redirectCount++;\n              willRetry = true;\n            }\n          }\n\n          if (willRetry) {\n            resp.error = null;\n            setTimeout(done, delay);\n          } else {\n            done();\n          }\n        });\n      }),\n      CorePost: new SequentialExecutor().addNamedListeners(function (add) {\n        add('EXTRACT_REQUEST_ID', 'extractData', AWS.util.extractRequestId);\n        add('EXTRACT_REQUEST_ID', 'extractError', AWS.util.extractRequestId);\n        add('ENOTFOUND_ERROR', 'httpError', function ENOTFOUND_ERROR(err) {\n          if (err.code === 'NetworkingError' && err.errno === 'ENOTFOUND') {\n            var message = 'Inaccessible host: `' + err.hostname + '\\'. This service may not be available in the `' + err.region + '\\' region.';\n            this.response.error = AWS.util.error(new Error(message), {\n              code: 'UnknownEndpoint',\n              region: err.region,\n              hostname: err.hostname,\n              retryable: true,\n              originalError: err\n            });\n          }\n        });\n      }),\n      Logger: new SequentialExecutor().addNamedListeners(function (add) {\n        add('LOG_REQUEST', 'complete', function LOG_REQUEST(resp) {\n          var req = resp.request;\n          var logger = req.service.config.logger;\n          if (!logger) return;\n\n          function filterSensitiveLog(inputShape, shape) {\n            if (!shape) {\n              return shape;\n            }\n\n            switch (inputShape.type) {\n              case 'structure':\n                var struct = {};\n                AWS.util.each(shape, function (subShapeName, subShape) {\n                  if (Object.prototype.hasOwnProperty.call(inputShape.members, subShapeName)) {\n                    struct[subShapeName] = filterSensitiveLog(inputShape.members[subShapeName], subShape);\n                  } else {\n                    struct[subShapeName] = subShape;\n                  }\n                });\n                return struct;\n\n              case 'list':\n                var list = [];\n                AWS.util.arrayEach(shape, function (subShape, index) {\n                  list.push(filterSensitiveLog(inputShape.member, subShape));\n                });\n                return list;\n\n              case 'map':\n                var map = {};\n                AWS.util.each(shape, function (key, value) {\n                  map[key] = filterSensitiveLog(inputShape.value, value);\n                });\n                return map;\n\n              default:\n                if (inputShape.isSensitive) {\n                  return '***SensitiveInformation***';\n                } else {\n                  return shape;\n                }\n\n            }\n          }\n\n          function buildMessage() {\n            var time = resp.request.service.getSkewCorrectedDate().getTime();\n            var delta = (time - req.startTime.getTime()) / 1000;\n            var ansi = logger.isTTY ? true : false;\n            var status = resp.httpResponse.statusCode;\n            var censoredParams = req.params;\n\n            if (req.service.api.operations && req.service.api.operations[req.operation] && req.service.api.operations[req.operation].input) {\n              var inputShape = req.service.api.operations[req.operation].input;\n              censoredParams = filterSensitiveLog(inputShape, req.params);\n            }\n\n            var params = require('util').inspect(censoredParams, true, null);\n\n            var message = '';\n            if (ansi) message += '\\x1B[33m';\n            message += '[AWS ' + req.service.serviceIdentifier + ' ' + status;\n            message += ' ' + delta.toString() + 's ' + resp.retryCount + ' retries]';\n            if (ansi) message += '\\x1B[0;1m';\n            message += ' ' + AWS.util.string.lowerFirst(req.operation);\n            message += '(' + params + ')';\n            if (ansi) message += '\\x1B[0m';\n            return message;\n          }\n\n          var line = buildMessage();\n\n          if (typeof logger.log === 'function') {\n            logger.log(line);\n          } else if (typeof logger.write === 'function') {\n            logger.write(line + '\\n');\n          }\n        });\n      }),\n      Json: new SequentialExecutor().addNamedListeners(function (add) {\n        var svc = require('./protocol/json');\n\n        add('BUILD', 'build', svc.buildRequest);\n        add('EXTRACT_DATA', 'extractData', svc.extractData);\n        add('EXTRACT_ERROR', 'extractError', svc.extractError);\n      }),\n      Rest: new SequentialExecutor().addNamedListeners(function (add) {\n        var svc = require('./protocol/rest');\n\n        add('BUILD', 'build', svc.buildRequest);\n        add('EXTRACT_DATA', 'extractData', svc.extractData);\n        add('EXTRACT_ERROR', 'extractError', svc.extractError);\n      }),\n      RestJson: new SequentialExecutor().addNamedListeners(function (add) {\n        var svc = require('./protocol/rest_json');\n\n        add('BUILD', 'build', svc.buildRequest);\n        add('EXTRACT_DATA', 'extractData', svc.extractData);\n        add('EXTRACT_ERROR', 'extractError', svc.extractError);\n      }),\n      RestXml: new SequentialExecutor().addNamedListeners(function (add) {\n        var svc = require('./protocol/rest_xml');\n\n        add('BUILD', 'build', svc.buildRequest);\n        add('EXTRACT_DATA', 'extractData', svc.extractData);\n        add('EXTRACT_ERROR', 'extractError', svc.extractError);\n      }),\n      Query: new SequentialExecutor().addNamedListeners(function (add) {\n        var svc = require('./protocol/query');\n\n        add('BUILD', 'build', svc.buildRequest);\n        add('EXTRACT_DATA', 'extractData', svc.extractData);\n        add('EXTRACT_ERROR', 'extractError', svc.extractError);\n      })\n    };\n  }, {\n    \"./core\": 18,\n    \"./discover_endpoint\": 26,\n    \"./protocol/json\": 46,\n    \"./protocol/query\": 47,\n    \"./protocol/rest\": 48,\n    \"./protocol/rest_json\": 49,\n    \"./protocol/rest_xml\": 50,\n    \"./sequential_executor\": 58,\n    \"util\": 97\n  }],\n  34: [function (require, module, exports) {\n    var AWS = require('./core');\n\n    var inherit = AWS.util.inherit;\n    /**\n     * The endpoint that a service will talk to, for example,\n     * `'https://ec2.ap-southeast-1.amazonaws.com'`. If\n     * you need to override an endpoint for a service, you can\n     * set the endpoint on a service by passing the endpoint\n     * object with the `endpoint` option key:\n     *\n     * ```javascript\n     * var ep = new AWS.Endpoint('awsproxy.example.com');\n     * var s3 = new AWS.S3({endpoint: ep});\n     * s3.service.endpoint.hostname == 'awsproxy.example.com'\n     * ```\n     *\n     * Note that if you do not specify a protocol, the protocol will\n     * be selected based on your current {AWS.config} configuration.\n     *\n     * @!attribute protocol\n     *   @return [String] the protocol (http or https) of the endpoint\n     *     URL\n     * @!attribute hostname\n     *   @return [String] the host portion of the endpoint, e.g.,\n     *     example.com\n     * @!attribute host\n     *   @return [String] the host portion of the endpoint including\n     *     the port, e.g., example.com:80\n     * @!attribute port\n     *   @return [Integer] the port of the endpoint\n     * @!attribute href\n     *   @return [String] the full URL of the endpoint\n     */\n\n    AWS.Endpoint = inherit({\n      /**\n       * @overload Endpoint(endpoint)\n       *   Constructs a new endpoint given an endpoint URL. If the\n       *   URL omits a protocol (http or https), the default protocol\n       *   set in the global {AWS.config} will be used.\n       *   @param endpoint [String] the URL to construct an endpoint from\n       */\n      constructor: function Endpoint(endpoint, config) {\n        AWS.util.hideProperties(this, ['slashes', 'auth', 'hash', 'search', 'query']);\n\n        if (typeof endpoint === 'undefined' || endpoint === null) {\n          throw new Error('Invalid endpoint: ' + endpoint);\n        } else if (typeof endpoint !== 'string') {\n          return AWS.util.copy(endpoint);\n        }\n\n        if (!endpoint.match(/^http/)) {\n          var useSSL = config && config.sslEnabled !== undefined ? config.sslEnabled : AWS.config.sslEnabled;\n          endpoint = (useSSL ? 'https' : 'http') + '://' + endpoint;\n        }\n\n        AWS.util.update(this, AWS.util.urlParse(endpoint)); // Ensure the port property is set as an integer\n\n        if (this.port) {\n          this.port = parseInt(this.port, 10);\n        } else {\n          this.port = this.protocol === 'https:' ? 443 : 80;\n        }\n      }\n    });\n    /**\n     * The low level HTTP request object, encapsulating all HTTP header\n     * and body data sent by a service request.\n     *\n     * @!attribute method\n     *   @return [String] the HTTP method of the request\n     * @!attribute path\n     *   @return [String] the path portion of the URI, e.g.,\n     *     \"/list/?start=5&num=10\"\n     * @!attribute headers\n     *   @return [map<String,String>]\n     *     a map of header keys and their respective values\n     * @!attribute body\n     *   @return [String] the request body payload\n     * @!attribute endpoint\n     *   @return [AWS.Endpoint] the endpoint for the request\n     * @!attribute region\n     *   @api private\n     *   @return [String] the region, for signing purposes only.\n     */\n\n    AWS.HttpRequest = inherit({\n      /**\n       * @api private\n       */\n      constructor: function HttpRequest(endpoint, region) {\n        endpoint = new AWS.Endpoint(endpoint);\n        this.method = 'POST';\n        this.path = endpoint.path || '/';\n        this.headers = {};\n        this.body = '';\n        this.endpoint = endpoint;\n        this.region = region;\n        this._userAgent = '';\n        this.setUserAgent();\n      },\n\n      /**\n       * @api private\n       */\n      setUserAgent: function setUserAgent() {\n        this._userAgent = this.headers[this.getUserAgentHeaderName()] = AWS.util.userAgent();\n      },\n      getUserAgentHeaderName: function getUserAgentHeaderName() {\n        var prefix = AWS.util.isBrowser() ? 'X-Amz-' : '';\n        return prefix + 'User-Agent';\n      },\n\n      /**\n       * @api private\n       */\n      appendToUserAgent: function appendToUserAgent(agentPartial) {\n        if (typeof agentPartial === 'string' && agentPartial) {\n          this._userAgent += ' ' + agentPartial;\n        }\n\n        this.headers[this.getUserAgentHeaderName()] = this._userAgent;\n      },\n\n      /**\n       * @api private\n       */\n      getUserAgent: function getUserAgent() {\n        return this._userAgent;\n      },\n\n      /**\n       * @return [String] the part of the {path} excluding the\n       *   query string\n       */\n      pathname: function pathname() {\n        return this.path.split('?', 1)[0];\n      },\n\n      /**\n       * @return [String] the query string portion of the {path}\n       */\n      search: function search() {\n        var query = this.path.split('?', 2)[1];\n\n        if (query) {\n          query = AWS.util.queryStringParse(query);\n          return AWS.util.queryParamsToString(query);\n        }\n\n        return '';\n      },\n\n      /**\n       * @api private\n       * update httpRequest endpoint with endpoint string\n       */\n      updateEndpoint: function updateEndpoint(endpointStr) {\n        var newEndpoint = new AWS.Endpoint(endpointStr);\n        this.endpoint = newEndpoint;\n        this.path = newEndpoint.path || '/';\n      }\n    });\n    /**\n     * The low level HTTP response object, encapsulating all HTTP header\n     * and body data returned from the request.\n     *\n     * @!attribute statusCode\n     *   @return [Integer] the HTTP status code of the response (e.g., 200, 404)\n     * @!attribute headers\n     *   @return [map<String,String>]\n     *      a map of response header keys and their respective values\n     * @!attribute body\n     *   @return [String] the response body payload\n     * @!attribute [r] streaming\n     *   @return [Boolean] whether this response is being streamed at a low-level.\n     *     Defaults to `false` (buffered reads). Do not modify this manually, use\n     *     {createUnbufferedStream} to convert the stream to unbuffered mode\n     *     instead.\n     */\n\n    AWS.HttpResponse = inherit({\n      /**\n       * @api private\n       */\n      constructor: function HttpResponse() {\n        this.statusCode = undefined;\n        this.headers = {};\n        this.body = undefined;\n        this.streaming = false;\n        this.stream = null;\n      },\n\n      /**\n       * Disables buffering on the HTTP response and returns the stream for reading.\n       * @return [Stream, XMLHttpRequest, null] the underlying stream object.\n       *   Use this object to directly read data off of the stream.\n       * @note This object is only available after the {AWS.Request~httpHeaders}\n       *   event has fired. This method must be called prior to\n       *   {AWS.Request~httpData}.\n       * @example Taking control of a stream\n       *   request.on('httpHeaders', function(statusCode, headers) {\n       *     if (statusCode < 300) {\n       *       if (headers.etag === 'xyz') {\n       *         // pipe the stream, disabling buffering\n       *         var stream = this.response.httpResponse.createUnbufferedStream();\n       *         stream.pipe(process.stdout);\n       *       } else { // abort this request and set a better error message\n       *         this.abort();\n       *         this.response.error = new Error('Invalid ETag');\n       *       }\n       *     }\n       *   }).send(console.log);\n       */\n      createUnbufferedStream: function createUnbufferedStream() {\n        this.streaming = true;\n        return this.stream;\n      }\n    });\n    AWS.HttpClient = inherit({});\n    /**\n     * @api private\n     */\n\n    AWS.HttpClient.getInstance = function getInstance() {\n      if (this.singleton === undefined) {\n        this.singleton = new this();\n      }\n\n      return this.singleton;\n    };\n  }, {\n    \"./core\": 18\n  }],\n  35: [function (require, module, exports) {\n    var AWS = require('../core');\n\n    var EventEmitter = require('events').EventEmitter;\n\n    require('../http');\n    /**\n     * @api private\n     */\n\n\n    AWS.XHRClient = AWS.util.inherit({\n      handleRequest: function handleRequest(httpRequest, httpOptions, callback, errCallback) {\n        var self = this;\n        var endpoint = httpRequest.endpoint;\n        var emitter = new EventEmitter();\n        var href = endpoint.protocol + '//' + endpoint.hostname;\n\n        if (endpoint.port !== 80 && endpoint.port !== 443) {\n          href += ':' + endpoint.port;\n        }\n\n        href += httpRequest.path;\n        var xhr = new XMLHttpRequest(),\n            headersEmitted = false;\n        httpRequest.stream = xhr;\n        xhr.addEventListener('readystatechange', function () {\n          try {\n            if (xhr.status === 0) return; // 0 code is invalid\n          } catch (e) {\n            return;\n          }\n\n          if (this.readyState >= this.HEADERS_RECEIVED && !headersEmitted) {\n            emitter.statusCode = xhr.status;\n            emitter.headers = self.parseHeaders(xhr.getAllResponseHeaders());\n            emitter.emit('headers', emitter.statusCode, emitter.headers, xhr.statusText);\n            headersEmitted = true;\n          }\n\n          if (this.readyState === this.DONE) {\n            self.finishRequest(xhr, emitter);\n          }\n        }, false);\n        xhr.upload.addEventListener('progress', function (evt) {\n          emitter.emit('sendProgress', evt);\n        });\n        xhr.addEventListener('progress', function (evt) {\n          emitter.emit('receiveProgress', evt);\n        }, false);\n        xhr.addEventListener('timeout', function () {\n          errCallback(AWS.util.error(new Error('Timeout'), {\n            code: 'TimeoutError'\n          }));\n        }, false);\n        xhr.addEventListener('error', function () {\n          errCallback(AWS.util.error(new Error('Network Failure'), {\n            code: 'NetworkingError'\n          }));\n        }, false);\n        xhr.addEventListener('abort', function () {\n          errCallback(AWS.util.error(new Error('Request aborted'), {\n            code: 'RequestAbortedError'\n          }));\n        }, false);\n        callback(emitter);\n        xhr.open(httpRequest.method, href, httpOptions.xhrAsync !== false);\n        AWS.util.each(httpRequest.headers, function (key, value) {\n          if (key !== 'Content-Length' && key !== 'User-Agent' && key !== 'Host') {\n            xhr.setRequestHeader(key, value);\n          }\n        });\n\n        if (httpOptions.timeout && httpOptions.xhrAsync !== false) {\n          xhr.timeout = httpOptions.timeout;\n        }\n\n        if (httpOptions.xhrWithCredentials) {\n          xhr.withCredentials = true;\n        }\n\n        try {\n          xhr.responseType = 'arraybuffer';\n        } catch (e) {}\n\n        try {\n          if (httpRequest.body) {\n            xhr.send(httpRequest.body);\n          } else {\n            xhr.send();\n          }\n        } catch (err) {\n          if (httpRequest.body && typeof httpRequest.body.buffer === 'object') {\n            xhr.send(httpRequest.body.buffer); // send ArrayBuffer directly\n          } else {\n            throw err;\n          }\n        }\n\n        return emitter;\n      },\n      parseHeaders: function parseHeaders(rawHeaders) {\n        var headers = {};\n        AWS.util.arrayEach(rawHeaders.split(/\\r?\\n/), function (line) {\n          var key = line.split(':', 1)[0];\n          var value = line.substring(key.length + 2);\n          if (key.length > 0) headers[key.toLowerCase()] = value;\n        });\n        return headers;\n      },\n      finishRequest: function finishRequest(xhr, emitter) {\n        var buffer;\n\n        if (xhr.responseType === 'arraybuffer' && xhr.response) {\n          var ab = xhr.response;\n          buffer = new AWS.util.Buffer(ab.byteLength);\n          var view = new Uint8Array(ab);\n\n          for (var i = 0; i < buffer.length; ++i) {\n            buffer[i] = view[i];\n          }\n        }\n\n        try {\n          if (!buffer && typeof xhr.responseText === 'string') {\n            buffer = new AWS.util.Buffer(xhr.responseText);\n          }\n        } catch (e) {}\n\n        if (buffer) emitter.emit('data', buffer);\n        emitter.emit('end');\n      }\n    });\n    /**\n     * @api private\n     */\n\n    AWS.HttpClient.prototype = AWS.XHRClient.prototype;\n    /**\n     * @api private\n     */\n\n    AWS.HttpClient.streamsApiVersion = 1;\n  }, {\n    \"../core\": 18,\n    \"../http\": 34,\n    \"events\": 82\n  }],\n  36: [function (require, module, exports) {\n    var util = require('../util');\n\n    function JsonBuilder() {}\n\n    JsonBuilder.prototype.build = function (value, shape) {\n      return JSON.stringify(translate(value, shape));\n    };\n\n    function translate(value, shape) {\n      if (!shape || value === undefined || value === null) return undefined;\n\n      switch (shape.type) {\n        case 'structure':\n          return translateStructure(value, shape);\n\n        case 'map':\n          return translateMap(value, shape);\n\n        case 'list':\n          return translateList(value, shape);\n\n        default:\n          return translateScalar(value, shape);\n      }\n    }\n\n    function translateStructure(structure, shape) {\n      var struct = {};\n      util.each(structure, function (name, value) {\n        var memberShape = shape.members[name];\n\n        if (memberShape) {\n          if (memberShape.location !== 'body') return;\n          var locationName = memberShape.isLocationName ? memberShape.name : name;\n          var result = translate(value, memberShape);\n          if (result !== undefined) struct[locationName] = result;\n        }\n      });\n      return struct;\n    }\n\n    function translateList(list, shape) {\n      var out = [];\n      util.arrayEach(list, function (value) {\n        var result = translate(value, shape.member);\n        if (result !== undefined) out.push(result);\n      });\n      return out;\n    }\n\n    function translateMap(map, shape) {\n      var out = {};\n      util.each(map, function (key, value) {\n        var result = translate(value, shape.value);\n        if (result !== undefined) out[key] = result;\n      });\n      return out;\n    }\n\n    function translateScalar(value, shape) {\n      return shape.toWireFormat(value);\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = JsonBuilder;\n  }, {\n    \"../util\": 71\n  }],\n  37: [function (require, module, exports) {\n    var util = require('../util');\n\n    function JsonParser() {}\n\n    JsonParser.prototype.parse = function (value, shape) {\n      return translate(JSON.parse(value), shape);\n    };\n\n    function translate(value, shape) {\n      if (!shape || value === undefined) return undefined;\n\n      switch (shape.type) {\n        case 'structure':\n          return translateStructure(value, shape);\n\n        case 'map':\n          return translateMap(value, shape);\n\n        case 'list':\n          return translateList(value, shape);\n\n        default:\n          return translateScalar(value, shape);\n      }\n    }\n\n    function translateStructure(structure, shape) {\n      if (structure == null) return undefined;\n      var struct = {};\n      var shapeMembers = shape.members;\n      util.each(shapeMembers, function (name, memberShape) {\n        var locationName = memberShape.isLocationName ? memberShape.name : name;\n\n        if (Object.prototype.hasOwnProperty.call(structure, locationName)) {\n          var value = structure[locationName];\n          var result = translate(value, memberShape);\n          if (result !== undefined) struct[name] = result;\n        }\n      });\n      return struct;\n    }\n\n    function translateList(list, shape) {\n      if (list == null) return undefined;\n      var out = [];\n      util.arrayEach(list, function (value) {\n        var result = translate(value, shape.member);\n        if (result === undefined) out.push(null);else out.push(result);\n      });\n      return out;\n    }\n\n    function translateMap(map, shape) {\n      if (map == null) return undefined;\n      var out = {};\n      util.each(map, function (key, value) {\n        var result = translate(value, shape.value);\n        if (result === undefined) out[key] = null;else out[key] = result;\n      });\n      return out;\n    }\n\n    function translateScalar(value, shape) {\n      return shape.toType(value);\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = JsonParser;\n  }, {\n    \"../util\": 71\n  }],\n  38: [function (require, module, exports) {\n    var Collection = require('./collection');\n\n    var Operation = require('./operation');\n\n    var Shape = require('./shape');\n\n    var Paginator = require('./paginator');\n\n    var ResourceWaiter = require('./resource_waiter');\n\n    var util = require('../util');\n\n    var property = util.property;\n    var memoizedProperty = util.memoizedProperty;\n\n    function Api(api, options) {\n      var self = this;\n      api = api || {};\n      options = options || {};\n      options.api = this;\n      api.metadata = api.metadata || {};\n      property(this, 'isApi', true, false);\n      property(this, 'apiVersion', api.metadata.apiVersion);\n      property(this, 'endpointPrefix', api.metadata.endpointPrefix);\n      property(this, 'signingName', api.metadata.signingName);\n      property(this, 'globalEndpoint', api.metadata.globalEndpoint);\n      property(this, 'signatureVersion', api.metadata.signatureVersion);\n      property(this, 'jsonVersion', api.metadata.jsonVersion);\n      property(this, 'targetPrefix', api.metadata.targetPrefix);\n      property(this, 'protocol', api.metadata.protocol);\n      property(this, 'timestampFormat', api.metadata.timestampFormat);\n      property(this, 'xmlNamespaceUri', api.metadata.xmlNamespace);\n      property(this, 'abbreviation', api.metadata.serviceAbbreviation);\n      property(this, 'fullName', api.metadata.serviceFullName);\n      property(this, 'serviceId', api.metadata.serviceId);\n      memoizedProperty(this, 'className', function () {\n        var name = api.metadata.serviceAbbreviation || api.metadata.serviceFullName;\n        if (!name) return null;\n        name = name.replace(/^Amazon|AWS\\s*|\\(.*|\\s+|\\W+/g, '');\n        if (name === 'ElasticLoadBalancing') name = 'ELB';\n        return name;\n      });\n\n      function addEndpointOperation(name, operation) {\n        if (operation.endpointoperation === true) {\n          property(self, 'endpointOperation', util.string.lowerFirst(name));\n        }\n      }\n\n      property(this, 'operations', new Collection(api.operations, options, function (name, operation) {\n        return new Operation(name, operation, options);\n      }, util.string.lowerFirst, addEndpointOperation));\n      property(this, 'shapes', new Collection(api.shapes, options, function (name, shape) {\n        return Shape.create(shape, options);\n      }));\n      property(this, 'paginators', new Collection(api.paginators, options, function (name, paginator) {\n        return new Paginator(name, paginator, options);\n      }));\n      property(this, 'waiters', new Collection(api.waiters, options, function (name, waiter) {\n        return new ResourceWaiter(name, waiter, options);\n      }, util.string.lowerFirst));\n\n      if (options.documentation) {\n        property(this, 'documentation', api.documentation);\n        property(this, 'documentationUrl', api.documentationUrl);\n      }\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = Api;\n  }, {\n    \"../util\": 71,\n    \"./collection\": 39,\n    \"./operation\": 40,\n    \"./paginator\": 41,\n    \"./resource_waiter\": 42,\n    \"./shape\": 43\n  }],\n  39: [function (require, module, exports) {\n    var memoizedProperty = require('../util').memoizedProperty;\n\n    function memoize(name, value, factory, nameTr) {\n      memoizedProperty(this, nameTr(name), function () {\n        return factory(name, value);\n      });\n    }\n\n    function Collection(iterable, options, factory, nameTr, callback) {\n      nameTr = nameTr || String;\n      var self = this;\n\n      for (var id in iterable) {\n        if (Object.prototype.hasOwnProperty.call(iterable, id)) {\n          memoize.call(self, id, iterable[id], factory, nameTr);\n          if (callback) callback(id, iterable[id]);\n        }\n      }\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = Collection;\n  }, {\n    \"../util\": 71\n  }],\n  40: [function (require, module, exports) {\n    var Shape = require('./shape');\n\n    var util = require('../util');\n\n    var property = util.property;\n    var memoizedProperty = util.memoizedProperty;\n\n    function Operation(name, operation, options) {\n      var self = this;\n      options = options || {};\n      property(this, 'name', operation.name || name);\n      property(this, 'api', options.api, false);\n      operation.http = operation.http || {};\n      property(this, 'endpoint', operation.endpoint);\n      property(this, 'httpMethod', operation.http.method || 'POST');\n      property(this, 'httpPath', operation.http.requestUri || '/');\n      property(this, 'authtype', operation.authtype || '');\n      property(this, 'endpointDiscoveryRequired', operation.endpointdiscovery ? operation.endpointdiscovery.required ? 'REQUIRED' : 'OPTIONAL' : 'NULL');\n      memoizedProperty(this, 'input', function () {\n        if (!operation.input) {\n          return new Shape.create({\n            type: 'structure'\n          }, options);\n        }\n\n        return Shape.create(operation.input, options);\n      });\n      memoizedProperty(this, 'output', function () {\n        if (!operation.output) {\n          return new Shape.create({\n            type: 'structure'\n          }, options);\n        }\n\n        return Shape.create(operation.output, options);\n      });\n      memoizedProperty(this, 'errors', function () {\n        var list = [];\n        if (!operation.errors) return null;\n\n        for (var i = 0; i < operation.errors.length; i++) {\n          list.push(Shape.create(operation.errors[i], options));\n        }\n\n        return list;\n      });\n      memoizedProperty(this, 'paginator', function () {\n        return options.api.paginators[name];\n      });\n\n      if (options.documentation) {\n        property(this, 'documentation', operation.documentation);\n        property(this, 'documentationUrl', operation.documentationUrl);\n      } // idempotentMembers only tracks top-level input shapes\n\n\n      memoizedProperty(this, 'idempotentMembers', function () {\n        var idempotentMembers = [];\n        var input = self.input;\n        var members = input.members;\n\n        if (!input.members) {\n          return idempotentMembers;\n        }\n\n        for (var name in members) {\n          if (!members.hasOwnProperty(name)) {\n            continue;\n          }\n\n          if (members[name].isIdempotent === true) {\n            idempotentMembers.push(name);\n          }\n        }\n\n        return idempotentMembers;\n      });\n      memoizedProperty(this, 'hasEventOutput', function () {\n        var output = self.output;\n        return hasEventStream(output);\n      });\n    }\n\n    function hasEventStream(topLevelShape) {\n      var members = topLevelShape.members;\n      var payload = topLevelShape.payload;\n\n      if (!topLevelShape.members) {\n        return false;\n      }\n\n      if (payload) {\n        var payloadMember = members[payload];\n        return payloadMember.isEventStream;\n      } // check if any member is an event stream\n\n\n      for (var name in members) {\n        if (!members.hasOwnProperty(name)) {\n          if (members[name].isEventStream === true) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = Operation;\n  }, {\n    \"../util\": 71,\n    \"./shape\": 43\n  }],\n  41: [function (require, module, exports) {\n    var property = require('../util').property;\n\n    function Paginator(name, paginator) {\n      property(this, 'inputToken', paginator.input_token);\n      property(this, 'limitKey', paginator.limit_key);\n      property(this, 'moreResults', paginator.more_results);\n      property(this, 'outputToken', paginator.output_token);\n      property(this, 'resultKey', paginator.result_key);\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = Paginator;\n  }, {\n    \"../util\": 71\n  }],\n  42: [function (require, module, exports) {\n    var util = require('../util');\n\n    var property = util.property;\n\n    function ResourceWaiter(name, waiter, options) {\n      options = options || {};\n      property(this, 'name', name);\n      property(this, 'api', options.api, false);\n\n      if (waiter.operation) {\n        property(this, 'operation', util.string.lowerFirst(waiter.operation));\n      }\n\n      var self = this;\n      var keys = ['type', 'description', 'delay', 'maxAttempts', 'acceptors'];\n      keys.forEach(function (key) {\n        var value = waiter[key];\n\n        if (value) {\n          property(self, key, value);\n        }\n      });\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = ResourceWaiter;\n  }, {\n    \"../util\": 71\n  }],\n  43: [function (require, module, exports) {\n    var Collection = require('./collection');\n\n    var util = require('../util');\n\n    function property(obj, name, value) {\n      if (value !== null && value !== undefined) {\n        util.property.apply(this, arguments);\n      }\n    }\n\n    function memoizedProperty(obj, name) {\n      if (!obj.constructor.prototype[name]) {\n        util.memoizedProperty.apply(this, arguments);\n      }\n    }\n\n    function Shape(shape, options, memberName) {\n      options = options || {};\n      property(this, 'shape', shape.shape);\n      property(this, 'api', options.api, false);\n      property(this, 'type', shape.type);\n      property(this, 'enum', shape.enum);\n      property(this, 'min', shape.min);\n      property(this, 'max', shape.max);\n      property(this, 'pattern', shape.pattern);\n      property(this, 'location', shape.location || this.location || 'body');\n      property(this, 'name', this.name || shape.xmlName || shape.queryName || shape.locationName || memberName);\n      property(this, 'isStreaming', shape.streaming || this.isStreaming || false);\n      property(this, 'requiresLength', shape.requiresLength, false);\n      property(this, 'isComposite', shape.isComposite || false);\n      property(this, 'isShape', true, false);\n      property(this, 'isQueryName', Boolean(shape.queryName), false);\n      property(this, 'isLocationName', Boolean(shape.locationName), false);\n      property(this, 'isIdempotent', shape.idempotencyToken === true);\n      property(this, 'isJsonValue', shape.jsonvalue === true);\n      property(this, 'isSensitive', shape.sensitive === true || shape.prototype && shape.prototype.sensitive === true);\n      property(this, 'isEventStream', Boolean(shape.eventstream), false);\n      property(this, 'isEvent', Boolean(shape.event), false);\n      property(this, 'isEventPayload', Boolean(shape.eventpayload), false);\n      property(this, 'isEventHeader', Boolean(shape.eventheader), false);\n      property(this, 'isTimestampFormatSet', Boolean(shape.timestampFormat) || shape.prototype && shape.prototype.isTimestampFormatSet === true, false);\n      property(this, 'endpointDiscoveryId', Boolean(shape.endpointdiscoveryid), false);\n      property(this, 'hostLabel', Boolean(shape.hostLabel), false);\n\n      if (options.documentation) {\n        property(this, 'documentation', shape.documentation);\n        property(this, 'documentationUrl', shape.documentationUrl);\n      }\n\n      if (shape.xmlAttribute) {\n        property(this, 'isXmlAttribute', shape.xmlAttribute || false);\n      } // type conversion and parsing\n\n\n      property(this, 'defaultValue', null);\n\n      this.toWireFormat = function (value) {\n        if (value === null || value === undefined) return '';\n        return value;\n      };\n\n      this.toType = function (value) {\n        return value;\n      };\n    }\n    /**\n     * @api private\n     */\n\n\n    Shape.normalizedTypes = {\n      character: 'string',\n      double: 'float',\n      long: 'integer',\n      short: 'integer',\n      biginteger: 'integer',\n      bigdecimal: 'float',\n      blob: 'binary'\n    };\n    /**\n     * @api private\n     */\n\n    Shape.types = {\n      'structure': StructureShape,\n      'list': ListShape,\n      'map': MapShape,\n      'boolean': BooleanShape,\n      'timestamp': TimestampShape,\n      'float': FloatShape,\n      'integer': IntegerShape,\n      'string': StringShape,\n      'base64': Base64Shape,\n      'binary': BinaryShape\n    };\n\n    Shape.resolve = function resolve(shape, options) {\n      if (shape.shape) {\n        var refShape = options.api.shapes[shape.shape];\n\n        if (!refShape) {\n          throw new Error('Cannot find shape reference: ' + shape.shape);\n        }\n\n        return refShape;\n      } else {\n        return null;\n      }\n    };\n\n    Shape.create = function create(shape, options, memberName) {\n      if (shape.isShape) return shape;\n      var refShape = Shape.resolve(shape, options);\n\n      if (refShape) {\n        var filteredKeys = Object.keys(shape);\n\n        if (!options.documentation) {\n          filteredKeys = filteredKeys.filter(function (name) {\n            return !name.match(/documentation/);\n          });\n        } // create an inline shape with extra members\n\n\n        var InlineShape = function () {\n          refShape.constructor.call(this, shape, options, memberName);\n        };\n\n        InlineShape.prototype = refShape;\n        return new InlineShape();\n      } else {\n        // set type if not set\n        if (!shape.type) {\n          if (shape.members) shape.type = 'structure';else if (shape.member) shape.type = 'list';else if (shape.key) shape.type = 'map';else shape.type = 'string';\n        } // normalize types\n\n\n        var origType = shape.type;\n\n        if (Shape.normalizedTypes[shape.type]) {\n          shape.type = Shape.normalizedTypes[shape.type];\n        }\n\n        if (Shape.types[shape.type]) {\n          return new Shape.types[shape.type](shape, options, memberName);\n        } else {\n          throw new Error('Unrecognized shape type: ' + origType);\n        }\n      }\n    };\n\n    function CompositeShape(shape) {\n      Shape.apply(this, arguments);\n      property(this, 'isComposite', true);\n\n      if (shape.flattened) {\n        property(this, 'flattened', shape.flattened || false);\n      }\n    }\n\n    function StructureShape(shape, options) {\n      var self = this;\n      var requiredMap = null,\n          firstInit = !this.isShape;\n      CompositeShape.apply(this, arguments);\n\n      if (firstInit) {\n        property(this, 'defaultValue', function () {\n          return {};\n        });\n        property(this, 'members', {});\n        property(this, 'memberNames', []);\n        property(this, 'required', []);\n        property(this, 'isRequired', function () {\n          return false;\n        });\n      }\n\n      if (shape.members) {\n        property(this, 'members', new Collection(shape.members, options, function (name, member) {\n          return Shape.create(member, options, name);\n        }));\n        memoizedProperty(this, 'memberNames', function () {\n          return shape.xmlOrder || Object.keys(shape.members);\n        });\n\n        if (shape.event) {\n          memoizedProperty(this, 'eventPayloadMemberName', function () {\n            var members = self.members;\n            var memberNames = self.memberNames; // iterate over members to find ones that are event payloads\n\n            for (var i = 0, iLen = memberNames.length; i < iLen; i++) {\n              if (members[memberNames[i]].isEventPayload) {\n                return memberNames[i];\n              }\n            }\n          });\n          memoizedProperty(this, 'eventHeaderMemberNames', function () {\n            var members = self.members;\n            var memberNames = self.memberNames;\n            var eventHeaderMemberNames = []; // iterate over members to find ones that are event headers\n\n            for (var i = 0, iLen = memberNames.length; i < iLen; i++) {\n              if (members[memberNames[i]].isEventHeader) {\n                eventHeaderMemberNames.push(memberNames[i]);\n              }\n            }\n\n            return eventHeaderMemberNames;\n          });\n        }\n      }\n\n      if (shape.required) {\n        property(this, 'required', shape.required);\n        property(this, 'isRequired', function (name) {\n          if (!requiredMap) {\n            requiredMap = {};\n\n            for (var i = 0; i < shape.required.length; i++) {\n              requiredMap[shape.required[i]] = true;\n            }\n          }\n\n          return requiredMap[name];\n        }, false, true);\n      }\n\n      property(this, 'resultWrapper', shape.resultWrapper || null);\n\n      if (shape.payload) {\n        property(this, 'payload', shape.payload);\n      }\n\n      if (typeof shape.xmlNamespace === 'string') {\n        property(this, 'xmlNamespaceUri', shape.xmlNamespace);\n      } else if (typeof shape.xmlNamespace === 'object') {\n        property(this, 'xmlNamespacePrefix', shape.xmlNamespace.prefix);\n        property(this, 'xmlNamespaceUri', shape.xmlNamespace.uri);\n      }\n    }\n\n    function ListShape(shape, options) {\n      var self = this,\n          firstInit = !this.isShape;\n      CompositeShape.apply(this, arguments);\n\n      if (firstInit) {\n        property(this, 'defaultValue', function () {\n          return [];\n        });\n      }\n\n      if (shape.member) {\n        memoizedProperty(this, 'member', function () {\n          return Shape.create(shape.member, options);\n        });\n      }\n\n      if (this.flattened) {\n        var oldName = this.name;\n        memoizedProperty(this, 'name', function () {\n          return self.member.name || oldName;\n        });\n      }\n    }\n\n    function MapShape(shape, options) {\n      var firstInit = !this.isShape;\n      CompositeShape.apply(this, arguments);\n\n      if (firstInit) {\n        property(this, 'defaultValue', function () {\n          return {};\n        });\n        property(this, 'key', Shape.create({\n          type: 'string'\n        }, options));\n        property(this, 'value', Shape.create({\n          type: 'string'\n        }, options));\n      }\n\n      if (shape.key) {\n        memoizedProperty(this, 'key', function () {\n          return Shape.create(shape.key, options);\n        });\n      }\n\n      if (shape.value) {\n        memoizedProperty(this, 'value', function () {\n          return Shape.create(shape.value, options);\n        });\n      }\n    }\n\n    function TimestampShape(shape) {\n      var self = this;\n      Shape.apply(this, arguments);\n\n      if (shape.timestampFormat) {\n        property(this, 'timestampFormat', shape.timestampFormat);\n      } else if (self.isTimestampFormatSet && this.timestampFormat) {\n        property(this, 'timestampFormat', this.timestampFormat);\n      } else if (this.location === 'header') {\n        property(this, 'timestampFormat', 'rfc822');\n      } else if (this.location === 'querystring') {\n        property(this, 'timestampFormat', 'iso8601');\n      } else if (this.api) {\n        switch (this.api.protocol) {\n          case 'json':\n          case 'rest-json':\n            property(this, 'timestampFormat', 'unixTimestamp');\n            break;\n\n          case 'rest-xml':\n          case 'query':\n          case 'ec2':\n            property(this, 'timestampFormat', 'iso8601');\n            break;\n        }\n      }\n\n      this.toType = function (value) {\n        if (value === null || value === undefined) return null;\n        if (typeof value.toUTCString === 'function') return value;\n        return typeof value === 'string' || typeof value === 'number' ? util.date.parseTimestamp(value) : null;\n      };\n\n      this.toWireFormat = function (value) {\n        return util.date.format(value, self.timestampFormat);\n      };\n    }\n\n    function StringShape() {\n      Shape.apply(this, arguments);\n      var nullLessProtocols = ['rest-xml', 'query', 'ec2'];\n\n      this.toType = function (value) {\n        value = this.api && nullLessProtocols.indexOf(this.api.protocol) > -1 ? value || '' : value;\n\n        if (this.isJsonValue) {\n          return JSON.parse(value);\n        }\n\n        return value && typeof value.toString === 'function' ? value.toString() : value;\n      };\n\n      this.toWireFormat = function (value) {\n        return this.isJsonValue ? JSON.stringify(value) : value;\n      };\n    }\n\n    function FloatShape() {\n      Shape.apply(this, arguments);\n\n      this.toType = function (value) {\n        if (value === null || value === undefined) return null;\n        return parseFloat(value);\n      };\n\n      this.toWireFormat = this.toType;\n    }\n\n    function IntegerShape() {\n      Shape.apply(this, arguments);\n\n      this.toType = function (value) {\n        if (value === null || value === undefined) return null;\n        return parseInt(value, 10);\n      };\n\n      this.toWireFormat = this.toType;\n    }\n\n    function BinaryShape() {\n      Shape.apply(this, arguments);\n\n      this.toType = function (value) {\n        var buf = util.base64.decode(value);\n\n        if (this.isSensitive && util.isNode() && typeof util.Buffer.alloc === 'function') {\n          /* Node.js can create a Buffer that is not isolated.\n           * i.e. buf.byteLength !== buf.buffer.byteLength\n           * This means that the sensitive data is accessible to anyone with access to buf.buffer.\n           * If this is the node shared Buffer, then other code within this process _could_ find this secret.\n           * Copy sensitive data to an isolated Buffer and zero the sensitive data.\n           * While this is safe to do here, copying this code somewhere else may produce unexpected results.\n           */\n          var secureBuf = util.Buffer.alloc(buf.length, buf);\n          buf.fill(0);\n          buf = secureBuf;\n        }\n\n        return buf;\n      };\n\n      this.toWireFormat = util.base64.encode;\n    }\n\n    function Base64Shape() {\n      BinaryShape.apply(this, arguments);\n    }\n\n    function BooleanShape() {\n      Shape.apply(this, arguments);\n\n      this.toType = function (value) {\n        if (typeof value === 'boolean') return value;\n        if (value === null || value === undefined) return null;\n        return value === 'true';\n      };\n    }\n    /**\n     * @api private\n     */\n\n\n    Shape.shapes = {\n      StructureShape: StructureShape,\n      ListShape: ListShape,\n      MapShape: MapShape,\n      StringShape: StringShape,\n      BooleanShape: BooleanShape,\n      Base64Shape: Base64Shape\n    };\n    /**\n     * @api private\n     */\n\n    module.exports = Shape;\n  }, {\n    \"../util\": 71,\n    \"./collection\": 39\n  }],\n  44: [function (require, module, exports) {\n    var AWS = require('./core');\n    /**\n     * @api private\n     */\n\n\n    AWS.ParamValidator = AWS.util.inherit({\n      /**\n       * Create a new validator object.\n       *\n       * @param validation [Boolean|map] whether input parameters should be\n       *     validated against the operation description before sending the\n       *     request. Pass a map to enable any of the following specific\n       *     validation features:\n       *\n       *     * **min** [Boolean] &mdash; Validates that a value meets the min\n       *       constraint. This is enabled by default when paramValidation is set\n       *       to `true`.\n       *     * **max** [Boolean] &mdash; Validates that a value meets the max\n       *       constraint.\n       *     * **pattern** [Boolean] &mdash; Validates that a string value matches a\n       *       regular expression.\n       *     * **enum** [Boolean] &mdash; Validates that a string value matches one\n       *       of the allowable enum values.\n       */\n      constructor: function ParamValidator(validation) {\n        if (validation === true || validation === undefined) {\n          validation = {\n            'min': true\n          };\n        }\n\n        this.validation = validation;\n      },\n      validate: function validate(shape, params, context) {\n        this.errors = [];\n        this.validateMember(shape, params || {}, context || 'params');\n\n        if (this.errors.length > 1) {\n          var msg = this.errors.join('\\n* ');\n          msg = 'There were ' + this.errors.length + ' validation errors:\\n* ' + msg;\n          throw AWS.util.error(new Error(msg), {\n            code: 'MultipleValidationErrors',\n            errors: this.errors\n          });\n        } else if (this.errors.length === 1) {\n          throw this.errors[0];\n        } else {\n          return true;\n        }\n      },\n      fail: function fail(code, message) {\n        this.errors.push(AWS.util.error(new Error(message), {\n          code: code\n        }));\n      },\n      validateStructure: function validateStructure(shape, params, context) {\n        this.validateType(params, context, ['object'], 'structure');\n        var paramName;\n\n        for (var i = 0; shape.required && i < shape.required.length; i++) {\n          paramName = shape.required[i];\n          var value = params[paramName];\n\n          if (value === undefined || value === null) {\n            this.fail('MissingRequiredParameter', 'Missing required key \\'' + paramName + '\\' in ' + context);\n          }\n        } // validate hash members\n\n\n        for (paramName in params) {\n          if (!Object.prototype.hasOwnProperty.call(params, paramName)) continue;\n          var paramValue = params[paramName],\n              memberShape = shape.members[paramName];\n\n          if (memberShape !== undefined) {\n            var memberContext = [context, paramName].join('.');\n            this.validateMember(memberShape, paramValue, memberContext);\n          } else {\n            this.fail('UnexpectedParameter', 'Unexpected key \\'' + paramName + '\\' found in ' + context);\n          }\n        }\n\n        return true;\n      },\n      validateMember: function validateMember(shape, param, context) {\n        switch (shape.type) {\n          case 'structure':\n            return this.validateStructure(shape, param, context);\n\n          case 'list':\n            return this.validateList(shape, param, context);\n\n          case 'map':\n            return this.validateMap(shape, param, context);\n\n          default:\n            return this.validateScalar(shape, param, context);\n        }\n      },\n      validateList: function validateList(shape, params, context) {\n        if (this.validateType(params, context, [Array])) {\n          this.validateRange(shape, params.length, context, 'list member count'); // validate array members\n\n          for (var i = 0; i < params.length; i++) {\n            this.validateMember(shape.member, params[i], context + '[' + i + ']');\n          }\n        }\n      },\n      validateMap: function validateMap(shape, params, context) {\n        if (this.validateType(params, context, ['object'], 'map')) {\n          // Build up a count of map members to validate range traits.\n          var mapCount = 0;\n\n          for (var param in params) {\n            if (!Object.prototype.hasOwnProperty.call(params, param)) continue; // Validate any map key trait constraints\n\n            this.validateMember(shape.key, param, context + '[key=\\'' + param + '\\']');\n            this.validateMember(shape.value, params[param], context + '[\\'' + param + '\\']');\n            mapCount++;\n          }\n\n          this.validateRange(shape, mapCount, context, 'map member count');\n        }\n      },\n      validateScalar: function validateScalar(shape, value, context) {\n        switch (shape.type) {\n          case null:\n          case undefined:\n          case 'string':\n            return this.validateString(shape, value, context);\n\n          case 'base64':\n          case 'binary':\n            return this.validatePayload(value, context);\n\n          case 'integer':\n          case 'float':\n            return this.validateNumber(shape, value, context);\n\n          case 'boolean':\n            return this.validateType(value, context, ['boolean']);\n\n          case 'timestamp':\n            return this.validateType(value, context, [Date, /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$/, 'number'], 'Date object, ISO-8601 string, or a UNIX timestamp');\n\n          default:\n            return this.fail('UnkownType', 'Unhandled type ' + shape.type + ' for ' + context);\n        }\n      },\n      validateString: function validateString(shape, value, context) {\n        var validTypes = ['string'];\n\n        if (shape.isJsonValue) {\n          validTypes = validTypes.concat(['number', 'object', 'boolean']);\n        }\n\n        if (value !== null && this.validateType(value, context, validTypes)) {\n          this.validateEnum(shape, value, context);\n          this.validateRange(shape, value.length, context, 'string length');\n          this.validatePattern(shape, value, context);\n          this.validateUri(shape, value, context);\n        }\n      },\n      validateUri: function validateUri(shape, value, context) {\n        if (shape['location'] === 'uri') {\n          if (value.length === 0) {\n            this.fail('UriParameterError', 'Expected uri parameter to have length >= 1,' + ' but found \"' + value + '\" for ' + context);\n          }\n        }\n      },\n      validatePattern: function validatePattern(shape, value, context) {\n        if (this.validation['pattern'] && shape['pattern'] !== undefined) {\n          if (!new RegExp(shape['pattern']).test(value)) {\n            this.fail('PatternMatchError', 'Provided value \"' + value + '\" ' + 'does not match regex pattern /' + shape['pattern'] + '/ for ' + context);\n          }\n        }\n      },\n      validateRange: function validateRange(shape, value, context, descriptor) {\n        if (this.validation['min']) {\n          if (shape['min'] !== undefined && value < shape['min']) {\n            this.fail('MinRangeError', 'Expected ' + descriptor + ' >= ' + shape['min'] + ', but found ' + value + ' for ' + context);\n          }\n        }\n\n        if (this.validation['max']) {\n          if (shape['max'] !== undefined && value > shape['max']) {\n            this.fail('MaxRangeError', 'Expected ' + descriptor + ' <= ' + shape['max'] + ', but found ' + value + ' for ' + context);\n          }\n        }\n      },\n      validateEnum: function validateRange(shape, value, context) {\n        if (this.validation['enum'] && shape['enum'] !== undefined) {\n          // Fail if the string value is not present in the enum list\n          if (shape['enum'].indexOf(value) === -1) {\n            this.fail('EnumError', 'Found string value of ' + value + ', but ' + 'expected ' + shape['enum'].join('|') + ' for ' + context);\n          }\n        }\n      },\n      validateType: function validateType(value, context, acceptedTypes, type) {\n        // We will not log an error for null or undefined, but we will return\n        // false so that callers know that the expected type was not strictly met.\n        if (value === null || value === undefined) return false;\n        var foundInvalidType = false;\n\n        for (var i = 0; i < acceptedTypes.length; i++) {\n          if (typeof acceptedTypes[i] === 'string') {\n            if (typeof value === acceptedTypes[i]) return true;\n          } else if (acceptedTypes[i] instanceof RegExp) {\n            if ((value || '').toString().match(acceptedTypes[i])) return true;\n          } else {\n            if (value instanceof acceptedTypes[i]) return true;\n            if (AWS.util.isType(value, acceptedTypes[i])) return true;\n            if (!type && !foundInvalidType) acceptedTypes = acceptedTypes.slice();\n            acceptedTypes[i] = AWS.util.typeName(acceptedTypes[i]);\n          }\n\n          foundInvalidType = true;\n        }\n\n        var acceptedType = type;\n\n        if (!acceptedType) {\n          acceptedType = acceptedTypes.join(', ').replace(/,([^,]+)$/, ', or$1');\n        }\n\n        var vowel = acceptedType.match(/^[aeiou]/i) ? 'n' : '';\n        this.fail('InvalidParameterType', 'Expected ' + context + ' to be a' + vowel + ' ' + acceptedType);\n        return false;\n      },\n      validateNumber: function validateNumber(shape, value, context) {\n        if (value === null || value === undefined) return;\n\n        if (typeof value === 'string') {\n          var castedValue = parseFloat(value);\n          if (castedValue.toString() === value) value = castedValue;\n        }\n\n        if (this.validateType(value, context, ['number'])) {\n          this.validateRange(shape, value, context, 'numeric value');\n        }\n      },\n      validatePayload: function validatePayload(value, context) {\n        if (value === null || value === undefined) return;\n        if (typeof value === 'string') return;\n        if (value && typeof value.byteLength === 'number') return; // typed arrays\n\n        if (AWS.util.isNode()) {\n          // special check for buffer/stream in Node.js\n          var Stream = AWS.util.stream.Stream;\n          if (AWS.util.Buffer.isBuffer(value) || value instanceof Stream) return;\n        } else {\n          if (typeof Blob !== void 0 && value instanceof Blob) return;\n        }\n\n        var types = ['Buffer', 'Stream', 'File', 'Blob', 'ArrayBuffer', 'DataView'];\n\n        if (value) {\n          for (var i = 0; i < types.length; i++) {\n            if (AWS.util.isType(value, types[i])) return;\n            if (AWS.util.typeName(value.constructor) === types[i]) return;\n          }\n        }\n\n        this.fail('InvalidParameterType', 'Expected ' + context + ' to be a ' + 'string, Buffer, Stream, Blob, or typed array object');\n      }\n    });\n  }, {\n    \"./core\": 18\n  }],\n  45: [function (require, module, exports) {\n    var util = require('../util');\n\n    var AWS = require('../core');\n    /**\n     * Prepend prefix defined by API model to endpoint that's already\n     * constructed. This feature does not apply to operations using\n     * endpoint discovery and can be disabled.\n     * @api private\n     */\n\n\n    function populateHostPrefix(request) {\n      var enabled = request.service.config.hostPrefixEnabled;\n      if (!enabled) return request;\n      var operationModel = request.service.api.operations[request.operation]; //don't marshal host prefix when operation has endpoint discovery traits\n\n      if (hasEndpointDiscover(request)) return request;\n\n      if (operationModel.endpoint && operationModel.endpoint.hostPrefix) {\n        var hostPrefixNotation = operationModel.endpoint.hostPrefix;\n        var hostPrefix = expandHostPrefix(hostPrefixNotation, request.params, operationModel.input);\n        prependEndpointPrefix(request.httpRequest.endpoint, hostPrefix);\n        validateHostname(request.httpRequest.endpoint.hostname);\n      }\n\n      return request;\n    }\n    /**\n     * @api private\n     */\n\n\n    function hasEndpointDiscover(request) {\n      var api = request.service.api;\n      var operationModel = api.operations[request.operation];\n      var isEndpointOperation = api.endpointOperation && api.endpointOperation === util.string.lowerFirst(operationModel.name);\n      return operationModel.endpointDiscoveryRequired !== 'NULL' || isEndpointOperation === true;\n    }\n    /**\n     * @api private\n     */\n\n\n    function expandHostPrefix(hostPrefixNotation, params, shape) {\n      util.each(shape.members, function (name, member) {\n        if (member.hostLabel === true) {\n          if (typeof params[name] !== 'string' || params[name] === '') {\n            throw util.error(new Error(), {\n              message: 'Parameter ' + name + ' should be a non-empty string.',\n              code: 'InvalidParameter'\n            });\n          }\n\n          var regex = new RegExp('\\\\{' + name + '\\\\}', 'g');\n          hostPrefixNotation = hostPrefixNotation.replace(regex, params[name]);\n        }\n      });\n      return hostPrefixNotation;\n    }\n    /**\n     * @api private\n     */\n\n\n    function prependEndpointPrefix(endpoint, prefix) {\n      if (endpoint.host) {\n        endpoint.host = prefix + endpoint.host;\n      }\n\n      if (endpoint.hostname) {\n        endpoint.hostname = prefix + endpoint.hostname;\n      }\n    }\n    /**\n     * @api private\n     */\n\n\n    function validateHostname(hostname) {\n      var labels = hostname.split('.'); //Reference: https://tools.ietf.org/html/rfc1123#section-2\n\n      var hostPattern = /^[a-zA-Z0-9]{1}$|^[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9]$/;\n      util.arrayEach(labels, function (label) {\n        if (!label.length || label.length < 1 || label.length > 63) {\n          throw util.error(new Error(), {\n            code: 'ValidationError',\n            message: 'Hostname label length should be between 1 to 63 characters, inclusive.'\n          });\n        }\n\n        if (!hostPattern.test(label)) {\n          throw AWS.util.error(new Error(), {\n            code: 'ValidationError',\n            message: label + ' is not hostname compatible.'\n          });\n        }\n      });\n    }\n\n    module.exports = {\n      populateHostPrefix: populateHostPrefix\n    };\n  }, {\n    \"../core\": 18,\n    \"../util\": 71\n  }],\n  46: [function (require, module, exports) {\n    var util = require('../util');\n\n    var JsonBuilder = require('../json/builder');\n\n    var JsonParser = require('../json/parser');\n\n    var populateHostPrefix = require('./helpers').populateHostPrefix;\n\n    function buildRequest(req) {\n      var httpRequest = req.httpRequest;\n      var api = req.service.api;\n      var target = api.targetPrefix + '.' + api.operations[req.operation].name;\n      var version = api.jsonVersion || '1.0';\n      var input = api.operations[req.operation].input;\n      var builder = new JsonBuilder();\n      if (version === 1) version = '1.0';\n      httpRequest.body = builder.build(req.params || {}, input);\n      httpRequest.headers['Content-Type'] = 'application/x-amz-json-' + version;\n      httpRequest.headers['X-Amz-Target'] = target;\n      populateHostPrefix(req);\n    }\n\n    function extractError(resp) {\n      var error = {};\n      var httpResponse = resp.httpResponse;\n      error.code = httpResponse.headers['x-amzn-errortype'] || 'UnknownError';\n\n      if (typeof error.code === 'string') {\n        error.code = error.code.split(':')[0];\n      }\n\n      if (httpResponse.body.length > 0) {\n        try {\n          var e = JSON.parse(httpResponse.body.toString());\n\n          if (e.__type || e.code) {\n            error.code = (e.__type || e.code).split('#').pop();\n          }\n\n          if (error.code === 'RequestEntityTooLarge') {\n            error.message = 'Request body must be less than 1 MB';\n          } else {\n            error.message = e.message || e.Message || null;\n          }\n        } catch (e) {\n          error.statusCode = httpResponse.statusCode;\n          error.message = httpResponse.statusMessage;\n        }\n      } else {\n        error.statusCode = httpResponse.statusCode;\n        error.message = httpResponse.statusCode.toString();\n      }\n\n      resp.error = util.error(new Error(), error);\n    }\n\n    function extractData(resp) {\n      var body = resp.httpResponse.body.toString() || '{}';\n\n      if (resp.request.service.config.convertResponseTypes === false) {\n        resp.data = JSON.parse(body);\n      } else {\n        var operation = resp.request.service.api.operations[resp.request.operation];\n        var shape = operation.output || {};\n        var parser = new JsonParser();\n        resp.data = parser.parse(body, shape);\n      }\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = {\n      buildRequest: buildRequest,\n      extractError: extractError,\n      extractData: extractData\n    };\n  }, {\n    \"../json/builder\": 36,\n    \"../json/parser\": 37,\n    \"../util\": 71,\n    \"./helpers\": 45\n  }],\n  47: [function (require, module, exports) {\n    var AWS = require('../core');\n\n    var util = require('../util');\n\n    var QueryParamSerializer = require('../query/query_param_serializer');\n\n    var Shape = require('../model/shape');\n\n    var populateHostPrefix = require('./helpers').populateHostPrefix;\n\n    function buildRequest(req) {\n      var operation = req.service.api.operations[req.operation];\n      var httpRequest = req.httpRequest;\n      httpRequest.headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=utf-8';\n      httpRequest.params = {\n        Version: req.service.api.apiVersion,\n        Action: operation.name\n      }; // convert the request parameters into a list of query params,\n      // e.g. Deeply.NestedParam.0.Name=value\n\n      var builder = new QueryParamSerializer();\n      builder.serialize(req.params, operation.input, function (name, value) {\n        httpRequest.params[name] = value;\n      });\n      httpRequest.body = util.queryParamsToString(httpRequest.params);\n      populateHostPrefix(req);\n    }\n\n    function extractError(resp) {\n      var data,\n          body = resp.httpResponse.body.toString();\n\n      if (body.match('<UnknownOperationException')) {\n        data = {\n          Code: 'UnknownOperation',\n          Message: 'Unknown operation ' + resp.request.operation\n        };\n      } else {\n        try {\n          data = new AWS.XML.Parser().parse(body);\n        } catch (e) {\n          data = {\n            Code: resp.httpResponse.statusCode,\n            Message: resp.httpResponse.statusMessage\n          };\n        }\n      }\n\n      if (data.requestId && !resp.requestId) resp.requestId = data.requestId;\n      if (data.Errors) data = data.Errors;\n      if (data.Error) data = data.Error;\n\n      if (data.Code) {\n        resp.error = util.error(new Error(), {\n          code: data.Code,\n          message: data.Message\n        });\n      } else {\n        resp.error = util.error(new Error(), {\n          code: resp.httpResponse.statusCode,\n          message: null\n        });\n      }\n    }\n\n    function extractData(resp) {\n      var req = resp.request;\n      var operation = req.service.api.operations[req.operation];\n      var shape = operation.output || {};\n      var origRules = shape;\n\n      if (origRules.resultWrapper) {\n        var tmp = Shape.create({\n          type: 'structure'\n        });\n        tmp.members[origRules.resultWrapper] = shape;\n        tmp.memberNames = [origRules.resultWrapper];\n        util.property(shape, 'name', shape.resultWrapper);\n        shape = tmp;\n      }\n\n      var parser = new AWS.XML.Parser(); // TODO: Refactor XML Parser to parse RequestId from response.\n\n      if (shape && shape.members && !shape.members._XAMZRequestId) {\n        var requestIdShape = Shape.create({\n          type: 'string'\n        }, {\n          api: {\n            protocol: 'query'\n          }\n        }, 'requestId');\n        shape.members._XAMZRequestId = requestIdShape;\n      }\n\n      var data = parser.parse(resp.httpResponse.body.toString(), shape);\n      resp.requestId = data._XAMZRequestId || data.requestId;\n      if (data._XAMZRequestId) delete data._XAMZRequestId;\n\n      if (origRules.resultWrapper) {\n        if (data[origRules.resultWrapper]) {\n          util.update(data, data[origRules.resultWrapper]);\n          delete data[origRules.resultWrapper];\n        }\n      }\n\n      resp.data = data;\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = {\n      buildRequest: buildRequest,\n      extractError: extractError,\n      extractData: extractData\n    };\n  }, {\n    \"../core\": 18,\n    \"../model/shape\": 43,\n    \"../query/query_param_serializer\": 51,\n    \"../util\": 71,\n    \"./helpers\": 45\n  }],\n  48: [function (require, module, exports) {\n    var util = require('../util');\n\n    var populateHostPrefix = require('./helpers').populateHostPrefix;\n\n    function populateMethod(req) {\n      req.httpRequest.method = req.service.api.operations[req.operation].httpMethod;\n    }\n\n    function generateURI(endpointPath, operationPath, input, params) {\n      var uri = [endpointPath, operationPath].join('/');\n      uri = uri.replace(/\\/+/g, '/');\n      var queryString = {},\n          queryStringSet = false;\n      util.each(input.members, function (name, member) {\n        var paramValue = params[name];\n        if (paramValue === null || paramValue === undefined) return;\n\n        if (member.location === 'uri') {\n          var regex = new RegExp('\\\\{' + member.name + '(\\\\+)?\\\\}');\n          uri = uri.replace(regex, function (_, plus) {\n            var fn = plus ? util.uriEscapePath : util.uriEscape;\n            return fn(String(paramValue));\n          });\n        } else if (member.location === 'querystring') {\n          queryStringSet = true;\n\n          if (member.type === 'list') {\n            queryString[member.name] = paramValue.map(function (val) {\n              return util.uriEscape(member.member.toWireFormat(val).toString());\n            });\n          } else if (member.type === 'map') {\n            util.each(paramValue, function (key, value) {\n              if (Array.isArray(value)) {\n                queryString[key] = value.map(function (val) {\n                  return util.uriEscape(String(val));\n                });\n              } else {\n                queryString[key] = util.uriEscape(String(value));\n              }\n            });\n          } else {\n            queryString[member.name] = util.uriEscape(member.toWireFormat(paramValue).toString());\n          }\n        }\n      });\n\n      if (queryStringSet) {\n        uri += uri.indexOf('?') >= 0 ? '&' : '?';\n        var parts = [];\n        util.arrayEach(Object.keys(queryString).sort(), function (key) {\n          if (!Array.isArray(queryString[key])) {\n            queryString[key] = [queryString[key]];\n          }\n\n          for (var i = 0; i < queryString[key].length; i++) {\n            parts.push(util.uriEscape(String(key)) + '=' + queryString[key][i]);\n          }\n        });\n        uri += parts.join('&');\n      }\n\n      return uri;\n    }\n\n    function populateURI(req) {\n      var operation = req.service.api.operations[req.operation];\n      var input = operation.input;\n      var uri = generateURI(req.httpRequest.endpoint.path, operation.httpPath, input, req.params);\n      req.httpRequest.path = uri;\n    }\n\n    function populateHeaders(req) {\n      var operation = req.service.api.operations[req.operation];\n      util.each(operation.input.members, function (name, member) {\n        var value = req.params[name];\n        if (value === null || value === undefined) return;\n\n        if (member.location === 'headers' && member.type === 'map') {\n          util.each(value, function (key, memberValue) {\n            req.httpRequest.headers[member.name + key] = memberValue;\n          });\n        } else if (member.location === 'header') {\n          value = member.toWireFormat(value).toString();\n\n          if (member.isJsonValue) {\n            value = util.base64.encode(value);\n          }\n\n          req.httpRequest.headers[member.name] = value;\n        }\n      });\n    }\n\n    function buildRequest(req) {\n      populateMethod(req);\n      populateURI(req);\n      populateHeaders(req);\n      populateHostPrefix(req);\n    }\n\n    function extractError() {}\n\n    function extractData(resp) {\n      var req = resp.request;\n      var data = {};\n      var r = resp.httpResponse;\n      var operation = req.service.api.operations[req.operation];\n      var output = operation.output; // normalize headers names to lower-cased keys for matching\n\n      var headers = {};\n      util.each(r.headers, function (k, v) {\n        headers[k.toLowerCase()] = v;\n      });\n      util.each(output.members, function (name, member) {\n        var header = (member.name || name).toLowerCase();\n\n        if (member.location === 'headers' && member.type === 'map') {\n          data[name] = {};\n          var location = member.isLocationName ? member.name : '';\n          var pattern = new RegExp('^' + location + '(.+)', 'i');\n          util.each(r.headers, function (k, v) {\n            var result = k.match(pattern);\n\n            if (result !== null) {\n              data[name][result[1]] = v;\n            }\n          });\n        } else if (member.location === 'header') {\n          if (headers[header] !== undefined) {\n            var value = member.isJsonValue ? util.base64.decode(headers[header]) : headers[header];\n            data[name] = member.toType(value);\n          }\n        } else if (member.location === 'statusCode') {\n          data[name] = parseInt(r.statusCode, 10);\n        }\n      });\n      resp.data = data;\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = {\n      buildRequest: buildRequest,\n      extractError: extractError,\n      extractData: extractData,\n      generateURI: generateURI\n    };\n  }, {\n    \"../util\": 71,\n    \"./helpers\": 45\n  }],\n  49: [function (require, module, exports) {\n    var util = require('../util');\n\n    var Rest = require('./rest');\n\n    var Json = require('./json');\n\n    var JsonBuilder = require('../json/builder');\n\n    var JsonParser = require('../json/parser');\n\n    function populateBody(req) {\n      var builder = new JsonBuilder();\n      var input = req.service.api.operations[req.operation].input;\n\n      if (input.payload) {\n        var params = {};\n        var payloadShape = input.members[input.payload];\n        params = req.params[input.payload];\n        if (params === undefined) return;\n\n        if (payloadShape.type === 'structure') {\n          req.httpRequest.body = builder.build(params, payloadShape);\n          applyContentTypeHeader(req);\n        } else {\n          // non-JSON payload\n          req.httpRequest.body = params;\n\n          if (payloadShape.type === 'binary' || payloadShape.isStreaming) {\n            applyContentTypeHeader(req, true);\n          }\n        }\n      } else {\n        var body = builder.build(req.params, input);\n\n        if (body !== '{}' || req.httpRequest.method !== 'GET') {\n          //don't send empty body for GET method\n          req.httpRequest.body = body;\n        }\n\n        applyContentTypeHeader(req);\n      }\n    }\n\n    function applyContentTypeHeader(req, isBinary) {\n      var operation = req.service.api.operations[req.operation];\n      var input = operation.input;\n\n      if (!req.httpRequest.headers['Content-Type']) {\n        var type = isBinary ? 'binary/octet-stream' : 'application/json';\n        req.httpRequest.headers['Content-Type'] = type;\n      }\n    }\n\n    function buildRequest(req) {\n      Rest.buildRequest(req); // never send body payload on HEAD/DELETE\n\n      if (['HEAD', 'DELETE'].indexOf(req.httpRequest.method) < 0) {\n        populateBody(req);\n      }\n    }\n\n    function extractError(resp) {\n      Json.extractError(resp);\n    }\n\n    function extractData(resp) {\n      Rest.extractData(resp);\n      var req = resp.request;\n      var operation = req.service.api.operations[req.operation];\n      var rules = req.service.api.operations[req.operation].output || {};\n      var parser;\n      var hasEventOutput = operation.hasEventOutput;\n\n      if (rules.payload) {\n        var payloadMember = rules.members[rules.payload];\n        var body = resp.httpResponse.body;\n\n        if (payloadMember.isEventStream) {\n          parser = new JsonParser();\n          resp.data[payload] = util.createEventStream(AWS.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : body, parser, payloadMember);\n        } else if (payloadMember.type === 'structure' || payloadMember.type === 'list') {\n          var parser = new JsonParser();\n          resp.data[rules.payload] = parser.parse(body, payloadMember);\n        } else if (payloadMember.type === 'binary' || payloadMember.isStreaming) {\n          resp.data[rules.payload] = body;\n        } else {\n          resp.data[rules.payload] = payloadMember.toType(body);\n        }\n      } else {\n        var data = resp.data;\n        Json.extractData(resp);\n        resp.data = util.merge(data, resp.data);\n      }\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = {\n      buildRequest: buildRequest,\n      extractError: extractError,\n      extractData: extractData\n    };\n  }, {\n    \"../json/builder\": 36,\n    \"../json/parser\": 37,\n    \"../util\": 71,\n    \"./json\": 46,\n    \"./rest\": 48\n  }],\n  50: [function (require, module, exports) {\n    var AWS = require('../core');\n\n    var util = require('../util');\n\n    var Rest = require('./rest');\n\n    function populateBody(req) {\n      var input = req.service.api.operations[req.operation].input;\n      var builder = new AWS.XML.Builder();\n      var params = req.params;\n      var payload = input.payload;\n\n      if (payload) {\n        var payloadMember = input.members[payload];\n        params = params[payload];\n        if (params === undefined) return;\n\n        if (payloadMember.type === 'structure') {\n          var rootElement = payloadMember.name;\n          req.httpRequest.body = builder.toXML(params, payloadMember, rootElement, true);\n        } else {\n          // non-xml payload\n          req.httpRequest.body = params;\n        }\n      } else {\n        req.httpRequest.body = builder.toXML(params, input, input.name || input.shape || util.string.upperFirst(req.operation) + 'Request');\n      }\n    }\n\n    function buildRequest(req) {\n      Rest.buildRequest(req); // never send body payload on GET/HEAD\n\n      if (['GET', 'HEAD'].indexOf(req.httpRequest.method) < 0) {\n        populateBody(req);\n      }\n    }\n\n    function extractError(resp) {\n      Rest.extractError(resp);\n      var data;\n\n      try {\n        data = new AWS.XML.Parser().parse(resp.httpResponse.body.toString());\n      } catch (e) {\n        data = {\n          Code: resp.httpResponse.statusCode,\n          Message: resp.httpResponse.statusMessage\n        };\n      }\n\n      if (data.Errors) data = data.Errors;\n      if (data.Error) data = data.Error;\n\n      if (data.Code) {\n        resp.error = util.error(new Error(), {\n          code: data.Code,\n          message: data.Message\n        });\n      } else {\n        resp.error = util.error(new Error(), {\n          code: resp.httpResponse.statusCode,\n          message: null\n        });\n      }\n    }\n\n    function extractData(resp) {\n      Rest.extractData(resp);\n      var parser;\n      var req = resp.request;\n      var body = resp.httpResponse.body;\n      var operation = req.service.api.operations[req.operation];\n      var output = operation.output;\n      var hasEventOutput = operation.hasEventOutput;\n      var payload = output.payload;\n\n      if (payload) {\n        var payloadMember = output.members[payload];\n\n        if (payloadMember.isEventStream) {\n          parser = new AWS.XML.Parser();\n          resp.data[payload] = util.createEventStream(AWS.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : resp.httpResponse.body, parser, payloadMember);\n        } else if (payloadMember.type === 'structure') {\n          parser = new AWS.XML.Parser();\n          resp.data[payload] = parser.parse(body.toString(), payloadMember);\n        } else if (payloadMember.type === 'binary' || payloadMember.isStreaming) {\n          resp.data[payload] = body;\n        } else {\n          resp.data[payload] = payloadMember.toType(body);\n        }\n      } else if (body.length > 0) {\n        parser = new AWS.XML.Parser();\n        var data = parser.parse(body.toString(), output);\n        util.update(resp.data, data);\n      }\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = {\n      buildRequest: buildRequest,\n      extractError: extractError,\n      extractData: extractData\n    };\n  }, {\n    \"../core\": 18,\n    \"../util\": 71,\n    \"./rest\": 48\n  }],\n  51: [function (require, module, exports) {\n    var util = require('../util');\n\n    function QueryParamSerializer() {}\n\n    QueryParamSerializer.prototype.serialize = function (params, shape, fn) {\n      serializeStructure('', params, shape, fn);\n    };\n\n    function ucfirst(shape) {\n      if (shape.isQueryName || shape.api.protocol !== 'ec2') {\n        return shape.name;\n      } else {\n        return shape.name[0].toUpperCase() + shape.name.substr(1);\n      }\n    }\n\n    function serializeStructure(prefix, struct, rules, fn) {\n      util.each(rules.members, function (name, member) {\n        var value = struct[name];\n        if (value === null || value === undefined) return;\n        var memberName = ucfirst(member);\n        memberName = prefix ? prefix + '.' + memberName : memberName;\n        serializeMember(memberName, value, member, fn);\n      });\n    }\n\n    function serializeMap(name, map, rules, fn) {\n      var i = 1;\n      util.each(map, function (key, value) {\n        var prefix = rules.flattened ? '.' : '.entry.';\n        var position = prefix + i++ + '.';\n        var keyName = position + (rules.key.name || 'key');\n        var valueName = position + (rules.value.name || 'value');\n        serializeMember(name + keyName, key, rules.key, fn);\n        serializeMember(name + valueName, value, rules.value, fn);\n      });\n    }\n\n    function serializeList(name, list, rules, fn) {\n      var memberRules = rules.member || {};\n\n      if (list.length === 0) {\n        fn.call(this, name, null);\n        return;\n      }\n\n      util.arrayEach(list, function (v, n) {\n        var suffix = '.' + (n + 1);\n\n        if (rules.api.protocol === 'ec2') {\n          // Do nothing for EC2\n          suffix = suffix + ''; // make linter happy\n        } else if (rules.flattened) {\n          if (memberRules.name) {\n            var parts = name.split('.');\n            parts.pop();\n            parts.push(ucfirst(memberRules));\n            name = parts.join('.');\n          }\n        } else {\n          suffix = '.' + (memberRules.name ? memberRules.name : 'member') + suffix;\n        }\n\n        serializeMember(name + suffix, v, memberRules, fn);\n      });\n    }\n\n    function serializeMember(name, value, rules, fn) {\n      if (value === null || value === undefined) return;\n\n      if (rules.type === 'structure') {\n        serializeStructure(name, value, rules, fn);\n      } else if (rules.type === 'list') {\n        serializeList(name, value, rules, fn);\n      } else if (rules.type === 'map') {\n        serializeMap(name, value, rules, fn);\n      } else {\n        fn(name, rules.toWireFormat(value).toString());\n      }\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = QueryParamSerializer;\n  }, {\n    \"../util\": 71\n  }],\n  52: [function (require, module, exports) {\n    module.exports = {\n      //provide realtime clock for performance measurement\n      now: function now() {\n        if (typeof performance !== 'undefined' && typeof performance.now === 'function') {\n          return performance.now();\n        }\n\n        return Date.now();\n      }\n    };\n  }, {}],\n  53: [function (require, module, exports) {\n    var util = require('./util');\n\n    var regionConfig = require('./region_config_data.json');\n\n    function generateRegionPrefix(region) {\n      if (!region) return null;\n      var parts = region.split('-');\n      if (parts.length < 3) return null;\n      return parts.slice(0, parts.length - 2).join('-') + '-*';\n    }\n\n    function derivedKeys(service) {\n      var region = service.config.region;\n      var regionPrefix = generateRegionPrefix(region);\n      var endpointPrefix = service.api.endpointPrefix;\n      return [[region, endpointPrefix], [regionPrefix, endpointPrefix], [region, '*'], [regionPrefix, '*'], ['*', endpointPrefix], ['*', '*']].map(function (item) {\n        return item[0] && item[1] ? item.join('/') : null;\n      });\n    }\n\n    function applyConfig(service, config) {\n      util.each(config, function (key, value) {\n        if (key === 'globalEndpoint') return;\n\n        if (service.config[key] === undefined || service.config[key] === null) {\n          service.config[key] = value;\n        }\n      });\n    }\n\n    function configureEndpoint(service) {\n      var keys = derivedKeys(service);\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        if (!key) continue;\n\n        if (Object.prototype.hasOwnProperty.call(regionConfig.rules, key)) {\n          var config = regionConfig.rules[key];\n\n          if (typeof config === 'string') {\n            config = regionConfig.patterns[config];\n          } // set dualstack endpoint\n\n\n          if (service.config.useDualstack && util.isDualstackAvailable(service)) {\n            config = util.copy(config);\n            config.endpoint = '{service}.dualstack.{region}.amazonaws.com';\n          } // set global endpoint\n\n\n          service.isGlobalEndpoint = !!config.globalEndpoint; // signature version\n\n          if (!config.signatureVersion) config.signatureVersion = 'v4'; // merge config\n\n          applyConfig(service, config);\n          return;\n        }\n      }\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = configureEndpoint;\n  }, {\n    \"./region_config_data.json\": 54,\n    \"./util\": 71\n  }],\n  54: [function (require, module, exports) {\n    module.exports = {\n      \"rules\": {\n        \"*/*\": {\n          \"endpoint\": \"{service}.{region}.amazonaws.com\"\n        },\n        \"cn-*/*\": {\n          \"endpoint\": \"{service}.{region}.amazonaws.com.cn\"\n        },\n        \"*/budgets\": \"globalSSL\",\n        \"*/cloudfront\": \"globalSSL\",\n        \"*/iam\": \"globalSSL\",\n        \"*/sts\": \"globalSSL\",\n        \"*/importexport\": {\n          \"endpoint\": \"{service}.amazonaws.com\",\n          \"signatureVersion\": \"v2\",\n          \"globalEndpoint\": true\n        },\n        \"*/route53\": {\n          \"endpoint\": \"https://{service}.amazonaws.com\",\n          \"signatureVersion\": \"v3https\",\n          \"globalEndpoint\": true\n        },\n        \"*/waf\": \"globalSSL\",\n        \"us-gov-*/iam\": \"globalGovCloud\",\n        \"us-gov-*/sts\": {\n          \"endpoint\": \"{service}.{region}.amazonaws.com\"\n        },\n        \"us-gov-west-1/s3\": \"s3signature\",\n        \"us-west-1/s3\": \"s3signature\",\n        \"us-west-2/s3\": \"s3signature\",\n        \"eu-west-1/s3\": \"s3signature\",\n        \"ap-southeast-1/s3\": \"s3signature\",\n        \"ap-southeast-2/s3\": \"s3signature\",\n        \"ap-northeast-1/s3\": \"s3signature\",\n        \"sa-east-1/s3\": \"s3signature\",\n        \"us-east-1/s3\": {\n          \"endpoint\": \"{service}.amazonaws.com\",\n          \"signatureVersion\": \"s3\"\n        },\n        \"us-east-1/sdb\": {\n          \"endpoint\": \"{service}.amazonaws.com\",\n          \"signatureVersion\": \"v2\"\n        },\n        \"*/sdb\": {\n          \"endpoint\": \"{service}.{region}.amazonaws.com\",\n          \"signatureVersion\": \"v2\"\n        }\n      },\n      \"patterns\": {\n        \"globalSSL\": {\n          \"endpoint\": \"https://{service}.amazonaws.com\",\n          \"globalEndpoint\": true\n        },\n        \"globalGovCloud\": {\n          \"endpoint\": \"{service}.us-gov.amazonaws.com\"\n        },\n        \"s3signature\": {\n          \"endpoint\": \"{service}.{region}.amazonaws.com\",\n          \"signatureVersion\": \"s3\"\n        }\n      }\n    };\n  }, {}],\n  55: [function (require, module, exports) {\n    (function (process) {\n      (function () {\n        var AWS = require('./core');\n\n        var AcceptorStateMachine = require('./state_machine');\n\n        var inherit = AWS.util.inherit;\n        var domain = AWS.util.domain;\n\n        var jmespath = require('jmespath');\n        /**\n         * @api private\n         */\n\n\n        var hardErrorStates = {\n          success: 1,\n          error: 1,\n          complete: 1\n        };\n\n        function isTerminalState(machine) {\n          return Object.prototype.hasOwnProperty.call(hardErrorStates, machine._asm.currentState);\n        }\n\n        var fsm = new AcceptorStateMachine();\n\n        fsm.setupStates = function () {\n          var transition = function (_, done) {\n            var self = this;\n            self._haltHandlersOnError = false;\n            self.emit(self._asm.currentState, function (err) {\n              if (err) {\n                if (isTerminalState(self)) {\n                  if (domain && self.domain instanceof domain.Domain) {\n                    err.domainEmitter = self;\n                    err.domain = self.domain;\n                    err.domainThrown = false;\n                    self.domain.emit('error', err);\n                  } else {\n                    throw err;\n                  }\n                } else {\n                  self.response.error = err;\n                  done(err);\n                }\n              } else {\n                done(self.response.error);\n              }\n            });\n          };\n\n          this.addState('validate', 'build', 'error', transition);\n          this.addState('build', 'afterBuild', 'restart', transition);\n          this.addState('afterBuild', 'sign', 'restart', transition);\n          this.addState('sign', 'send', 'retry', transition);\n          this.addState('retry', 'afterRetry', 'afterRetry', transition);\n          this.addState('afterRetry', 'sign', 'error', transition);\n          this.addState('send', 'validateResponse', 'retry', transition);\n          this.addState('validateResponse', 'extractData', 'extractError', transition);\n          this.addState('extractError', 'extractData', 'retry', transition);\n          this.addState('extractData', 'success', 'retry', transition);\n          this.addState('restart', 'build', 'error', transition);\n          this.addState('success', 'complete', 'complete', transition);\n          this.addState('error', 'complete', 'complete', transition);\n          this.addState('complete', null, null, transition);\n        };\n\n        fsm.setupStates();\n        /**\n         * ## Asynchronous Requests\n         *\n         * All requests made through the SDK are asynchronous and use a\n         * callback interface. Each service method that kicks off a request\n         * returns an `AWS.Request` object that you can use to register\n         * callbacks.\n         *\n         * For example, the following service method returns the request\n         * object as \"request\", which can be used to register callbacks:\n         *\n         * ```javascript\n         * // request is an AWS.Request object\n         * var request = ec2.describeInstances();\n         *\n         * // register callbacks on request to retrieve response data\n         * request.on('success', function(response) {\n         *   console.log(response.data);\n         * });\n         * ```\n         *\n         * When a request is ready to be sent, the {send} method should\n         * be called:\n         *\n         * ```javascript\n         * request.send();\n         * ```\n         *\n         * Since registered callbacks may or may not be idempotent, requests should only\n         * be sent once. To perform the same operation multiple times, you will need to\n         * create multiple request objects, each with its own registered callbacks.\n         *\n         * ## Removing Default Listeners for Events\n         *\n         * Request objects are built with default listeners for the various events,\n         * depending on the service type. In some cases, you may want to remove\n         * some built-in listeners to customize behaviour. Doing this requires\n         * access to the built-in listener functions, which are exposed through\n         * the {AWS.EventListeners.Core} namespace. For instance, you may\n         * want to customize the HTTP handler used when sending a request. In this\n         * case, you can remove the built-in listener associated with the 'send'\n         * event, the {AWS.EventListeners.Core.SEND} listener and add your own.\n         *\n         * ## Multiple Callbacks and Chaining\n         *\n         * You can register multiple callbacks on any request object. The\n         * callbacks can be registered for different events, or all for the\n         * same event. In addition, you can chain callback registration, for\n         * example:\n         *\n         * ```javascript\n         * request.\n         *   on('success', function(response) {\n         *     console.log(\"Success!\");\n         *   }).\n         *   on('error', function(error, response) {\n         *     console.log(\"Error!\");\n         *   }).\n         *   on('complete', function(response) {\n         *     console.log(\"Always!\");\n         *   }).\n         *   send();\n         * ```\n         *\n         * The above example will print either \"Success! Always!\", or \"Error! Always!\",\n         * depending on whether the request succeeded or not.\n         *\n         * @!attribute httpRequest\n         *   @readonly\n         *   @!group HTTP Properties\n         *   @return [AWS.HttpRequest] the raw HTTP request object\n         *     containing request headers and body information\n         *     sent by the service.\n         *\n         * @!attribute startTime\n         *   @readonly\n         *   @!group Operation Properties\n         *   @return [Date] the time that the request started\n         *\n         * @!group Request Building Events\n         *\n         * @!event validate(request)\n         *   Triggered when a request is being validated. Listeners\n         *   should throw an error if the request should not be sent.\n         *   @param request [Request] the request object being sent\n         *   @see AWS.EventListeners.Core.VALIDATE_CREDENTIALS\n         *   @see AWS.EventListeners.Core.VALIDATE_REGION\n         *   @example Ensuring that a certain parameter is set before sending a request\n         *     var req = s3.putObject(params);\n         *     req.on('validate', function() {\n         *       if (!req.params.Body.match(/^Hello\\s/)) {\n         *         throw new Error('Body must start with \"Hello \"');\n         *       }\n         *     });\n         *     req.send(function(err, data) { ... });\n         *\n         * @!event build(request)\n         *   Triggered when the request payload is being built. Listeners\n         *   should fill the necessary information to send the request\n         *   over HTTP.\n         *   @param (see AWS.Request~validate)\n         *   @example Add a custom HTTP header to a request\n         *     var req = s3.putObject(params);\n         *     req.on('build', function() {\n         *       req.httpRequest.headers['Custom-Header'] = 'value';\n         *     });\n         *     req.send(function(err, data) { ... });\n         *\n         * @!event sign(request)\n         *   Triggered when the request is being signed. Listeners should\n         *   add the correct authentication headers and/or adjust the body,\n         *   depending on the authentication mechanism being used.\n         *   @param (see AWS.Request~validate)\n         *\n         * @!group Request Sending Events\n         *\n         * @!event send(response)\n         *   Triggered when the request is ready to be sent. Listeners\n         *   should call the underlying transport layer to initiate\n         *   the sending of the request.\n         *   @param response [Response] the response object\n         *   @context [Request] the request object that was sent\n         *   @see AWS.EventListeners.Core.SEND\n         *\n         * @!event retry(response)\n         *   Triggered when a request failed and might need to be retried or redirected.\n         *   If the response is retryable, the listener should set the\n         *   `response.error.retryable` property to `true`, and optionally set\n         *   `response.error.retryDelay` to the millisecond delay for the next attempt.\n         *   In the case of a redirect, `response.error.redirect` should be set to\n         *   `true` with `retryDelay` set to an optional delay on the next request.\n         *\n         *   If a listener decides that a request should not be retried,\n         *   it should set both `retryable` and `redirect` to false.\n         *\n         *   Note that a retryable error will be retried at most\n         *   {AWS.Config.maxRetries} times (based on the service object's config).\n         *   Similarly, a request that is redirected will only redirect at most\n         *   {AWS.Config.maxRedirects} times.\n         *\n         *   @param (see AWS.Request~send)\n         *   @context (see AWS.Request~send)\n         *   @example Adding a custom retry for a 404 response\n         *     request.on('retry', function(response) {\n         *       // this resource is not yet available, wait 10 seconds to get it again\n         *       if (response.httpResponse.statusCode === 404 && response.error) {\n         *         response.error.retryable = true;   // retry this error\n         *         response.error.retryDelay = 10000; // wait 10 seconds\n         *       }\n         *     });\n         *\n         * @!group Data Parsing Events\n         *\n         * @!event extractError(response)\n         *   Triggered on all non-2xx requests so that listeners can extract\n         *   error details from the response body. Listeners to this event\n         *   should set the `response.error` property.\n         *   @param (see AWS.Request~send)\n         *   @context (see AWS.Request~send)\n         *\n         * @!event extractData(response)\n         *   Triggered in successful requests to allow listeners to\n         *   de-serialize the response body into `response.data`.\n         *   @param (see AWS.Request~send)\n         *   @context (see AWS.Request~send)\n         *\n         * @!group Completion Events\n         *\n         * @!event success(response)\n         *   Triggered when the request completed successfully.\n         *   `response.data` will contain the response data and\n         *   `response.error` will be null.\n         *   @param (see AWS.Request~send)\n         *   @context (see AWS.Request~send)\n         *\n         * @!event error(error, response)\n         *   Triggered when an error occurs at any point during the\n         *   request. `response.error` will contain details about the error\n         *   that occurred. `response.data` will be null.\n         *   @param error [Error] the error object containing details about\n         *     the error that occurred.\n         *   @param (see AWS.Request~send)\n         *   @context (see AWS.Request~send)\n         *\n         * @!event complete(response)\n         *   Triggered whenever a request cycle completes. `response.error`\n         *   should be checked, since the request may have failed.\n         *   @param (see AWS.Request~send)\n         *   @context (see AWS.Request~send)\n         *\n         * @!group HTTP Events\n         *\n         * @!event httpHeaders(statusCode, headers, response, statusMessage)\n         *   Triggered when headers are sent by the remote server\n         *   @param statusCode [Integer] the HTTP response code\n         *   @param headers [map<String,String>] the response headers\n         *   @param (see AWS.Request~send)\n         *   @param statusMessage [String] A status message corresponding to the HTTP\n         *                                 response code\n         *   @context (see AWS.Request~send)\n         *\n         * @!event httpData(chunk, response)\n         *   Triggered when data is sent by the remote server\n         *   @param chunk [Buffer] the buffer data containing the next data chunk\n         *     from the server\n         *   @param (see AWS.Request~send)\n         *   @context (see AWS.Request~send)\n         *   @see AWS.EventListeners.Core.HTTP_DATA\n         *\n         * @!event httpUploadProgress(progress, response)\n         *   Triggered when the HTTP request has uploaded more data\n         *   @param progress [map] An object containing the `loaded` and `total` bytes\n         *     of the request.\n         *   @param (see AWS.Request~send)\n         *   @context (see AWS.Request~send)\n         *   @note This event will not be emitted in Node.js 0.8.x.\n         *\n         * @!event httpDownloadProgress(progress, response)\n         *   Triggered when the HTTP request has downloaded more data\n         *   @param progress [map] An object containing the `loaded` and `total` bytes\n         *     of the request.\n         *   @param (see AWS.Request~send)\n         *   @context (see AWS.Request~send)\n         *   @note This event will not be emitted in Node.js 0.8.x.\n         *\n         * @!event httpError(error, response)\n         *   Triggered when the HTTP request failed\n         *   @param error [Error] the error object that was thrown\n         *   @param (see AWS.Request~send)\n         *   @context (see AWS.Request~send)\n         *\n         * @!event httpDone(response)\n         *   Triggered when the server is finished sending data\n         *   @param (see AWS.Request~send)\n         *   @context (see AWS.Request~send)\n         *\n         * @see AWS.Response\n         */\n\n        AWS.Request = inherit({\n          /**\n           * Creates a request for an operation on a given service with\n           * a set of input parameters.\n           *\n           * @param service [AWS.Service] the service to perform the operation on\n           * @param operation [String] the operation to perform on the service\n           * @param params [Object] parameters to send to the operation.\n           *   See the operation's documentation for the format of the\n           *   parameters.\n           */\n          constructor: function Request(service, operation, params) {\n            var endpoint = service.endpoint;\n            var region = service.config.region;\n            var customUserAgent = service.config.customUserAgent; // global endpoints sign as us-east-1\n\n            if (service.isGlobalEndpoint) region = 'us-east-1';\n            this.domain = domain && domain.active;\n            this.service = service;\n            this.operation = operation;\n            this.params = params || {};\n            this.httpRequest = new AWS.HttpRequest(endpoint, region);\n            this.httpRequest.appendToUserAgent(customUserAgent);\n            this.startTime = service.getSkewCorrectedDate();\n            this.response = new AWS.Response(this);\n            this._asm = new AcceptorStateMachine(fsm.states, 'validate');\n            this._haltHandlersOnError = false;\n            AWS.SequentialExecutor.call(this);\n            this.emit = this.emitEvent;\n          },\n\n          /**\n           * @!group Sending a Request\n           */\n\n          /**\n           * @overload send(callback = null)\n           *   Sends the request object.\n           *\n           *   @callback callback function(err, data)\n           *     If a callback is supplied, it is called when a response is returned\n           *     from the service.\n           *     @context [AWS.Request] the request object being sent.\n           *     @param err [Error] the error object returned from the request.\n           *       Set to `null` if the request is successful.\n           *     @param data [Object] the de-serialized data returned from\n           *       the request. Set to `null` if a request error occurs.\n           *   @example Sending a request with a callback\n           *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});\n           *     request.send(function(err, data) { console.log(err, data); });\n           *   @example Sending a request with no callback (using event handlers)\n           *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});\n           *     request.on('complete', function(response) { ... }); // register a callback\n           *     request.send();\n           */\n          send: function send(callback) {\n            if (callback) {\n              // append to user agent\n              this.httpRequest.appendToUserAgent('callback');\n              this.on('complete', function (resp) {\n                callback.call(resp, resp.error, resp.data);\n              });\n            }\n\n            this.runTo();\n            return this.response;\n          },\n\n          /**\n           * @!method  promise()\n           *   Sends the request and returns a 'thenable' promise.\n           *\n           *   Two callbacks can be provided to the `then` method on the returned promise.\n           *   The first callback will be called if the promise is fulfilled, and the second\n           *   callback will be called if the promise is rejected.\n           *   @callback fulfilledCallback function(data)\n           *     Called if the promise is fulfilled.\n           *     @param data [Object] the de-serialized data returned from the request.\n           *   @callback rejectedCallback function(error)\n           *     Called if the promise is rejected.\n           *     @param error [Error] the error object returned from the request.\n           *   @return [Promise] A promise that represents the state of the request.\n           *   @example Sending a request using promises.\n           *     var request = s3.putObject({Bucket: 'bucket', Key: 'key'});\n           *     var result = request.promise();\n           *     result.then(function(data) { ... }, function(error) { ... });\n           */\n\n          /**\n           * @api private\n           */\n          build: function build(callback) {\n            return this.runTo('send', callback);\n          },\n\n          /**\n           * @api private\n           */\n          runTo: function runTo(state, done) {\n            this._asm.runTo(state, done, this);\n\n            return this;\n          },\n\n          /**\n           * Aborts a request, emitting the error and complete events.\n           *\n           * @!macro nobrowser\n           * @example Aborting a request after sending\n           *   var params = {\n           *     Bucket: 'bucket', Key: 'key',\n           *     Body: Buffer.alloc(1024 * 1024 * 5) // 5MB payload\n           *   };\n           *   var request = s3.putObject(params);\n           *   request.send(function (err, data) {\n           *     if (err) console.log(\"Error:\", err.code, err.message);\n           *     else console.log(data);\n           *   });\n           *\n           *   // abort request in 1 second\n           *   setTimeout(request.abort.bind(request), 1000);\n           *\n           *   // prints \"Error: RequestAbortedError Request aborted by user\"\n           * @return [AWS.Request] the same request object, for chaining.\n           * @since v1.4.0\n           */\n          abort: function abort() {\n            this.removeAllListeners('validateResponse');\n            this.removeAllListeners('extractError');\n            this.on('validateResponse', function addAbortedError(resp) {\n              resp.error = AWS.util.error(new Error('Request aborted by user'), {\n                code: 'RequestAbortedError',\n                retryable: false\n              });\n            });\n\n            if (this.httpRequest.stream && !this.httpRequest.stream.didCallback) {\n              // abort HTTP stream\n              this.httpRequest.stream.abort();\n\n              if (this.httpRequest._abortCallback) {\n                this.httpRequest._abortCallback();\n              } else {\n                this.removeAllListeners('send'); // haven't sent yet, so let's not\n              }\n            }\n\n            return this;\n          },\n\n          /**\n           * Iterates over each page of results given a pageable request, calling\n           * the provided callback with each page of data. After all pages have been\n           * retrieved, the callback is called with `null` data.\n           *\n           * @note This operation can generate multiple requests to a service.\n           * @example Iterating over multiple pages of objects in an S3 bucket\n           *   var pages = 1;\n           *   s3.listObjects().eachPage(function(err, data) {\n           *     if (err) return;\n           *     console.log(\"Page\", pages++);\n           *     console.log(data);\n           *   });\n           * @example Iterating over multiple pages with an asynchronous callback\n           *   s3.listObjects(params).eachPage(function(err, data, done) {\n           *     doSomethingAsyncAndOrExpensive(function() {\n           *       // The next page of results isn't fetched until done is called\n           *       done();\n           *     });\n           *   });\n           * @callback callback function(err, data, [doneCallback])\n           *   Called with each page of resulting data from the request. If the\n           *   optional `doneCallback` is provided in the function, it must be called\n           *   when the callback is complete.\n           *\n           *   @param err [Error] an error object, if an error occurred.\n           *   @param data [Object] a single page of response data. If there is no\n           *     more data, this object will be `null`.\n           *   @param doneCallback [Function] an optional done callback. If this\n           *     argument is defined in the function declaration, it should be called\n           *     when the next page is ready to be retrieved. This is useful for\n           *     controlling serial pagination across asynchronous operations.\n           *   @return [Boolean] if the callback returns `false`, pagination will\n           *     stop.\n           *\n           * @see AWS.Request.eachItem\n           * @see AWS.Response.nextPage\n           * @since v1.4.0\n           */\n          eachPage: function eachPage(callback) {\n            // Make all callbacks async-ish\n            callback = AWS.util.fn.makeAsync(callback, 3);\n\n            function wrappedCallback(response) {\n              callback.call(response, response.error, response.data, function (result) {\n                if (result === false) return;\n\n                if (response.hasNextPage()) {\n                  response.nextPage().on('complete', wrappedCallback).send();\n                } else {\n                  callback.call(response, null, null, AWS.util.fn.noop);\n                }\n              });\n            }\n\n            this.on('complete', wrappedCallback).send();\n          },\n\n          /**\n           * Enumerates over individual items of a request, paging the responses if\n           * necessary.\n           *\n           * @api experimental\n           * @since v1.4.0\n           */\n          eachItem: function eachItem(callback) {\n            var self = this;\n\n            function wrappedCallback(err, data) {\n              if (err) return callback(err, null);\n              if (data === null) return callback(null, null);\n              var config = self.service.paginationConfig(self.operation);\n              var resultKey = config.resultKey;\n              if (Array.isArray(resultKey)) resultKey = resultKey[0];\n              var items = jmespath.search(data, resultKey);\n              var continueIteration = true;\n              AWS.util.arrayEach(items, function (item) {\n                continueIteration = callback(null, item);\n\n                if (continueIteration === false) {\n                  return AWS.util.abort;\n                }\n              });\n              return continueIteration;\n            }\n\n            this.eachPage(wrappedCallback);\n          },\n\n          /**\n           * @return [Boolean] whether the operation can return multiple pages of\n           *   response data.\n           * @see AWS.Response.eachPage\n           * @since v1.4.0\n           */\n          isPageable: function isPageable() {\n            return this.service.paginationConfig(this.operation) ? true : false;\n          },\n\n          /**\n           * Sends the request and converts the request object into a readable stream\n           * that can be read from or piped into a writable stream.\n           *\n           * @note The data read from a readable stream contains only\n           *   the raw HTTP body contents.\n           * @example Manually reading from a stream\n           *   request.createReadStream().on('data', function(data) {\n           *     console.log(\"Got data:\", data.toString());\n           *   });\n           * @example Piping a request body into a file\n           *   var out = fs.createWriteStream('/path/to/outfile.jpg');\n           *   s3.service.getObject(params).createReadStream().pipe(out);\n           * @return [Stream] the readable stream object that can be piped\n           *   or read from (by registering 'data' event listeners).\n           * @!macro nobrowser\n           */\n          createReadStream: function createReadStream() {\n            var streams = AWS.util.stream;\n            var req = this;\n            var stream = null;\n\n            if (AWS.HttpClient.streamsApiVersion === 2) {\n              stream = new streams.PassThrough();\n              process.nextTick(function () {\n                req.send();\n              });\n            } else {\n              stream = new streams.Stream();\n              stream.readable = true;\n              stream.sent = false;\n              stream.on('newListener', function (event) {\n                if (!stream.sent && event === 'data') {\n                  stream.sent = true;\n                  process.nextTick(function () {\n                    req.send();\n                  });\n                }\n              });\n            }\n\n            this.on('error', function (err) {\n              stream.emit('error', err);\n            });\n            this.on('httpHeaders', function streamHeaders(statusCode, headers, resp) {\n              if (statusCode < 300) {\n                req.removeListener('httpData', AWS.EventListeners.Core.HTTP_DATA);\n                req.removeListener('httpError', AWS.EventListeners.Core.HTTP_ERROR);\n                req.on('httpError', function streamHttpError(error) {\n                  resp.error = error;\n                  resp.error.retryable = false;\n                });\n                var shouldCheckContentLength = false;\n                var expectedLen;\n\n                if (req.httpRequest.method !== 'HEAD') {\n                  expectedLen = parseInt(headers['content-length'], 10);\n                }\n\n                if (expectedLen !== undefined && !isNaN(expectedLen) && expectedLen >= 0) {\n                  shouldCheckContentLength = true;\n                  var receivedLen = 0;\n                }\n\n                var checkContentLengthAndEmit = function checkContentLengthAndEmit() {\n                  if (shouldCheckContentLength && receivedLen !== expectedLen) {\n                    stream.emit('error', AWS.util.error(new Error('Stream content length mismatch. Received ' + receivedLen + ' of ' + expectedLen + ' bytes.'), {\n                      code: 'StreamContentLengthMismatch'\n                    }));\n                  } else if (AWS.HttpClient.streamsApiVersion === 2) {\n                    stream.end();\n                  } else {\n                    stream.emit('end');\n                  }\n                };\n\n                var httpStream = resp.httpResponse.createUnbufferedStream();\n\n                if (AWS.HttpClient.streamsApiVersion === 2) {\n                  if (shouldCheckContentLength) {\n                    var lengthAccumulator = new streams.PassThrough();\n\n                    lengthAccumulator._write = function (chunk) {\n                      if (chunk && chunk.length) {\n                        receivedLen += chunk.length;\n                      }\n\n                      return streams.PassThrough.prototype._write.apply(this, arguments);\n                    };\n\n                    lengthAccumulator.on('end', checkContentLengthAndEmit);\n                    stream.on('error', function (err) {\n                      shouldCheckContentLength = false;\n                      httpStream.unpipe(lengthAccumulator);\n                      lengthAccumulator.emit('end');\n                      lengthAccumulator.end();\n                    });\n                    httpStream.pipe(lengthAccumulator).pipe(stream, {\n                      end: false\n                    });\n                  } else {\n                    httpStream.pipe(stream);\n                  }\n                } else {\n                  if (shouldCheckContentLength) {\n                    httpStream.on('data', function (arg) {\n                      if (arg && arg.length) {\n                        receivedLen += arg.length;\n                      }\n                    });\n                  }\n\n                  httpStream.on('data', function (arg) {\n                    stream.emit('data', arg);\n                  });\n                  httpStream.on('end', checkContentLengthAndEmit);\n                }\n\n                httpStream.on('error', function (err) {\n                  shouldCheckContentLength = false;\n                  stream.emit('error', err);\n                });\n              }\n            });\n            return stream;\n          },\n\n          /**\n           * @param [Array,Response] args This should be the response object,\n           *   or an array of args to send to the event.\n           * @api private\n           */\n          emitEvent: function emit(eventName, args, done) {\n            if (typeof args === 'function') {\n              done = args;\n              args = null;\n            }\n\n            if (!done) done = function () {};\n            if (!args) args = this.eventParameters(eventName, this.response);\n            var origEmit = AWS.SequentialExecutor.prototype.emit;\n            origEmit.call(this, eventName, args, function (err) {\n              if (err) this.response.error = err;\n              done.call(this, err);\n            });\n          },\n\n          /**\n           * @api private\n           */\n          eventParameters: function eventParameters(eventName) {\n            switch (eventName) {\n              case 'restart':\n              case 'validate':\n              case 'sign':\n              case 'build':\n              case 'afterValidate':\n              case 'afterBuild':\n                return [this];\n\n              case 'error':\n                return [this.response.error, this.response];\n\n              default:\n                return [this.response];\n            }\n          },\n\n          /**\n           * @api private\n           */\n          presign: function presign(expires, callback) {\n            if (!callback && typeof expires === 'function') {\n              callback = expires;\n              expires = null;\n            }\n\n            return new AWS.Signers.Presign().sign(this.toGet(), expires, callback);\n          },\n\n          /**\n           * @api private\n           */\n          isPresigned: function isPresigned() {\n            return Object.prototype.hasOwnProperty.call(this.httpRequest.headers, 'presigned-expires');\n          },\n\n          /**\n           * @api private\n           */\n          toUnauthenticated: function toUnauthenticated() {\n            this._unAuthenticated = true;\n            this.removeListener('validate', AWS.EventListeners.Core.VALIDATE_CREDENTIALS);\n            this.removeListener('sign', AWS.EventListeners.Core.SIGN);\n            return this;\n          },\n\n          /**\n           * @api private\n           */\n          toGet: function toGet() {\n            if (this.service.api.protocol === 'query' || this.service.api.protocol === 'ec2') {\n              this.removeListener('build', this.buildAsGet);\n              this.addListener('build', this.buildAsGet);\n            }\n\n            return this;\n          },\n\n          /**\n           * @api private\n           */\n          buildAsGet: function buildAsGet(request) {\n            request.httpRequest.method = 'GET';\n            request.httpRequest.path = request.service.endpoint.path + '?' + request.httpRequest.body;\n            request.httpRequest.body = ''; // don't need these headers on a GET request\n\n            delete request.httpRequest.headers['Content-Length'];\n            delete request.httpRequest.headers['Content-Type'];\n          },\n\n          /**\n           * @api private\n           */\n          haltHandlersOnError: function haltHandlersOnError() {\n            this._haltHandlersOnError = true;\n          }\n        });\n        /**\n         * @api private\n         */\n\n        AWS.Request.addPromisesToClass = function addPromisesToClass(PromiseDependency) {\n          this.prototype.promise = function promise() {\n            var self = this; // append to user agent\n\n            this.httpRequest.appendToUserAgent('promise');\n            return new PromiseDependency(function (resolve, reject) {\n              self.on('complete', function (resp) {\n                if (resp.error) {\n                  reject(resp.error);\n                } else {\n                  // define $response property so that it is not enumberable\n                  // this prevents circular reference errors when stringifying the JSON object\n                  resolve(Object.defineProperty(resp.data || {}, '$response', {\n                    value: resp\n                  }));\n                }\n              });\n              self.runTo();\n            });\n          };\n        };\n        /**\n         * @api private\n         */\n\n\n        AWS.Request.deletePromisesFromClass = function deletePromisesFromClass() {\n          delete this.prototype.promise;\n        };\n\n        AWS.util.addPromises(AWS.Request);\n        AWS.util.mixin(AWS.Request, AWS.SequentialExecutor);\n      }).call(this);\n    }).call(this, require('_process'));\n  }, {\n    \"./core\": 18,\n    \"./state_machine\": 70,\n    \"_process\": 86,\n    \"jmespath\": 85\n  }],\n  56: [function (require, module, exports) {\n    /**\n     * Copyright 2012-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\"). You\n     * may not use this file except in compliance with the License. A copy of\n     * the License is located at\n     *\n     *     http://aws.amazon.com/apache2.0/\n     *\n     * or in the \"license\" file accompanying this file. This file is\n     * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n     * ANY KIND, either express or implied. See the License for the specific\n     * language governing permissions and limitations under the License.\n     */\n    var AWS = require('./core');\n\n    var inherit = AWS.util.inherit;\n\n    var jmespath = require('jmespath');\n    /**\n     * @api private\n     */\n\n\n    function CHECK_ACCEPTORS(resp) {\n      var waiter = resp.request._waiter;\n      var acceptors = waiter.config.acceptors;\n      var acceptorMatched = false;\n      var state = 'retry';\n      acceptors.forEach(function (acceptor) {\n        if (!acceptorMatched) {\n          var matcher = waiter.matchers[acceptor.matcher];\n\n          if (matcher && matcher(resp, acceptor.expected, acceptor.argument)) {\n            acceptorMatched = true;\n            state = acceptor.state;\n          }\n        }\n      });\n      if (!acceptorMatched && resp.error) state = 'failure';\n\n      if (state === 'success') {\n        waiter.setSuccess(resp);\n      } else {\n        waiter.setError(resp, state === 'retry');\n      }\n    }\n    /**\n     * @api private\n     */\n\n\n    AWS.ResourceWaiter = inherit({\n      /**\n       * Waits for a given state on a service object\n       * @param service [Service] the service object to wait on\n       * @param state [String] the state (defined in waiter configuration) to wait\n       *   for.\n       * @example Create a waiter for running EC2 instances\n       *   var ec2 = new AWS.EC2;\n       *   var waiter = new AWS.ResourceWaiter(ec2, 'instanceRunning');\n       */\n      constructor: function constructor(service, state) {\n        this.service = service;\n        this.state = state;\n        this.loadWaiterConfig(this.state);\n      },\n      service: null,\n      state: null,\n      config: null,\n      matchers: {\n        path: function (resp, expected, argument) {\n          try {\n            var result = jmespath.search(resp.data, argument);\n          } catch (err) {\n            return false;\n          }\n\n          return jmespath.strictDeepEqual(result, expected);\n        },\n        pathAll: function (resp, expected, argument) {\n          try {\n            var results = jmespath.search(resp.data, argument);\n          } catch (err) {\n            return false;\n          }\n\n          if (!Array.isArray(results)) results = [results];\n          var numResults = results.length;\n          if (!numResults) return false;\n\n          for (var ind = 0; ind < numResults; ind++) {\n            if (!jmespath.strictDeepEqual(results[ind], expected)) {\n              return false;\n            }\n          }\n\n          return true;\n        },\n        pathAny: function (resp, expected, argument) {\n          try {\n            var results = jmespath.search(resp.data, argument);\n          } catch (err) {\n            return false;\n          }\n\n          if (!Array.isArray(results)) results = [results];\n          var numResults = results.length;\n\n          for (var ind = 0; ind < numResults; ind++) {\n            if (jmespath.strictDeepEqual(results[ind], expected)) {\n              return true;\n            }\n          }\n\n          return false;\n        },\n        status: function (resp, expected) {\n          var statusCode = resp.httpResponse.statusCode;\n          return typeof statusCode === 'number' && statusCode === expected;\n        },\n        error: function (resp, expected) {\n          if (typeof expected === 'string' && resp.error) {\n            return expected === resp.error.code;\n          } // if expected is not string, can be boolean indicating presence of error\n\n\n          return expected === !!resp.error;\n        }\n      },\n      listeners: new AWS.SequentialExecutor().addNamedListeners(function (add) {\n        add('RETRY_CHECK', 'retry', function (resp) {\n          var waiter = resp.request._waiter;\n\n          if (resp.error && resp.error.code === 'ResourceNotReady') {\n            resp.error.retryDelay = (waiter.config.delay || 0) * 1000;\n          }\n        });\n        add('CHECK_OUTPUT', 'extractData', CHECK_ACCEPTORS);\n        add('CHECK_ERROR', 'extractError', CHECK_ACCEPTORS);\n      }),\n\n      /**\n       * @return [AWS.Request]\n       */\n      wait: function wait(params, callback) {\n        if (typeof params === 'function') {\n          callback = params;\n          params = undefined;\n        }\n\n        if (params && params.$waiter) {\n          params = AWS.util.copy(params);\n\n          if (typeof params.$waiter.delay === 'number') {\n            this.config.delay = params.$waiter.delay;\n          }\n\n          if (typeof params.$waiter.maxAttempts === 'number') {\n            this.config.maxAttempts = params.$waiter.maxAttempts;\n          }\n\n          delete params.$waiter;\n        }\n\n        var request = this.service.makeRequest(this.config.operation, params);\n        request._waiter = this;\n        request.response.maxRetries = this.config.maxAttempts;\n        request.addListeners(this.listeners);\n        if (callback) request.send(callback);\n        return request;\n      },\n      setSuccess: function setSuccess(resp) {\n        resp.error = null;\n        resp.data = resp.data || {};\n        resp.request.removeAllListeners('extractData');\n      },\n      setError: function setError(resp, retryable) {\n        resp.data = null;\n        resp.error = AWS.util.error(resp.error || new Error(), {\n          code: 'ResourceNotReady',\n          message: 'Resource is not in the state ' + this.state,\n          retryable: retryable\n        });\n      },\n\n      /**\n       * Loads waiter configuration from API configuration\n       *\n       * @api private\n       */\n      loadWaiterConfig: function loadWaiterConfig(state) {\n        if (!this.service.api.waiters[state]) {\n          throw new AWS.util.error(new Error(), {\n            code: 'StateNotFoundError',\n            message: 'State ' + state + ' not found.'\n          });\n        }\n\n        this.config = AWS.util.copy(this.service.api.waiters[state]);\n      }\n    });\n  }, {\n    \"./core\": 18,\n    \"jmespath\": 85\n  }],\n  57: [function (require, module, exports) {\n    var AWS = require('./core');\n\n    var inherit = AWS.util.inherit;\n\n    var jmespath = require('jmespath');\n    /**\n     * This class encapsulates the response information\n     * from a service request operation sent through {AWS.Request}.\n     * The response object has two main properties for getting information\n     * back from a request:\n     *\n     * ## The `data` property\n     *\n     * The `response.data` property contains the serialized object data\n     * retrieved from the service request. For instance, for an\n     * Amazon DynamoDB `listTables` method call, the response data might\n     * look like:\n     *\n     * ```\n     * > resp.data\n     * { TableNames:\n     *    [ 'table1', 'table2', ... ] }\n     * ```\n     *\n     * The `data` property can be null if an error occurs (see below).\n     *\n     * ## The `error` property\n     *\n     * In the event of a service error (or transfer error), the\n     * `response.error` property will be filled with the given\n     * error data in the form:\n     *\n     * ```\n     * { code: 'SHORT_UNIQUE_ERROR_CODE',\n     *   message: 'Some human readable error message' }\n     * ```\n     *\n     * In the case of an error, the `data` property will be `null`.\n     * Note that if you handle events that can be in a failure state,\n     * you should always check whether `response.error` is set\n     * before attempting to access the `response.data` property.\n     *\n     * @!attribute data\n     *   @readonly\n     *   @!group Data Properties\n     *   @note Inside of a {AWS.Request~httpData} event, this\n     *     property contains a single raw packet instead of the\n     *     full de-serialized service response.\n     *   @return [Object] the de-serialized response data\n     *     from the service.\n     *\n     * @!attribute error\n     *   An structure containing information about a service\n     *   or networking error.\n     *   @readonly\n     *   @!group Data Properties\n     *   @note This attribute is only filled if a service or\n     *     networking error occurs.\n     *   @return [Error]\n     *     * code [String] a unique short code representing the\n     *       error that was emitted.\n     *     * message [String] a longer human readable error message\n     *     * retryable [Boolean] whether the error message is\n     *       retryable.\n     *     * statusCode [Numeric] in the case of a request that reached the service,\n     *       this value contains the response status code.\n     *     * time [Date] the date time object when the error occurred.\n     *     * hostname [String] set when a networking error occurs to easily\n     *       identify the endpoint of the request.\n     *     * region [String] set when a networking error occurs to easily\n     *       identify the region of the request.\n     *\n     * @!attribute requestId\n     *   @readonly\n     *   @!group Data Properties\n     *   @return [String] the unique request ID associated with the response.\n     *     Log this value when debugging requests for AWS support.\n     *\n     * @!attribute retryCount\n     *   @readonly\n     *   @!group Operation Properties\n     *   @return [Integer] the number of retries that were\n     *     attempted before the request was completed.\n     *\n     * @!attribute redirectCount\n     *   @readonly\n     *   @!group Operation Properties\n     *   @return [Integer] the number of redirects that were\n     *     followed before the request was completed.\n     *\n     * @!attribute httpResponse\n     *   @readonly\n     *   @!group HTTP Properties\n     *   @return [AWS.HttpResponse] the raw HTTP response object\n     *     containing the response headers and body information\n     *     from the server.\n     *\n     * @see AWS.Request\n     */\n\n\n    AWS.Response = inherit({\n      /**\n       * @api private\n       */\n      constructor: function Response(request) {\n        this.request = request;\n        this.data = null;\n        this.error = null;\n        this.retryCount = 0;\n        this.redirectCount = 0;\n        this.httpResponse = new AWS.HttpResponse();\n\n        if (request) {\n          this.maxRetries = request.service.numRetries();\n          this.maxRedirects = request.service.config.maxRedirects;\n        }\n      },\n\n      /**\n       * Creates a new request for the next page of response data, calling the\n       * callback with the page data if a callback is provided.\n       *\n       * @callback callback function(err, data)\n       *   Called when a page of data is returned from the next request.\n       *\n       *   @param err [Error] an error object, if an error occurred in the request\n       *   @param data [Object] the next page of data, or null, if there are no\n       *     more pages left.\n       * @return [AWS.Request] the request object for the next page of data\n       * @return [null] if no callback is provided and there are no pages left\n       *   to retrieve.\n       * @since v1.4.0\n       */\n      nextPage: function nextPage(callback) {\n        var config;\n        var service = this.request.service;\n        var operation = this.request.operation;\n\n        try {\n          config = service.paginationConfig(operation, true);\n        } catch (e) {\n          this.error = e;\n        }\n\n        if (!this.hasNextPage()) {\n          if (callback) callback(this.error, null);else if (this.error) throw this.error;\n          return null;\n        }\n\n        var params = AWS.util.copy(this.request.params);\n\n        if (!this.nextPageTokens) {\n          return callback ? callback(null, null) : null;\n        } else {\n          var inputTokens = config.inputToken;\n          if (typeof inputTokens === 'string') inputTokens = [inputTokens];\n\n          for (var i = 0; i < inputTokens.length; i++) {\n            params[inputTokens[i]] = this.nextPageTokens[i];\n          }\n\n          return service.makeRequest(this.request.operation, params, callback);\n        }\n      },\n\n      /**\n       * @return [Boolean] whether more pages of data can be returned by further\n       *   requests\n       * @since v1.4.0\n       */\n      hasNextPage: function hasNextPage() {\n        this.cacheNextPageTokens();\n        if (this.nextPageTokens) return true;\n        if (this.nextPageTokens === undefined) return undefined;else return false;\n      },\n\n      /**\n       * @api private\n       */\n      cacheNextPageTokens: function cacheNextPageTokens() {\n        if (Object.prototype.hasOwnProperty.call(this, 'nextPageTokens')) return this.nextPageTokens;\n        this.nextPageTokens = undefined;\n        var config = this.request.service.paginationConfig(this.request.operation);\n        if (!config) return this.nextPageTokens;\n        this.nextPageTokens = null;\n\n        if (config.moreResults) {\n          if (!jmespath.search(this.data, config.moreResults)) {\n            return this.nextPageTokens;\n          }\n        }\n\n        var exprs = config.outputToken;\n        if (typeof exprs === 'string') exprs = [exprs];\n        AWS.util.arrayEach.call(this, exprs, function (expr) {\n          var output = jmespath.search(this.data, expr);\n\n          if (output) {\n            this.nextPageTokens = this.nextPageTokens || [];\n            this.nextPageTokens.push(output);\n          }\n        });\n        return this.nextPageTokens;\n      }\n    });\n  }, {\n    \"./core\": 18,\n    \"jmespath\": 85\n  }],\n  58: [function (require, module, exports) {\n    var AWS = require('./core');\n    /**\n     * @api private\n     * @!method on(eventName, callback)\n     *   Registers an event listener callback for the event given by `eventName`.\n     *   Parameters passed to the callback function depend on the individual event\n     *   being triggered. See the event documentation for those parameters.\n     *\n     *   @param eventName [String] the event name to register the listener for\n     *   @param callback [Function] the listener callback function\n     *   @param toHead [Boolean] attach the listener callback to the head of callback array if set to true.\n     *     Default to be false.\n     *   @return [AWS.SequentialExecutor] the same object for chaining\n     */\n\n\n    AWS.SequentialExecutor = AWS.util.inherit({\n      constructor: function SequentialExecutor() {\n        this._events = {};\n      },\n\n      /**\n       * @api private\n       */\n      listeners: function listeners(eventName) {\n        return this._events[eventName] ? this._events[eventName].slice(0) : [];\n      },\n      on: function on(eventName, listener, toHead) {\n        if (this._events[eventName]) {\n          toHead ? this._events[eventName].unshift(listener) : this._events[eventName].push(listener);\n        } else {\n          this._events[eventName] = [listener];\n        }\n\n        return this;\n      },\n      onAsync: function onAsync(eventName, listener, toHead) {\n        listener._isAsync = true;\n        return this.on(eventName, listener, toHead);\n      },\n      removeListener: function removeListener(eventName, listener) {\n        var listeners = this._events[eventName];\n\n        if (listeners) {\n          var length = listeners.length;\n          var position = -1;\n\n          for (var i = 0; i < length; ++i) {\n            if (listeners[i] === listener) {\n              position = i;\n            }\n          }\n\n          if (position > -1) {\n            listeners.splice(position, 1);\n          }\n        }\n\n        return this;\n      },\n      removeAllListeners: function removeAllListeners(eventName) {\n        if (eventName) {\n          delete this._events[eventName];\n        } else {\n          this._events = {};\n        }\n\n        return this;\n      },\n\n      /**\n       * @api private\n       */\n      emit: function emit(eventName, eventArgs, doneCallback) {\n        if (!doneCallback) doneCallback = function () {};\n        var listeners = this.listeners(eventName);\n        var count = listeners.length;\n        this.callListeners(listeners, eventArgs, doneCallback);\n        return count > 0;\n      },\n\n      /**\n       * @api private\n       */\n      callListeners: function callListeners(listeners, args, doneCallback, prevError) {\n        var self = this;\n        var error = prevError || null;\n\n        function callNextListener(err) {\n          if (err) {\n            error = AWS.util.error(error || new Error(), err);\n\n            if (self._haltHandlersOnError) {\n              return doneCallback.call(self, error);\n            }\n          }\n\n          self.callListeners(listeners, args, doneCallback, error);\n        }\n\n        while (listeners.length > 0) {\n          var listener = listeners.shift();\n\n          if (listener._isAsync) {\n            // asynchronous listener\n            listener.apply(self, args.concat([callNextListener]));\n            return; // stop here, callNextListener will continue\n          } else {\n            // synchronous listener\n            try {\n              listener.apply(self, args);\n            } catch (err) {\n              error = AWS.util.error(error || new Error(), err);\n            }\n\n            if (error && self._haltHandlersOnError) {\n              doneCallback.call(self, error);\n              return;\n            }\n          }\n        }\n\n        doneCallback.call(self, error);\n      },\n\n      /**\n       * Adds or copies a set of listeners from another list of\n       * listeners or SequentialExecutor object.\n       *\n       * @param listeners [map<String,Array<Function>>, AWS.SequentialExecutor]\n       *   a list of events and callbacks, or an event emitter object\n       *   containing listeners to add to this emitter object.\n       * @return [AWS.SequentialExecutor] the emitter object, for chaining.\n       * @example Adding listeners from a map of listeners\n       *   emitter.addListeners({\n       *     event1: [function() { ... }, function() { ... }],\n       *     event2: [function() { ... }]\n       *   });\n       *   emitter.emit('event1'); // emitter has event1\n       *   emitter.emit('event2'); // emitter has event2\n       * @example Adding listeners from another emitter object\n       *   var emitter1 = new AWS.SequentialExecutor();\n       *   emitter1.on('event1', function() { ... });\n       *   emitter1.on('event2', function() { ... });\n       *   var emitter2 = new AWS.SequentialExecutor();\n       *   emitter2.addListeners(emitter1);\n       *   emitter2.emit('event1'); // emitter2 has event1\n       *   emitter2.emit('event2'); // emitter2 has event2\n       */\n      addListeners: function addListeners(listeners) {\n        var self = this; // extract listeners if parameter is an SequentialExecutor object\n\n        if (listeners._events) listeners = listeners._events;\n        AWS.util.each(listeners, function (event, callbacks) {\n          if (typeof callbacks === 'function') callbacks = [callbacks];\n          AWS.util.arrayEach(callbacks, function (callback) {\n            self.on(event, callback);\n          });\n        });\n        return self;\n      },\n\n      /**\n       * Registers an event with {on} and saves the callback handle function\n       * as a property on the emitter object using a given `name`.\n       *\n       * @param name [String] the property name to set on this object containing\n       *   the callback function handle so that the listener can be removed in\n       *   the future.\n       * @param (see on)\n       * @return (see on)\n       * @example Adding a named listener DATA_CALLBACK\n       *   var listener = function() { doSomething(); };\n       *   emitter.addNamedListener('DATA_CALLBACK', 'data', listener);\n       *\n       *   // the following prints: true\n       *   console.log(emitter.DATA_CALLBACK == listener);\n       */\n      addNamedListener: function addNamedListener(name, eventName, callback, toHead) {\n        this[name] = callback;\n        this.addListener(eventName, callback, toHead);\n        return this;\n      },\n\n      /**\n       * @api private\n       */\n      addNamedAsyncListener: function addNamedAsyncListener(name, eventName, callback, toHead) {\n        callback._isAsync = true;\n        return this.addNamedListener(name, eventName, callback, toHead);\n      },\n\n      /**\n       * Helper method to add a set of named listeners using\n       * {addNamedListener}. The callback contains a parameter\n       * with a handle to the `addNamedListener` method.\n       *\n       * @callback callback function(add)\n       *   The callback function is called immediately in order to provide\n       *   the `add` function to the block. This simplifies the addition of\n       *   a large group of named listeners.\n       *   @param add [Function] the {addNamedListener} function to call\n       *     when registering listeners.\n       * @example Adding a set of named listeners\n       *   emitter.addNamedListeners(function(add) {\n       *     add('DATA_CALLBACK', 'data', function() { ... });\n       *     add('OTHER', 'otherEvent', function() { ... });\n       *     add('LAST', 'lastEvent', function() { ... });\n       *   });\n       *\n       *   // these properties are now set:\n       *   emitter.DATA_CALLBACK;\n       *   emitter.OTHER;\n       *   emitter.LAST;\n       */\n      addNamedListeners: function addNamedListeners(callback) {\n        var self = this;\n        callback(function () {\n          self.addNamedListener.apply(self, arguments);\n        }, function () {\n          self.addNamedAsyncListener.apply(self, arguments);\n        });\n        return this;\n      }\n    });\n    /**\n     * {on} is the prefered method.\n     * @api private\n     */\n\n    AWS.SequentialExecutor.prototype.addListener = AWS.SequentialExecutor.prototype.on;\n    /**\n     * @api private\n     */\n\n    module.exports = AWS.SequentialExecutor;\n  }, {\n    \"./core\": 18\n  }],\n  59: [function (require, module, exports) {\n    (function (process) {\n      (function () {\n        var AWS = require('./core');\n\n        var Api = require('./model/api');\n\n        var regionConfig = require('./region_config');\n\n        var inherit = AWS.util.inherit;\n        var clientCount = 0;\n        /**\n         * The service class representing an AWS service.\n         *\n         * @class_abstract This class is an abstract class.\n         *\n         * @!attribute apiVersions\n         *   @return [Array<String>] the list of API versions supported by this service.\n         *   @readonly\n         */\n\n        AWS.Service = inherit({\n          /**\n           * Create a new service object with a configuration object\n           *\n           * @param config [map] a map of configuration options\n           */\n          constructor: function Service(config) {\n            if (!this.loadServiceClass) {\n              throw AWS.util.error(new Error(), 'Service must be constructed with `new\\' operator');\n            }\n\n            var ServiceClass = this.loadServiceClass(config || {});\n\n            if (ServiceClass) {\n              var originalConfig = AWS.util.copy(config);\n              var svc = new ServiceClass(config);\n              Object.defineProperty(svc, '_originalConfig', {\n                get: function () {\n                  return originalConfig;\n                },\n                enumerable: false,\n                configurable: true\n              });\n              svc._clientId = ++clientCount;\n              return svc;\n            }\n\n            this.initialize(config);\n          },\n\n          /**\n           * @api private\n           */\n          initialize: function initialize(config) {\n            var svcConfig = AWS.config[this.serviceIdentifier];\n            this.config = new AWS.Config(AWS.config);\n            if (svcConfig) this.config.update(svcConfig, true);\n            if (config) this.config.update(config, true);\n            this.validateService();\n            if (!this.config.endpoint) regionConfig(this);\n            this.config.endpoint = this.endpointFromTemplate(this.config.endpoint);\n            this.setEndpoint(this.config.endpoint); //enable attaching listeners to service client\n\n            AWS.SequentialExecutor.call(this);\n            AWS.Service.addDefaultMonitoringListeners(this);\n\n            if ((this.config.clientSideMonitoring || AWS.Service._clientSideMonitoring) && this.publisher) {\n              var publisher = this.publisher;\n              this.addNamedListener('PUBLISH_API_CALL', 'apiCall', function PUBLISH_API_CALL(event) {\n                process.nextTick(function () {\n                  publisher.eventHandler(event);\n                });\n              });\n              this.addNamedListener('PUBLISH_API_ATTEMPT', 'apiCallAttempt', function PUBLISH_API_ATTEMPT(event) {\n                process.nextTick(function () {\n                  publisher.eventHandler(event);\n                });\n              });\n            }\n          },\n\n          /**\n           * @api private\n           */\n          validateService: function validateService() {},\n\n          /**\n           * @api private\n           */\n          loadServiceClass: function loadServiceClass(serviceConfig) {\n            var config = serviceConfig;\n\n            if (!AWS.util.isEmpty(this.api)) {\n              return null;\n            } else if (config.apiConfig) {\n              return AWS.Service.defineServiceApi(this.constructor, config.apiConfig);\n            } else if (!this.constructor.services) {\n              return null;\n            } else {\n              config = new AWS.Config(AWS.config);\n              config.update(serviceConfig, true);\n              var version = config.apiVersions[this.constructor.serviceIdentifier];\n              version = version || config.apiVersion;\n              return this.getLatestServiceClass(version);\n            }\n          },\n\n          /**\n           * @api private\n           */\n          getLatestServiceClass: function getLatestServiceClass(version) {\n            version = this.getLatestServiceVersion(version);\n\n            if (this.constructor.services[version] === null) {\n              AWS.Service.defineServiceApi(this.constructor, version);\n            }\n\n            return this.constructor.services[version];\n          },\n\n          /**\n           * @api private\n           */\n          getLatestServiceVersion: function getLatestServiceVersion(version) {\n            if (!this.constructor.services || this.constructor.services.length === 0) {\n              throw new Error('No services defined on ' + this.constructor.serviceIdentifier);\n            }\n\n            if (!version) {\n              version = 'latest';\n            } else if (AWS.util.isType(version, Date)) {\n              version = AWS.util.date.iso8601(version).split('T')[0];\n            }\n\n            if (Object.hasOwnProperty(this.constructor.services, version)) {\n              return version;\n            }\n\n            var keys = Object.keys(this.constructor.services).sort();\n            var selectedVersion = null;\n\n            for (var i = keys.length - 1; i >= 0; i--) {\n              // versions that end in \"*\" are not available on disk and can be\n              // skipped, so do not choose these as selectedVersions\n              if (keys[i][keys[i].length - 1] !== '*') {\n                selectedVersion = keys[i];\n              }\n\n              if (keys[i].substr(0, 10) <= version) {\n                return selectedVersion;\n              }\n            }\n\n            throw new Error('Could not find ' + this.constructor.serviceIdentifier + ' API to satisfy version constraint `' + version + '\\'');\n          },\n\n          /**\n           * @api private\n           */\n          api: {},\n\n          /**\n           * @api private\n           */\n          defaultRetryCount: 3,\n\n          /**\n           * @api private\n           */\n          customizeRequests: function customizeRequests(callback) {\n            if (!callback) {\n              this.customRequestHandler = null;\n            } else if (typeof callback === 'function') {\n              this.customRequestHandler = callback;\n            } else {\n              throw new Error('Invalid callback type \\'' + typeof callback + '\\' provided in customizeRequests');\n            }\n          },\n\n          /**\n           * Calls an operation on a service with the given input parameters.\n           *\n           * @param operation [String] the name of the operation to call on the service.\n           * @param params [map] a map of input options for the operation\n           * @callback callback function(err, data)\n           *   If a callback is supplied, it is called when a response is returned\n           *   from the service.\n           *   @param err [Error] the error object returned from the request.\n           *     Set to `null` if the request is successful.\n           *   @param data [Object] the de-serialized data returned from\n           *     the request. Set to `null` if a request error occurs.\n           */\n          makeRequest: function makeRequest(operation, params, callback) {\n            if (typeof params === 'function') {\n              callback = params;\n              params = null;\n            }\n\n            params = params || {};\n\n            if (this.config.params) {\n              // copy only toplevel bound params\n              var rules = this.api.operations[operation];\n\n              if (rules) {\n                params = AWS.util.copy(params);\n                AWS.util.each(this.config.params, function (key, value) {\n                  if (rules.input.members[key]) {\n                    if (params[key] === undefined || params[key] === null) {\n                      params[key] = value;\n                    }\n                  }\n                });\n              }\n            }\n\n            var request = new AWS.Request(this, operation, params);\n            this.addAllRequestListeners(request);\n            this.attachMonitoringEmitter(request);\n            if (callback) request.send(callback);\n            return request;\n          },\n\n          /**\n           * Calls an operation on a service with the given input parameters, without\n           * any authentication data. This method is useful for \"public\" API operations.\n           *\n           * @param operation [String] the name of the operation to call on the service.\n           * @param params [map] a map of input options for the operation\n           * @callback callback function(err, data)\n           *   If a callback is supplied, it is called when a response is returned\n           *   from the service.\n           *   @param err [Error] the error object returned from the request.\n           *     Set to `null` if the request is successful.\n           *   @param data [Object] the de-serialized data returned from\n           *     the request. Set to `null` if a request error occurs.\n           */\n          makeUnauthenticatedRequest: function makeUnauthenticatedRequest(operation, params, callback) {\n            if (typeof params === 'function') {\n              callback = params;\n              params = {};\n            }\n\n            var request = this.makeRequest(operation, params).toUnauthenticated();\n            return callback ? request.send(callback) : request;\n          },\n\n          /**\n           * Waits for a given state\n           *\n           * @param state [String] the state on the service to wait for\n           * @param params [map] a map of parameters to pass with each request\n           * @option params $waiter [map] a map of configuration options for the waiter\n           * @option params $waiter.delay [Number] The number of seconds to wait between\n           *                                       requests\n           * @option params $waiter.maxAttempts [Number] The maximum number of requests\n           *                                             to send while waiting\n           * @callback callback function(err, data)\n           *   If a callback is supplied, it is called when a response is returned\n           *   from the service.\n           *   @param err [Error] the error object returned from the request.\n           *     Set to `null` if the request is successful.\n           *   @param data [Object] the de-serialized data returned from\n           *     the request. Set to `null` if a request error occurs.\n           */\n          waitFor: function waitFor(state, params, callback) {\n            var waiter = new AWS.ResourceWaiter(this, state);\n            return waiter.wait(params, callback);\n          },\n\n          /**\n           * @api private\n           */\n          addAllRequestListeners: function addAllRequestListeners(request) {\n            var list = [AWS.events, AWS.EventListeners.Core, this.serviceInterface(), AWS.EventListeners.CorePost];\n\n            for (var i = 0; i < list.length; i++) {\n              if (list[i]) request.addListeners(list[i]);\n            } // disable parameter validation\n\n\n            if (!this.config.paramValidation) {\n              request.removeListener('validate', AWS.EventListeners.Core.VALIDATE_PARAMETERS);\n            }\n\n            if (this.config.logger) {\n              // add logging events\n              request.addListeners(AWS.EventListeners.Logger);\n            }\n\n            this.setupRequestListeners(request); // call prototype's customRequestHandler\n\n            if (typeof this.constructor.prototype.customRequestHandler === 'function') {\n              this.constructor.prototype.customRequestHandler(request);\n            } // call instance's customRequestHandler\n\n\n            if (Object.prototype.hasOwnProperty.call(this, 'customRequestHandler') && typeof this.customRequestHandler === 'function') {\n              this.customRequestHandler(request);\n            }\n          },\n\n          /**\n           * Event recording metrics for a whole API call.\n           * @returns {object} a subset of api call metrics\n           * @api private\n           */\n          apiCallEvent: function apiCallEvent(request) {\n            var api = request.service.api.operations[request.operation];\n            var monitoringEvent = {\n              Type: 'ApiCall',\n              Api: api ? api.name : request.operation,\n              Version: 1,\n              Service: request.service.api.serviceId || request.service.api.endpointPrefix,\n              Region: request.httpRequest.region,\n              MaxRetriesExceeded: 0,\n              UserAgent: request.httpRequest.getUserAgent()\n            };\n            var response = request.response;\n\n            if (response.httpResponse.statusCode) {\n              monitoringEvent.FinalHttpStatusCode = response.httpResponse.statusCode;\n            }\n\n            if (response.error) {\n              var error = response.error;\n              var statusCode = response.httpResponse.statusCode;\n\n              if (statusCode > 299) {\n                if (error.code) monitoringEvent.FinalAwsException = error.code;\n                if (error.message) monitoringEvent.FinalAwsExceptionMessage = error.message;\n              } else {\n                if (error.code || error.name) monitoringEvent.FinalSdkException = error.code || error.name;\n                if (error.message) monitoringEvent.FinalSdkExceptionMessage = error.message;\n              }\n            }\n\n            return monitoringEvent;\n          },\n\n          /**\n           * Event recording metrics for an API call attempt.\n           * @returns {object} a subset of api call attempt metrics\n           * @api private\n           */\n          apiAttemptEvent: function apiAttemptEvent(request) {\n            var api = request.service.api.operations[request.operation];\n            var monitoringEvent = {\n              Type: 'ApiCallAttempt',\n              Api: api ? api.name : request.operation,\n              Version: 1,\n              Service: request.service.api.serviceId || request.service.api.endpointPrefix,\n              Fqdn: request.httpRequest.endpoint.hostname,\n              UserAgent: request.httpRequest.getUserAgent()\n            };\n            var response = request.response;\n\n            if (response.httpResponse.statusCode) {\n              monitoringEvent.HttpStatusCode = response.httpResponse.statusCode;\n            }\n\n            if (!request._unAuthenticated && request.service.config.credentials && request.service.config.credentials.accessKeyId) {\n              monitoringEvent.AccessKey = request.service.config.credentials.accessKeyId;\n            }\n\n            if (!response.httpResponse.headers) return monitoringEvent;\n\n            if (request.httpRequest.headers['x-amz-security-token']) {\n              monitoringEvent.SessionToken = request.httpRequest.headers['x-amz-security-token'];\n            }\n\n            if (response.httpResponse.headers['x-amzn-requestid']) {\n              monitoringEvent.XAmznRequestId = response.httpResponse.headers['x-amzn-requestid'];\n            }\n\n            if (response.httpResponse.headers['x-amz-request-id']) {\n              monitoringEvent.XAmzRequestId = response.httpResponse.headers['x-amz-request-id'];\n            }\n\n            if (response.httpResponse.headers['x-amz-id-2']) {\n              monitoringEvent.XAmzId2 = response.httpResponse.headers['x-amz-id-2'];\n            }\n\n            return monitoringEvent;\n          },\n\n          /**\n           * Add metrics of failed request.\n           * @api private\n           */\n          attemptFailEvent: function attemptFailEvent(request) {\n            var monitoringEvent = this.apiAttemptEvent(request);\n            var response = request.response;\n            var error = response.error;\n\n            if (response.httpResponse.statusCode > 299) {\n              if (error.code) monitoringEvent.AwsException = error.code;\n              if (error.message) monitoringEvent.AwsExceptionMessage = error.message;\n            } else {\n              if (error.code || error.name) monitoringEvent.SdkException = error.code || error.name;\n              if (error.message) monitoringEvent.SdkExceptionMessage = error.message;\n            }\n\n            return monitoringEvent;\n          },\n\n          /**\n           * Attach listeners to request object to fetch metrics of each request\n           * and emit data object through \\'ApiCall\\' and \\'ApiCallAttempt\\' events.\n           * @api private\n           */\n          attachMonitoringEmitter: function attachMonitoringEmitter(request) {\n            var attemptTimestamp; //timestamp marking the beginning of a request attempt\n\n            var attemptStartRealTime; //Start time of request attempt. Used to calculating attemptLatency\n\n            var attemptLatency; //latency from request sent out to http response reaching SDK\n\n            var callStartRealTime; //Start time of API call. Used to calculating API call latency\n\n            var attemptCount = 0; //request.retryCount is not reliable here\n\n            var region; //region cache region for each attempt since it can be updated in plase (e.g. s3)\n\n            var callTimestamp; //timestamp when the request is created\n\n            var self = this;\n            var addToHead = true;\n            request.on('validate', function () {\n              callStartRealTime = AWS.util.realClock.now();\n              callTimestamp = Date.now();\n            }, addToHead);\n            request.on('sign', function () {\n              attemptStartRealTime = AWS.util.realClock.now();\n              attemptTimestamp = Date.now();\n              region = request.httpRequest.region;\n              attemptCount++;\n            }, addToHead);\n            request.on('validateResponse', function () {\n              attemptLatency = Math.round(AWS.util.realClock.now() - attemptStartRealTime);\n            });\n            request.addNamedListener('API_CALL_ATTEMPT', 'success', function API_CALL_ATTEMPT() {\n              var apiAttemptEvent = self.apiAttemptEvent(request);\n              apiAttemptEvent.Timestamp = attemptTimestamp;\n              apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;\n              apiAttemptEvent.Region = region;\n              self.emit('apiCallAttempt', [apiAttemptEvent]);\n            });\n            request.addNamedListener('API_CALL_ATTEMPT_RETRY', 'retry', function API_CALL_ATTEMPT_RETRY() {\n              var apiAttemptEvent = self.attemptFailEvent(request);\n              apiAttemptEvent.Timestamp = attemptTimestamp; //attemptLatency may not be available if fail before response\n\n              attemptLatency = attemptLatency || Math.round(AWS.util.realClock.now() - attemptStartRealTime);\n              apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;\n              apiAttemptEvent.Region = region;\n              self.emit('apiCallAttempt', [apiAttemptEvent]);\n            });\n            request.addNamedListener('API_CALL', 'complete', function API_CALL() {\n              var apiCallEvent = self.apiCallEvent(request);\n              apiCallEvent.AttemptCount = attemptCount;\n              if (apiCallEvent.AttemptCount <= 0) return;\n              apiCallEvent.Timestamp = callTimestamp;\n              var latency = Math.round(AWS.util.realClock.now() - callStartRealTime);\n              apiCallEvent.Latency = latency >= 0 ? latency : 0;\n              var response = request.response;\n\n              if (typeof response.retryCount === 'number' && typeof response.maxRetries === 'number' && response.retryCount >= response.maxRetries) {\n                apiCallEvent.MaxRetriesExceeded = 1;\n              }\n\n              self.emit('apiCall', [apiCallEvent]);\n            });\n          },\n\n          /**\n           * Override this method to setup any custom request listeners for each\n           * new request to the service.\n           *\n           * @method_abstract This is an abstract method.\n           */\n          setupRequestListeners: function setupRequestListeners(request) {},\n\n          /**\n           * Gets the signer class for a given request\n           * @api private\n           */\n          getSignerClass: function getSignerClass(request) {\n            var version; // get operation authtype if present\n\n            var operation = null;\n            var authtype = '';\n\n            if (request) {\n              var operations = request.service.api.operations || {};\n              operation = operations[request.operation] || null;\n              authtype = operation ? operation.authtype : '';\n            }\n\n            if (this.config.signatureVersion) {\n              version = this.config.signatureVersion;\n            } else if (authtype === 'v4' || authtype === 'v4-unsigned-body') {\n              version = 'v4';\n            } else {\n              version = this.api.signatureVersion;\n            }\n\n            return AWS.Signers.RequestSigner.getVersion(version);\n          },\n\n          /**\n           * @api private\n           */\n          serviceInterface: function serviceInterface() {\n            switch (this.api.protocol) {\n              case 'ec2':\n                return AWS.EventListeners.Query;\n\n              case 'query':\n                return AWS.EventListeners.Query;\n\n              case 'json':\n                return AWS.EventListeners.Json;\n\n              case 'rest-json':\n                return AWS.EventListeners.RestJson;\n\n              case 'rest-xml':\n                return AWS.EventListeners.RestXml;\n            }\n\n            if (this.api.protocol) {\n              throw new Error('Invalid service `protocol\\' ' + this.api.protocol + ' in API config');\n            }\n          },\n\n          /**\n           * @api private\n           */\n          successfulResponse: function successfulResponse(resp) {\n            return resp.httpResponse.statusCode < 300;\n          },\n\n          /**\n           * How many times a failed request should be retried before giving up.\n           * the defaultRetryCount can be overriden by service classes.\n           *\n           * @api private\n           */\n          numRetries: function numRetries() {\n            if (this.config.maxRetries !== undefined) {\n              return this.config.maxRetries;\n            } else {\n              return this.defaultRetryCount;\n            }\n          },\n\n          /**\n           * @api private\n           */\n          retryDelays: function retryDelays(retryCount) {\n            return AWS.util.calculateRetryDelay(retryCount, this.config.retryDelayOptions);\n          },\n\n          /**\n           * @api private\n           */\n          retryableError: function retryableError(error) {\n            if (this.timeoutError(error)) return true;\n            if (this.networkingError(error)) return true;\n            if (this.expiredCredentialsError(error)) return true;\n            if (this.throttledError(error)) return true;\n            if (error.statusCode >= 500) return true;\n            return false;\n          },\n\n          /**\n           * @api private\n           */\n          networkingError: function networkingError(error) {\n            return error.code === 'NetworkingError';\n          },\n\n          /**\n           * @api private\n           */\n          timeoutError: function timeoutError(error) {\n            return error.code === 'TimeoutError';\n          },\n\n          /**\n           * @api private\n           */\n          expiredCredentialsError: function expiredCredentialsError(error) {\n            // TODO : this only handles *one* of the expired credential codes\n            return error.code === 'ExpiredTokenException';\n          },\n\n          /**\n           * @api private\n           */\n          clockSkewError: function clockSkewError(error) {\n            switch (error.code) {\n              case 'RequestTimeTooSkewed':\n              case 'RequestExpired':\n              case 'InvalidSignatureException':\n              case 'SignatureDoesNotMatch':\n              case 'AuthFailure':\n              case 'RequestInTheFuture':\n                return true;\n\n              default:\n                return false;\n            }\n          },\n\n          /**\n           * @api private\n           */\n          getSkewCorrectedDate: function getSkewCorrectedDate() {\n            return new Date(Date.now() + this.config.systemClockOffset);\n          },\n\n          /**\n           * @api private\n           */\n          applyClockOffset: function applyClockOffset(newServerTime) {\n            if (newServerTime) {\n              this.config.systemClockOffset = newServerTime - Date.now();\n            }\n          },\n\n          /**\n           * @api private\n           */\n          isClockSkewed: function isClockSkewed(newServerTime) {\n            if (newServerTime) {\n              return Math.abs(this.getSkewCorrectedDate().getTime() - newServerTime) >= 30000;\n            }\n          },\n\n          /**\n           * @api private\n           */\n          throttledError: function throttledError(error) {\n            // this logic varies between services\n            if (error.statusCode === 429) return true;\n\n            switch (error.code) {\n              case 'ProvisionedThroughputExceededException':\n              case 'Throttling':\n              case 'ThrottlingException':\n              case 'RequestLimitExceeded':\n              case 'RequestThrottled':\n              case 'RequestThrottledException':\n              case 'TooManyRequestsException':\n              case 'TransactionInProgressException':\n                //dynamodb\n                return true;\n\n              default:\n                return false;\n            }\n          },\n\n          /**\n           * @api private\n           */\n          endpointFromTemplate: function endpointFromTemplate(endpoint) {\n            if (typeof endpoint !== 'string') return endpoint;\n            var e = endpoint;\n            e = e.replace(/\\{service\\}/g, this.api.endpointPrefix);\n            e = e.replace(/\\{region\\}/g, this.config.region);\n            e = e.replace(/\\{scheme\\}/g, this.config.sslEnabled ? 'https' : 'http');\n            return e;\n          },\n\n          /**\n           * @api private\n           */\n          setEndpoint: function setEndpoint(endpoint) {\n            this.endpoint = new AWS.Endpoint(endpoint, this.config);\n          },\n\n          /**\n           * @api private\n           */\n          paginationConfig: function paginationConfig(operation, throwException) {\n            var paginator = this.api.operations[operation].paginator;\n\n            if (!paginator) {\n              if (throwException) {\n                var e = new Error();\n                throw AWS.util.error(e, 'No pagination configuration for ' + operation);\n              }\n\n              return null;\n            }\n\n            return paginator;\n          }\n        });\n        AWS.util.update(AWS.Service, {\n          /**\n           * Adds one method for each operation described in the api configuration\n           *\n           * @api private\n           */\n          defineMethods: function defineMethods(svc) {\n            AWS.util.each(svc.prototype.api.operations, function iterator(method) {\n              if (svc.prototype[method]) return;\n              var operation = svc.prototype.api.operations[method];\n\n              if (operation.authtype === 'none') {\n                svc.prototype[method] = function (params, callback) {\n                  return this.makeUnauthenticatedRequest(method, params, callback);\n                };\n              } else {\n                svc.prototype[method] = function (params, callback) {\n                  return this.makeRequest(method, params, callback);\n                };\n              }\n            });\n          },\n\n          /**\n           * Defines a new Service class using a service identifier and list of versions\n           * including an optional set of features (functions) to apply to the class\n           * prototype.\n           *\n           * @param serviceIdentifier [String] the identifier for the service\n           * @param versions [Array<String>] a list of versions that work with this\n           *   service\n           * @param features [Object] an object to attach to the prototype\n           * @return [Class<Service>] the service class defined by this function.\n           */\n          defineService: function defineService(serviceIdentifier, versions, features) {\n            AWS.Service._serviceMap[serviceIdentifier] = true;\n\n            if (!Array.isArray(versions)) {\n              features = versions;\n              versions = [];\n            }\n\n            var svc = inherit(AWS.Service, features || {});\n\n            if (typeof serviceIdentifier === 'string') {\n              AWS.Service.addVersions(svc, versions);\n              var identifier = svc.serviceIdentifier || serviceIdentifier;\n              svc.serviceIdentifier = identifier;\n            } else {\n              // defineService called with an API\n              svc.prototype.api = serviceIdentifier;\n              AWS.Service.defineMethods(svc);\n            }\n\n            AWS.SequentialExecutor.call(this.prototype); //util.clientSideMonitoring is only available in node\n\n            if (!this.prototype.publisher && AWS.util.clientSideMonitoring) {\n              var Publisher = AWS.util.clientSideMonitoring.Publisher;\n              var configProvider = AWS.util.clientSideMonitoring.configProvider;\n              var publisherConfig = configProvider();\n              this.prototype.publisher = new Publisher(publisherConfig);\n\n              if (publisherConfig.enabled) {\n                //if csm is enabled in environment, SDK should send all metrics\n                AWS.Service._clientSideMonitoring = true;\n              }\n            }\n\n            AWS.SequentialExecutor.call(svc.prototype);\n            AWS.Service.addDefaultMonitoringListeners(svc.prototype);\n            return svc;\n          },\n\n          /**\n           * @api private\n           */\n          addVersions: function addVersions(svc, versions) {\n            if (!Array.isArray(versions)) versions = [versions];\n            svc.services = svc.services || {};\n\n            for (var i = 0; i < versions.length; i++) {\n              if (svc.services[versions[i]] === undefined) {\n                svc.services[versions[i]] = null;\n              }\n            }\n\n            svc.apiVersions = Object.keys(svc.services).sort();\n          },\n\n          /**\n           * @api private\n           */\n          defineServiceApi: function defineServiceApi(superclass, version, apiConfig) {\n            var svc = inherit(superclass, {\n              serviceIdentifier: superclass.serviceIdentifier\n            });\n\n            function setApi(api) {\n              if (api.isApi) {\n                svc.prototype.api = api;\n              } else {\n                svc.prototype.api = new Api(api);\n              }\n            }\n\n            if (typeof version === 'string') {\n              if (apiConfig) {\n                setApi(apiConfig);\n              } else {\n                try {\n                  setApi(AWS.apiLoader(superclass.serviceIdentifier, version));\n                } catch (err) {\n                  throw AWS.util.error(err, {\n                    message: 'Could not find API configuration ' + superclass.serviceIdentifier + '-' + version\n                  });\n                }\n              }\n\n              if (!Object.prototype.hasOwnProperty.call(superclass.services, version)) {\n                superclass.apiVersions = superclass.apiVersions.concat(version).sort();\n              }\n\n              superclass.services[version] = svc;\n            } else {\n              setApi(version);\n            }\n\n            AWS.Service.defineMethods(svc);\n            return svc;\n          },\n\n          /**\n           * @api private\n           */\n          hasService: function (identifier) {\n            return Object.prototype.hasOwnProperty.call(AWS.Service._serviceMap, identifier);\n          },\n\n          /**\n           * @param attachOn attach default monitoring listeners to object\n           *\n           * Each monitoring event should be emitted from service client to service constructor prototype and then\n           * to global service prototype like bubbling up. These default monitoring events listener will transfer\n           * the monitoring events to the upper layer.\n           * @api private\n           */\n          addDefaultMonitoringListeners: function addDefaultMonitoringListeners(attachOn) {\n            attachOn.addNamedListener('MONITOR_EVENTS_BUBBLE', 'apiCallAttempt', function EVENTS_BUBBLE(event) {\n              var baseClass = Object.getPrototypeOf(attachOn);\n              if (baseClass._events) baseClass.emit('apiCallAttempt', [event]);\n            });\n            attachOn.addNamedListener('CALL_EVENTS_BUBBLE', 'apiCall', function CALL_EVENTS_BUBBLE(event) {\n              var baseClass = Object.getPrototypeOf(attachOn);\n              if (baseClass._events) baseClass.emit('apiCall', [event]);\n            });\n          },\n\n          /**\n           * @api private\n           */\n          _serviceMap: {}\n        });\n        AWS.util.mixin(AWS.Service, AWS.SequentialExecutor);\n        /**\n         * @api private\n         */\n\n        module.exports = AWS.Service;\n      }).call(this);\n    }).call(this, require('_process'));\n  }, {\n    \"./core\": 18,\n    \"./model/api\": 38,\n    \"./region_config\": 53,\n    \"_process\": 86\n  }],\n  60: [function (require, module, exports) {\n    var AWS = require('../core');\n\n    AWS.util.update(AWS.CognitoIdentity.prototype, {\n      getOpenIdToken: function getOpenIdToken(params, callback) {\n        return this.makeUnauthenticatedRequest('getOpenIdToken', params, callback);\n      },\n      getId: function getId(params, callback) {\n        return this.makeUnauthenticatedRequest('getId', params, callback);\n      },\n      getCredentialsForIdentity: function getCredentialsForIdentity(params, callback) {\n        return this.makeUnauthenticatedRequest('getCredentialsForIdentity', params, callback);\n      }\n    });\n  }, {\n    \"../core\": 18\n  }],\n  61: [function (require, module, exports) {\n    (function (process) {\n      (function () {\n        var AWS = require('../core');\n\n        var regionConfig = require('../region_config');\n\n        var ENV_REGIONAL_ENDPOINT_ENABLED = 'AWS_STS_REGIONAL_ENDPOINTS';\n        var CONFIG_REGIONAL_ENDPOINT_ENABLED = 'sts_regional_endpoints';\n        AWS.util.update(AWS.STS.prototype, {\n          /**\n           * @overload credentialsFrom(data, credentials = null)\n           *   Creates a credentials object from STS response data containing\n           *   credentials information. Useful for quickly setting AWS credentials.\n           *\n           *   @note This is a low-level utility function. If you want to load temporary\n           *     credentials into your process for subsequent requests to AWS resources,\n           *     you should use {AWS.TemporaryCredentials} instead.\n           *   @param data [map] data retrieved from a call to {getFederatedToken},\n           *     {getSessionToken}, {assumeRole}, or {assumeRoleWithWebIdentity}.\n           *   @param credentials [AWS.Credentials] an optional credentials object to\n           *     fill instead of creating a new object. Useful when modifying an\n           *     existing credentials object from a refresh call.\n           *   @return [AWS.TemporaryCredentials] the set of temporary credentials\n           *     loaded from a raw STS operation response.\n           *   @example Using credentialsFrom to load global AWS credentials\n           *     var sts = new AWS.STS();\n           *     sts.getSessionToken(function (err, data) {\n           *       if (err) console.log(\"Error getting credentials\");\n           *       else {\n           *         AWS.config.credentials = sts.credentialsFrom(data);\n           *       }\n           *     });\n           *   @see AWS.TemporaryCredentials\n           */\n          credentialsFrom: function credentialsFrom(data, credentials) {\n            if (!data) return null;\n            if (!credentials) credentials = new AWS.TemporaryCredentials();\n            credentials.expired = false;\n            credentials.accessKeyId = data.Credentials.AccessKeyId;\n            credentials.secretAccessKey = data.Credentials.SecretAccessKey;\n            credentials.sessionToken = data.Credentials.SessionToken;\n            credentials.expireTime = data.Credentials.Expiration;\n            return credentials;\n          },\n          assumeRoleWithWebIdentity: function assumeRoleWithWebIdentity(params, callback) {\n            return this.makeUnauthenticatedRequest('assumeRoleWithWebIdentity', params, callback);\n          },\n          assumeRoleWithSAML: function assumeRoleWithSAML(params, callback) {\n            return this.makeUnauthenticatedRequest('assumeRoleWithSAML', params, callback);\n          },\n\n          /**\n           * @api private\n           */\n          validateRegionalEndpointsFlagValue: function validateRegionalEndpointsFlagValue(configValue, errorOptions) {\n            if (typeof configValue === 'string' && ['legacy', 'regional'].indexOf(configValue.toLowerCase()) >= 0) {\n              this.config.stsRegionalEndpoints = configValue.toLowerCase();\n              return;\n            } else {\n              throw AWS.util.error(new Error(), errorOptions);\n            }\n          },\n\n          /**\n           * @api private\n           */\n          validateRegionalEndpointsFlag: function validateRegionalEndpointsFlag() {\n            //validate config value\n            var config = this.config;\n\n            if (config.stsRegionalEndpoints) {\n              this.validateRegionalEndpointsFlagValue(config.stsRegionalEndpoints, {\n                code: 'InvalidConfiguration',\n                message: 'invalid \"stsRegionalEndpoints\" configuration. Expect \"legacy\" ' + ' or \"regional\". Got \"' + config.stsRegionalEndpoints + '\".'\n              });\n            }\n\n            if (!AWS.util.isNode()) return; //validate environmental variable\n\n            if (Object.prototype.hasOwnProperty.call(process.env, ENV_REGIONAL_ENDPOINT_ENABLED)) {\n              var envFlag = process.env[ENV_REGIONAL_ENDPOINT_ENABLED];\n              this.validateRegionalEndpointsFlagValue(envFlag, {\n                code: 'InvalidEnvironmentalVariable',\n                message: 'invalid ' + ENV_REGIONAL_ENDPOINT_ENABLED + ' environmental variable. Expect \"legacy\" ' + ' or \"regional\". Got \"' + process.env[ENV_REGIONAL_ENDPOINT_ENABLED] + '\".'\n              });\n            } //validate shared config file\n\n\n            var profile = {};\n\n            try {\n              var profiles = AWS.util.getProfilesFromSharedConfig(AWS.util.iniLoader);\n              profile = profiles[process.env.AWS_PROFILE || AWS.util.defaultProfile];\n            } catch (e) {}\n\n            ;\n\n            if (profile && Object.prototype.hasOwnProperty.call(profile, CONFIG_REGIONAL_ENDPOINT_ENABLED)) {\n              var fileFlag = profile[CONFIG_REGIONAL_ENDPOINT_ENABLED];\n              this.validateRegionalEndpointsFlagValue(fileFlag, {\n                code: 'InvalidConfiguration',\n                message: 'invalid ' + CONFIG_REGIONAL_ENDPOINT_ENABLED + ' profile config. Expect \"legacy\" ' + ' or \"regional\". Got \"' + profile[CONFIG_REGIONAL_ENDPOINT_ENABLED] + '\".'\n              });\n            }\n          },\n\n          /**\n           * @api private\n           */\n          optInRegionalEndpoint: function optInRegionalEndpoint() {\n            this.validateRegionalEndpointsFlag();\n            var config = this.config;\n\n            if (config.stsRegionalEndpoints === 'regional') {\n              regionConfig(this);\n              if (!this.isGlobalEndpoint) return;\n              this.isGlobalEndpoint = false; //client will throw if region is not supplied; request will be signed with specified region\n\n              if (!config.region) {\n                throw AWS.util.error(new Error(), {\n                  code: 'ConfigError',\n                  message: 'Missing region in config'\n                });\n              }\n\n              var insertPoint = config.endpoint.indexOf('.amazonaws.com');\n              config.endpoint = config.endpoint.substring(0, insertPoint) + '.' + config.region + config.endpoint.substring(insertPoint);\n            }\n          },\n          validateService: function validateService() {\n            this.optInRegionalEndpoint();\n          }\n        });\n      }).call(this);\n    }).call(this, require('_process'));\n  }, {\n    \"../core\": 18,\n    \"../region_config\": 53,\n    \"_process\": 86\n  }],\n  62: [function (require, module, exports) {\n    var AWS = require('../core');\n\n    var inherit = AWS.util.inherit;\n    /**\n     * @api private\n     */\n\n    var expiresHeader = 'presigned-expires';\n    /**\n     * @api private\n     */\n\n    function signedUrlBuilder(request) {\n      var expires = request.httpRequest.headers[expiresHeader];\n      var signerClass = request.service.getSignerClass(request);\n      delete request.httpRequest.headers['User-Agent'];\n      delete request.httpRequest.headers['X-Amz-User-Agent'];\n\n      if (signerClass === AWS.Signers.V4) {\n        if (expires > 604800) {\n          // one week expiry is invalid\n          var message = 'Presigning does not support expiry time greater ' + 'than a week with SigV4 signing.';\n          throw AWS.util.error(new Error(), {\n            code: 'InvalidExpiryTime',\n            message: message,\n            retryable: false\n          });\n        }\n\n        request.httpRequest.headers[expiresHeader] = expires;\n      } else if (signerClass === AWS.Signers.S3) {\n        var now = request.service ? request.service.getSkewCorrectedDate() : AWS.util.date.getDate();\n        request.httpRequest.headers[expiresHeader] = parseInt(AWS.util.date.unixTimestamp(now) + expires, 10).toString();\n      } else {\n        throw AWS.util.error(new Error(), {\n          message: 'Presigning only supports S3 or SigV4 signing.',\n          code: 'UnsupportedSigner',\n          retryable: false\n        });\n      }\n    }\n    /**\n     * @api private\n     */\n\n\n    function signedUrlSigner(request) {\n      var endpoint = request.httpRequest.endpoint;\n      var parsedUrl = AWS.util.urlParse(request.httpRequest.path);\n      var queryParams = {};\n\n      if (parsedUrl.search) {\n        queryParams = AWS.util.queryStringParse(parsedUrl.search.substr(1));\n      }\n\n      var auth = request.httpRequest.headers['Authorization'].split(' ');\n\n      if (auth[0] === 'AWS') {\n        auth = auth[1].split(':');\n        queryParams['AWSAccessKeyId'] = auth[0];\n        queryParams['Signature'] = auth[1];\n        AWS.util.each(request.httpRequest.headers, function (key, value) {\n          if (key === expiresHeader) key = 'Expires';\n\n          if (key.indexOf('x-amz-meta-') === 0) {\n            // Delete existing, potentially not normalized key\n            delete queryParams[key];\n            key = key.toLowerCase();\n          }\n\n          queryParams[key] = value;\n        });\n        delete request.httpRequest.headers[expiresHeader];\n        delete queryParams['Authorization'];\n        delete queryParams['Host'];\n      } else if (auth[0] === 'AWS4-HMAC-SHA256') {\n        // SigV4 signing\n        auth.shift();\n        var rest = auth.join(' ');\n        var signature = rest.match(/Signature=(.*?)(?:,|\\s|\\r?\\n|$)/)[1];\n        queryParams['X-Amz-Signature'] = signature;\n        delete queryParams['Expires'];\n      } // build URL\n\n\n      endpoint.pathname = parsedUrl.pathname;\n      endpoint.search = AWS.util.queryParamsToString(queryParams);\n    }\n    /**\n     * @api private\n     */\n\n\n    AWS.Signers.Presign = inherit({\n      /**\n       * @api private\n       */\n      sign: function sign(request, expireTime, callback) {\n        request.httpRequest.headers[expiresHeader] = expireTime || 3600;\n        request.on('build', signedUrlBuilder);\n        request.on('sign', signedUrlSigner);\n        request.removeListener('afterBuild', AWS.EventListeners.Core.SET_CONTENT_LENGTH);\n        request.removeListener('afterBuild', AWS.EventListeners.Core.COMPUTE_SHA256);\n        request.emit('beforePresign', [request]);\n\n        if (callback) {\n          request.build(function () {\n            if (this.response.error) callback(this.response.error);else {\n              callback(null, AWS.util.urlFormat(request.httpRequest.endpoint));\n            }\n          });\n        } else {\n          request.build();\n          if (request.response.error) throw request.response.error;\n          return AWS.util.urlFormat(request.httpRequest.endpoint);\n        }\n      }\n    });\n    /**\n     * @api private\n     */\n\n    module.exports = AWS.Signers.Presign;\n  }, {\n    \"../core\": 18\n  }],\n  63: [function (require, module, exports) {\n    var AWS = require('../core');\n\n    var inherit = AWS.util.inherit;\n    /**\n     * @api private\n     */\n\n    AWS.Signers.RequestSigner = inherit({\n      constructor: function RequestSigner(request) {\n        this.request = request;\n      },\n      setServiceClientId: function setServiceClientId(id) {\n        this.serviceClientId = id;\n      },\n      getServiceClientId: function getServiceClientId() {\n        return this.serviceClientId;\n      }\n    });\n\n    AWS.Signers.RequestSigner.getVersion = function getVersion(version) {\n      switch (version) {\n        case 'v2':\n          return AWS.Signers.V2;\n\n        case 'v3':\n          return AWS.Signers.V3;\n\n        case 's3v4':\n          return AWS.Signers.V4;\n\n        case 'v4':\n          return AWS.Signers.V4;\n\n        case 's3':\n          return AWS.Signers.S3;\n\n        case 'v3https':\n          return AWS.Signers.V3Https;\n      }\n\n      throw new Error('Unknown signing version ' + version);\n    };\n\n    require('./v2');\n\n    require('./v3');\n\n    require('./v3https');\n\n    require('./v4');\n\n    require('./s3');\n\n    require('./presign');\n  }, {\n    \"../core\": 18,\n    \"./presign\": 62,\n    \"./s3\": 64,\n    \"./v2\": 65,\n    \"./v3\": 66,\n    \"./v3https\": 67,\n    \"./v4\": 68\n  }],\n  64: [function (require, module, exports) {\n    var AWS = require('../core');\n\n    var inherit = AWS.util.inherit;\n    /**\n     * @api private\n     */\n\n    AWS.Signers.S3 = inherit(AWS.Signers.RequestSigner, {\n      /**\n       * When building the stringToSign, these sub resource params should be\n       * part of the canonical resource string with their NON-decoded values\n       */\n      subResources: {\n        'acl': 1,\n        'accelerate': 1,\n        'analytics': 1,\n        'cors': 1,\n        'lifecycle': 1,\n        'delete': 1,\n        'inventory': 1,\n        'location': 1,\n        'logging': 1,\n        'metrics': 1,\n        'notification': 1,\n        'partNumber': 1,\n        'policy': 1,\n        'requestPayment': 1,\n        'replication': 1,\n        'restore': 1,\n        'tagging': 1,\n        'torrent': 1,\n        'uploadId': 1,\n        'uploads': 1,\n        'versionId': 1,\n        'versioning': 1,\n        'versions': 1,\n        'website': 1\n      },\n      // when building the stringToSign, these querystring params should be\n      // part of the canonical resource string with their NON-encoded values\n      responseHeaders: {\n        'response-content-type': 1,\n        'response-content-language': 1,\n        'response-expires': 1,\n        'response-cache-control': 1,\n        'response-content-disposition': 1,\n        'response-content-encoding': 1\n      },\n      addAuthorization: function addAuthorization(credentials, date) {\n        if (!this.request.headers['presigned-expires']) {\n          this.request.headers['X-Amz-Date'] = AWS.util.date.rfc822(date);\n        }\n\n        if (credentials.sessionToken) {\n          // presigned URLs require this header to be lowercased\n          this.request.headers['x-amz-security-token'] = credentials.sessionToken;\n        }\n\n        var signature = this.sign(credentials.secretAccessKey, this.stringToSign());\n        var auth = 'AWS ' + credentials.accessKeyId + ':' + signature;\n        this.request.headers['Authorization'] = auth;\n      },\n      stringToSign: function stringToSign() {\n        var r = this.request;\n        var parts = [];\n        parts.push(r.method);\n        parts.push(r.headers['Content-MD5'] || '');\n        parts.push(r.headers['Content-Type'] || ''); // This is the \"Date\" header, but we use X-Amz-Date.\n        // The S3 signing mechanism requires us to pass an empty\n        // string for this Date header regardless.\n\n        parts.push(r.headers['presigned-expires'] || '');\n        var headers = this.canonicalizedAmzHeaders();\n        if (headers) parts.push(headers);\n        parts.push(this.canonicalizedResource());\n        return parts.join('\\n');\n      },\n      canonicalizedAmzHeaders: function canonicalizedAmzHeaders() {\n        var amzHeaders = [];\n        AWS.util.each(this.request.headers, function (name) {\n          if (name.match(/^x-amz-/i)) amzHeaders.push(name);\n        });\n        amzHeaders.sort(function (a, b) {\n          return a.toLowerCase() < b.toLowerCase() ? -1 : 1;\n        });\n        var parts = [];\n        AWS.util.arrayEach.call(this, amzHeaders, function (name) {\n          parts.push(name.toLowerCase() + ':' + String(this.request.headers[name]));\n        });\n        return parts.join('\\n');\n      },\n      canonicalizedResource: function canonicalizedResource() {\n        var r = this.request;\n        var parts = r.path.split('?');\n        var path = parts[0];\n        var querystring = parts[1];\n        var resource = '';\n        if (r.virtualHostedBucket) resource += '/' + r.virtualHostedBucket;\n        resource += path;\n\n        if (querystring) {\n          // collect a list of sub resources and query params that need to be signed\n          var resources = [];\n          AWS.util.arrayEach.call(this, querystring.split('&'), function (param) {\n            var name = param.split('=')[0];\n            var value = param.split('=')[1];\n\n            if (this.subResources[name] || this.responseHeaders[name]) {\n              var subresource = {\n                name: name\n              };\n\n              if (value !== undefined) {\n                if (this.subResources[name]) {\n                  subresource.value = value;\n                } else {\n                  subresource.value = decodeURIComponent(value);\n                }\n              }\n\n              resources.push(subresource);\n            }\n          });\n          resources.sort(function (a, b) {\n            return a.name < b.name ? -1 : 1;\n          });\n\n          if (resources.length) {\n            querystring = [];\n            AWS.util.arrayEach(resources, function (res) {\n              if (res.value === undefined) {\n                querystring.push(res.name);\n              } else {\n                querystring.push(res.name + '=' + res.value);\n              }\n            });\n            resource += '?' + querystring.join('&');\n          }\n        }\n\n        return resource;\n      },\n      sign: function sign(secret, string) {\n        return AWS.util.crypto.hmac(secret, string, 'base64', 'sha1');\n      }\n    });\n    /**\n     * @api private\n     */\n\n    module.exports = AWS.Signers.S3;\n  }, {\n    \"../core\": 18\n  }],\n  65: [function (require, module, exports) {\n    var AWS = require('../core');\n\n    var inherit = AWS.util.inherit;\n    /**\n     * @api private\n     */\n\n    AWS.Signers.V2 = inherit(AWS.Signers.RequestSigner, {\n      addAuthorization: function addAuthorization(credentials, date) {\n        if (!date) date = AWS.util.date.getDate();\n        var r = this.request;\n        r.params.Timestamp = AWS.util.date.iso8601(date);\n        r.params.SignatureVersion = '2';\n        r.params.SignatureMethod = 'HmacSHA256';\n        r.params.AWSAccessKeyId = credentials.accessKeyId;\n\n        if (credentials.sessionToken) {\n          r.params.SecurityToken = credentials.sessionToken;\n        }\n\n        delete r.params.Signature; // delete old Signature for re-signing\n\n        r.params.Signature = this.signature(credentials);\n        r.body = AWS.util.queryParamsToString(r.params);\n        r.headers['Content-Length'] = r.body.length;\n      },\n      signature: function signature(credentials) {\n        return AWS.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), 'base64');\n      },\n      stringToSign: function stringToSign() {\n        var parts = [];\n        parts.push(this.request.method);\n        parts.push(this.request.endpoint.host.toLowerCase());\n        parts.push(this.request.pathname());\n        parts.push(AWS.util.queryParamsToString(this.request.params));\n        return parts.join('\\n');\n      }\n    });\n    /**\n     * @api private\n     */\n\n    module.exports = AWS.Signers.V2;\n  }, {\n    \"../core\": 18\n  }],\n  66: [function (require, module, exports) {\n    var AWS = require('../core');\n\n    var inherit = AWS.util.inherit;\n    /**\n     * @api private\n     */\n\n    AWS.Signers.V3 = inherit(AWS.Signers.RequestSigner, {\n      addAuthorization: function addAuthorization(credentials, date) {\n        var datetime = AWS.util.date.rfc822(date);\n        this.request.headers['X-Amz-Date'] = datetime;\n\n        if (credentials.sessionToken) {\n          this.request.headers['x-amz-security-token'] = credentials.sessionToken;\n        }\n\n        this.request.headers['X-Amzn-Authorization'] = this.authorization(credentials, datetime);\n      },\n      authorization: function authorization(credentials) {\n        return 'AWS3 ' + 'AWSAccessKeyId=' + credentials.accessKeyId + ',' + 'Algorithm=HmacSHA256,' + 'SignedHeaders=' + this.signedHeaders() + ',' + 'Signature=' + this.signature(credentials);\n      },\n      signedHeaders: function signedHeaders() {\n        var headers = [];\n        AWS.util.arrayEach(this.headersToSign(), function iterator(h) {\n          headers.push(h.toLowerCase());\n        });\n        return headers.sort().join(';');\n      },\n      canonicalHeaders: function canonicalHeaders() {\n        var headers = this.request.headers;\n        var parts = [];\n        AWS.util.arrayEach(this.headersToSign(), function iterator(h) {\n          parts.push(h.toLowerCase().trim() + ':' + String(headers[h]).trim());\n        });\n        return parts.sort().join('\\n') + '\\n';\n      },\n      headersToSign: function headersToSign() {\n        var headers = [];\n        AWS.util.each(this.request.headers, function iterator(k) {\n          if (k === 'Host' || k === 'Content-Encoding' || k.match(/^X-Amz/i)) {\n            headers.push(k);\n          }\n        });\n        return headers;\n      },\n      signature: function signature(credentials) {\n        return AWS.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), 'base64');\n      },\n      stringToSign: function stringToSign() {\n        var parts = [];\n        parts.push(this.request.method);\n        parts.push('/');\n        parts.push('');\n        parts.push(this.canonicalHeaders());\n        parts.push(this.request.body);\n        return AWS.util.crypto.sha256(parts.join('\\n'));\n      }\n    });\n    /**\n     * @api private\n     */\n\n    module.exports = AWS.Signers.V3;\n  }, {\n    \"../core\": 18\n  }],\n  67: [function (require, module, exports) {\n    var AWS = require('../core');\n\n    var inherit = AWS.util.inherit;\n\n    require('./v3');\n    /**\n     * @api private\n     */\n\n\n    AWS.Signers.V3Https = inherit(AWS.Signers.V3, {\n      authorization: function authorization(credentials) {\n        return 'AWS3-HTTPS ' + 'AWSAccessKeyId=' + credentials.accessKeyId + ',' + 'Algorithm=HmacSHA256,' + 'Signature=' + this.signature(credentials);\n      },\n      stringToSign: function stringToSign() {\n        return this.request.headers['X-Amz-Date'];\n      }\n    });\n    /**\n     * @api private\n     */\n\n    module.exports = AWS.Signers.V3Https;\n  }, {\n    \"../core\": 18,\n    \"./v3\": 66\n  }],\n  68: [function (require, module, exports) {\n    var AWS = require('../core');\n\n    var v4Credentials = require('./v4_credentials');\n\n    var inherit = AWS.util.inherit;\n    /**\n     * @api private\n     */\n\n    var expiresHeader = 'presigned-expires';\n    /**\n     * @api private\n     */\n\n    AWS.Signers.V4 = inherit(AWS.Signers.RequestSigner, {\n      constructor: function V4(request, serviceName, options) {\n        AWS.Signers.RequestSigner.call(this, request);\n        this.serviceName = serviceName;\n        options = options || {};\n        this.signatureCache = typeof options.signatureCache === 'boolean' ? options.signatureCache : true;\n        this.operation = options.operation;\n        this.signatureVersion = options.signatureVersion;\n      },\n      algorithm: 'AWS4-HMAC-SHA256',\n      addAuthorization: function addAuthorization(credentials, date) {\n        var datetime = AWS.util.date.iso8601(date).replace(/[:\\-]|\\.\\d{3}/g, '');\n\n        if (this.isPresigned()) {\n          this.updateForPresigned(credentials, datetime);\n        } else {\n          this.addHeaders(credentials, datetime);\n        }\n\n        this.request.headers['Authorization'] = this.authorization(credentials, datetime);\n      },\n      addHeaders: function addHeaders(credentials, datetime) {\n        this.request.headers['X-Amz-Date'] = datetime;\n\n        if (credentials.sessionToken) {\n          this.request.headers['x-amz-security-token'] = credentials.sessionToken;\n        }\n      },\n      updateForPresigned: function updateForPresigned(credentials, datetime) {\n        var credString = this.credentialString(datetime);\n        var qs = {\n          'X-Amz-Date': datetime,\n          'X-Amz-Algorithm': this.algorithm,\n          'X-Amz-Credential': credentials.accessKeyId + '/' + credString,\n          'X-Amz-Expires': this.request.headers[expiresHeader],\n          'X-Amz-SignedHeaders': this.signedHeaders()\n        };\n\n        if (credentials.sessionToken) {\n          qs['X-Amz-Security-Token'] = credentials.sessionToken;\n        }\n\n        if (this.request.headers['Content-Type']) {\n          qs['Content-Type'] = this.request.headers['Content-Type'];\n        }\n\n        if (this.request.headers['Content-MD5']) {\n          qs['Content-MD5'] = this.request.headers['Content-MD5'];\n        }\n\n        if (this.request.headers['Cache-Control']) {\n          qs['Cache-Control'] = this.request.headers['Cache-Control'];\n        } // need to pull in any other X-Amz-* headers\n\n\n        AWS.util.each.call(this, this.request.headers, function (key, value) {\n          if (key === expiresHeader) return;\n\n          if (this.isSignableHeader(key)) {\n            var lowerKey = key.toLowerCase(); // Metadata should be normalized\n\n            if (lowerKey.indexOf('x-amz-meta-') === 0) {\n              qs[lowerKey] = value;\n            } else if (lowerKey.indexOf('x-amz-') === 0) {\n              qs[key] = value;\n            }\n          }\n        });\n        var sep = this.request.path.indexOf('?') >= 0 ? '&' : '?';\n        this.request.path += sep + AWS.util.queryParamsToString(qs);\n      },\n      authorization: function authorization(credentials, datetime) {\n        var parts = [];\n        var credString = this.credentialString(datetime);\n        parts.push(this.algorithm + ' Credential=' + credentials.accessKeyId + '/' + credString);\n        parts.push('SignedHeaders=' + this.signedHeaders());\n        parts.push('Signature=' + this.signature(credentials, datetime));\n        return parts.join(', ');\n      },\n      signature: function signature(credentials, datetime) {\n        var signingKey = v4Credentials.getSigningKey(credentials, datetime.substr(0, 8), this.request.region, this.serviceName, this.signatureCache);\n        return AWS.util.crypto.hmac(signingKey, this.stringToSign(datetime), 'hex');\n      },\n      stringToSign: function stringToSign(datetime) {\n        var parts = [];\n        parts.push('AWS4-HMAC-SHA256');\n        parts.push(datetime);\n        parts.push(this.credentialString(datetime));\n        parts.push(this.hexEncodedHash(this.canonicalString()));\n        return parts.join('\\n');\n      },\n      canonicalString: function canonicalString() {\n        var parts = [],\n            pathname = this.request.pathname();\n        if (this.serviceName !== 's3' && this.signatureVersion !== 's3v4') pathname = AWS.util.uriEscapePath(pathname);\n        parts.push(this.request.method);\n        parts.push(pathname);\n        parts.push(this.request.search());\n        parts.push(this.canonicalHeaders() + '\\n');\n        parts.push(this.signedHeaders());\n        parts.push(this.hexEncodedBodyHash());\n        return parts.join('\\n');\n      },\n      canonicalHeaders: function canonicalHeaders() {\n        var headers = [];\n        AWS.util.each.call(this, this.request.headers, function (key, item) {\n          headers.push([key, item]);\n        });\n        headers.sort(function (a, b) {\n          return a[0].toLowerCase() < b[0].toLowerCase() ? -1 : 1;\n        });\n        var parts = [];\n        AWS.util.arrayEach.call(this, headers, function (item) {\n          var key = item[0].toLowerCase();\n\n          if (this.isSignableHeader(key)) {\n            var value = item[1];\n\n            if (typeof value === 'undefined' || value === null || typeof value.toString !== 'function') {\n              throw AWS.util.error(new Error('Header ' + key + ' contains invalid value'), {\n                code: 'InvalidHeader'\n              });\n            }\n\n            parts.push(key + ':' + this.canonicalHeaderValues(value.toString()));\n          }\n        });\n        return parts.join('\\n');\n      },\n      canonicalHeaderValues: function canonicalHeaderValues(values) {\n        return values.replace(/\\s+/g, ' ').replace(/^\\s+|\\s+$/g, '');\n      },\n      signedHeaders: function signedHeaders() {\n        var keys = [];\n        AWS.util.each.call(this, this.request.headers, function (key) {\n          key = key.toLowerCase();\n          if (this.isSignableHeader(key)) keys.push(key);\n        });\n        return keys.sort().join(';');\n      },\n      credentialString: function credentialString(datetime) {\n        return v4Credentials.createScope(datetime.substr(0, 8), this.request.region, this.serviceName);\n      },\n      hexEncodedHash: function hash(string) {\n        return AWS.util.crypto.sha256(string, 'hex');\n      },\n      hexEncodedBodyHash: function hexEncodedBodyHash() {\n        var request = this.request;\n\n        if (this.isPresigned() && this.serviceName === 's3' && !request.body) {\n          return 'UNSIGNED-PAYLOAD';\n        } else if (request.headers['X-Amz-Content-Sha256']) {\n          return request.headers['X-Amz-Content-Sha256'];\n        } else {\n          return this.hexEncodedHash(this.request.body || '');\n        }\n      },\n      unsignableHeaders: ['authorization', 'content-type', 'content-length', 'user-agent', expiresHeader, 'expect', 'x-amzn-trace-id'],\n      isSignableHeader: function isSignableHeader(key) {\n        if (key.toLowerCase().indexOf('x-amz-') === 0) return true;\n        return this.unsignableHeaders.indexOf(key) < 0;\n      },\n      isPresigned: function isPresigned() {\n        return this.request.headers[expiresHeader] ? true : false;\n      }\n    });\n    /**\n     * @api private\n     */\n\n    module.exports = AWS.Signers.V4;\n  }, {\n    \"../core\": 18,\n    \"./v4_credentials\": 69\n  }],\n  69: [function (require, module, exports) {\n    var AWS = require('../core');\n    /**\n     * @api private\n     */\n\n\n    var cachedSecret = {};\n    /**\n     * @api private\n     */\n\n    var cacheQueue = [];\n    /**\n     * @api private\n     */\n\n    var maxCacheEntries = 50;\n    /**\n     * @api private\n     */\n\n    var v4Identifier = 'aws4_request';\n    /**\n     * @api private\n     */\n\n    module.exports = {\n      /**\n       * @api private\n       *\n       * @param date [String]\n       * @param region [String]\n       * @param serviceName [String]\n       * @return [String]\n       */\n      createScope: function createScope(date, region, serviceName) {\n        return [date.substr(0, 8), region, serviceName, v4Identifier].join('/');\n      },\n\n      /**\n       * @api private\n       *\n       * @param credentials [Credentials]\n       * @param date [String]\n       * @param region [String]\n       * @param service [String]\n       * @param shouldCache [Boolean]\n       * @return [String]\n       */\n      getSigningKey: function getSigningKey(credentials, date, region, service, shouldCache) {\n        var credsIdentifier = AWS.util.crypto.hmac(credentials.secretAccessKey, credentials.accessKeyId, 'base64');\n        var cacheKey = [credsIdentifier, date, region, service].join('_');\n        shouldCache = shouldCache !== false;\n\n        if (shouldCache && cacheKey in cachedSecret) {\n          return cachedSecret[cacheKey];\n        }\n\n        var kDate = AWS.util.crypto.hmac('AWS4' + credentials.secretAccessKey, date, 'buffer');\n        var kRegion = AWS.util.crypto.hmac(kDate, region, 'buffer');\n        var kService = AWS.util.crypto.hmac(kRegion, service, 'buffer');\n        var signingKey = AWS.util.crypto.hmac(kService, v4Identifier, 'buffer');\n\n        if (shouldCache) {\n          cachedSecret[cacheKey] = signingKey;\n          cacheQueue.push(cacheKey);\n\n          if (cacheQueue.length > maxCacheEntries) {\n            // remove the oldest entry (not the least recently used)\n            delete cachedSecret[cacheQueue.shift()];\n          }\n        }\n\n        return signingKey;\n      },\n\n      /**\n       * @api private\n       *\n       * Empties the derived signing key cache. Made available for testing purposes\n       * only.\n       */\n      emptyCache: function emptyCache() {\n        cachedSecret = {};\n        cacheQueue = [];\n      }\n    };\n  }, {\n    \"../core\": 18\n  }],\n  70: [function (require, module, exports) {\n    function AcceptorStateMachine(states, state) {\n      this.currentState = state || null;\n      this.states = states || {};\n    }\n\n    AcceptorStateMachine.prototype.runTo = function runTo(finalState, done, bindObject, inputError) {\n      if (typeof finalState === 'function') {\n        inputError = bindObject;\n        bindObject = done;\n        done = finalState;\n        finalState = null;\n      }\n\n      var self = this;\n      var state = self.states[self.currentState];\n      state.fn.call(bindObject || self, inputError, function (err) {\n        if (err) {\n          if (state.fail) self.currentState = state.fail;else return done ? done.call(bindObject, err) : null;\n        } else {\n          if (state.accept) self.currentState = state.accept;else return done ? done.call(bindObject) : null;\n        }\n\n        if (self.currentState === finalState) {\n          return done ? done.call(bindObject, err) : null;\n        }\n\n        self.runTo(finalState, done, bindObject, err);\n      });\n    };\n\n    AcceptorStateMachine.prototype.addState = function addState(name, acceptState, failState, fn) {\n      if (typeof acceptState === 'function') {\n        fn = acceptState;\n        acceptState = null;\n        failState = null;\n      } else if (typeof failState === 'function') {\n        fn = failState;\n        failState = null;\n      }\n\n      if (!this.currentState) this.currentState = name;\n      this.states[name] = {\n        accept: acceptState,\n        fail: failState,\n        fn: fn\n      };\n      return this;\n    };\n    /**\n     * @api private\n     */\n\n\n    module.exports = AcceptorStateMachine;\n  }, {}],\n  71: [function (require, module, exports) {\n    (function (process, setImmediate) {\n      (function () {\n        /* eslint guard-for-in:0 */\n        var AWS;\n        /**\n         * A set of utility methods for use with the AWS SDK.\n         *\n         * @!attribute abort\n         *   Return this value from an iterator function {each} or {arrayEach}\n         *   to break out of the iteration.\n         *   @example Breaking out of an iterator function\n         *     AWS.util.each({a: 1, b: 2, c: 3}, function(key, value) {\n         *       if (key == 'b') return AWS.util.abort;\n         *     });\n         *   @see each\n         *   @see arrayEach\n         * @api private\n         */\n\n        var util = {\n          environment: 'nodejs',\n          engine: function engine() {\n            if (util.isBrowser() && typeof navigator !== 'undefined') {\n              return navigator.userAgent;\n            } else {\n              var engine = process.platform + '/' + process.version;\n\n              if (process.env.AWS_EXECUTION_ENV) {\n                engine += ' exec-env/' + process.env.AWS_EXECUTION_ENV;\n              }\n\n              return engine;\n            }\n          },\n          userAgent: function userAgent() {\n            var name = util.environment;\n\n            var agent = 'aws-sdk-' + name + '/' + require('./core').VERSION;\n\n            if (name === 'nodejs') agent += ' ' + util.engine();\n            return agent;\n          },\n          uriEscape: function uriEscape(string) {\n            var output = encodeURIComponent(string);\n            output = output.replace(/[^A-Za-z0-9_.~\\-%]+/g, escape); // AWS percent-encodes some extra non-standard characters in a URI\n\n            output = output.replace(/[*]/g, function (ch) {\n              return '%' + ch.charCodeAt(0).toString(16).toUpperCase();\n            });\n            return output;\n          },\n          uriEscapePath: function uriEscapePath(string) {\n            var parts = [];\n            util.arrayEach(string.split('/'), function (part) {\n              parts.push(util.uriEscape(part));\n            });\n            return parts.join('/');\n          },\n          urlParse: function urlParse(url) {\n            return util.url.parse(url);\n          },\n          urlFormat: function urlFormat(url) {\n            return util.url.format(url);\n          },\n          queryStringParse: function queryStringParse(qs) {\n            return util.querystring.parse(qs);\n          },\n          queryParamsToString: function queryParamsToString(params) {\n            var items = [];\n            var escape = util.uriEscape;\n            var sortedKeys = Object.keys(params).sort();\n            util.arrayEach(sortedKeys, function (name) {\n              var value = params[name];\n              var ename = escape(name);\n              var result = ename + '=';\n\n              if (Array.isArray(value)) {\n                var vals = [];\n                util.arrayEach(value, function (item) {\n                  vals.push(escape(item));\n                });\n                result = ename + '=' + vals.sort().join('&' + ename + '=');\n              } else if (value !== undefined && value !== null) {\n                result = ename + '=' + escape(value);\n              }\n\n              items.push(result);\n            });\n            return items.join('&');\n          },\n          readFileSync: function readFileSync(path) {\n            if (util.isBrowser()) return null;\n            return require('fs').readFileSync(path, 'utf-8');\n          },\n          base64: {\n            encode: function encode64(string) {\n              if (typeof string === 'number') {\n                throw util.error(new Error('Cannot base64 encode number ' + string));\n              }\n\n              if (string === null || typeof string === 'undefined') {\n                return string;\n              }\n\n              var buf = util.buffer.toBuffer(string);\n              return buf.toString('base64');\n            },\n            decode: function decode64(string) {\n              if (typeof string === 'number') {\n                throw util.error(new Error('Cannot base64 decode number ' + string));\n              }\n\n              if (string === null || typeof string === 'undefined') {\n                return string;\n              }\n\n              return util.buffer.toBuffer(string, 'base64');\n            }\n          },\n          buffer: {\n            /**\n             * Buffer constructor for Node buffer and buffer pollyfill\n             */\n            toBuffer: function (data, encoding) {\n              return typeof util.Buffer.from === 'function' && util.Buffer.from !== Uint8Array.from ? util.Buffer.from(data, encoding) : new util.Buffer(data, encoding);\n            },\n            alloc: function (size, fill, encoding) {\n              if (typeof size !== 'number') {\n                throw new Error('size passed to alloc must be a number.');\n              }\n\n              if (typeof util.Buffer.alloc === 'function') {\n                return util.Buffer.alloc(size, fill, encoding);\n              } else {\n                var buf = new util.Buffer(size);\n\n                if (fill !== undefined && typeof buf.fill === 'function') {\n                  buf.fill(fill, undefined, undefined, encoding);\n                }\n\n                return buf;\n              }\n            },\n            toStream: function toStream(buffer) {\n              if (!util.Buffer.isBuffer(buffer)) buffer = util.buffer.toBuffer(buffer);\n              var readable = new util.stream.Readable();\n              var pos = 0;\n\n              readable._read = function (size) {\n                if (pos >= buffer.length) return readable.push(null);\n                var end = pos + size;\n                if (end > buffer.length) end = buffer.length;\n                readable.push(buffer.slice(pos, end));\n                pos = end;\n              };\n\n              return readable;\n            },\n\n            /**\n             * Concatenates a list of Buffer objects.\n             */\n            concat: function (buffers) {\n              var length = 0,\n                  offset = 0,\n                  buffer = null,\n                  i;\n\n              for (i = 0; i < buffers.length; i++) {\n                length += buffers[i].length;\n              }\n\n              buffer = util.buffer.alloc(length);\n\n              for (i = 0; i < buffers.length; i++) {\n                buffers[i].copy(buffer, offset);\n                offset += buffers[i].length;\n              }\n\n              return buffer;\n            }\n          },\n          string: {\n            byteLength: function byteLength(string) {\n              if (string === null || string === undefined) return 0;\n              if (typeof string === 'string') string = util.buffer.toBuffer(string);\n\n              if (typeof string.byteLength === 'number') {\n                return string.byteLength;\n              } else if (typeof string.length === 'number') {\n                return string.length;\n              } else if (typeof string.size === 'number') {\n                return string.size;\n              } else if (typeof string.path === 'string') {\n                return require('fs').lstatSync(string.path).size;\n              } else {\n                throw util.error(new Error('Cannot determine length of ' + string), {\n                  object: string\n                });\n              }\n            },\n            upperFirst: function upperFirst(string) {\n              return string[0].toUpperCase() + string.substr(1);\n            },\n            lowerFirst: function lowerFirst(string) {\n              return string[0].toLowerCase() + string.substr(1);\n            }\n          },\n          ini: {\n            parse: function string(ini) {\n              var currentSection,\n                  map = {};\n              util.arrayEach(ini.split(/\\r?\\n/), function (line) {\n                line = line.split(/(^|\\s)[;#]/)[0]; // remove comments\n\n                var section = line.match(/^\\s*\\[([^\\[\\]]+)\\]\\s*$/);\n\n                if (section) {\n                  currentSection = section[1];\n                } else if (currentSection) {\n                  var item = line.match(/^\\s*(.+?)\\s*=\\s*(.+?)\\s*$/);\n\n                  if (item) {\n                    map[currentSection] = map[currentSection] || {};\n                    map[currentSection][item[1]] = item[2];\n                  }\n                }\n              });\n              return map;\n            }\n          },\n          fn: {\n            noop: function () {},\n            callback: function (err) {\n              if (err) throw err;\n            },\n\n            /**\n             * Turn a synchronous function into as \"async\" function by making it call\n             * a callback. The underlying function is called with all but the last argument,\n             * which is treated as the callback. The callback is passed passed a first argument\n             * of null on success to mimick standard node callbacks.\n             */\n            makeAsync: function makeAsync(fn, expectedArgs) {\n              if (expectedArgs && expectedArgs <= fn.length) {\n                return fn;\n              }\n\n              return function () {\n                var args = Array.prototype.slice.call(arguments, 0);\n                var callback = args.pop();\n                var result = fn.apply(null, args);\n                callback(result);\n              };\n            }\n          },\n\n          /**\n           * Date and time utility functions.\n           */\n          date: {\n            /**\n             * @return [Date] the current JavaScript date object. Since all\n             *   AWS services rely on this date object, you can override\n             *   this function to provide a special time value to AWS service\n             *   requests.\n             */\n            getDate: function getDate() {\n              if (!AWS) AWS = require('./core');\n\n              if (AWS.config.systemClockOffset) {\n                // use offset when non-zero\n                return new Date(new Date().getTime() + AWS.config.systemClockOffset);\n              } else {\n                return new Date();\n              }\n            },\n\n            /**\n             * @return [String] the date in ISO-8601 format\n             */\n            iso8601: function iso8601(date) {\n              if (date === undefined) {\n                date = util.date.getDate();\n              }\n\n              return date.toISOString().replace(/\\.\\d{3}Z$/, 'Z');\n            },\n\n            /**\n             * @return [String] the date in RFC 822 format\n             */\n            rfc822: function rfc822(date) {\n              if (date === undefined) {\n                date = util.date.getDate();\n              }\n\n              return date.toUTCString();\n            },\n\n            /**\n             * @return [Integer] the UNIX timestamp value for the current time\n             */\n            unixTimestamp: function unixTimestamp(date) {\n              if (date === undefined) {\n                date = util.date.getDate();\n              }\n\n              return date.getTime() / 1000;\n            },\n\n            /**\n             * @param [String,number,Date] date\n             * @return [Date]\n             */\n            from: function format(date) {\n              if (typeof date === 'number') {\n                return new Date(date * 1000); // unix timestamp\n              } else {\n                return new Date(date);\n              }\n            },\n\n            /**\n             * Given a Date or date-like value, this function formats the\n             * date into a string of the requested value.\n             * @param [String,number,Date] date\n             * @param [String] formatter Valid formats are:\n             #   * 'iso8601'\n             #   * 'rfc822'\n             #   * 'unixTimestamp'\n             * @return [String]\n             */\n            format: function format(date, formatter) {\n              if (!formatter) formatter = 'iso8601';\n              return util.date[formatter](util.date.from(date));\n            },\n            parseTimestamp: function parseTimestamp(value) {\n              if (typeof value === 'number') {\n                // unix timestamp (number)\n                return new Date(value * 1000);\n              } else if (value.match(/^\\d+$/)) {\n                // unix timestamp\n                return new Date(value * 1000);\n              } else if (value.match(/^\\d{4}/)) {\n                // iso8601\n                return new Date(value);\n              } else if (value.match(/^\\w{3},/)) {\n                // rfc822\n                return new Date(value);\n              } else {\n                throw util.error(new Error('unhandled timestamp format: ' + value), {\n                  code: 'TimestampParserError'\n                });\n              }\n            }\n          },\n          crypto: {\n            crc32Table: [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D],\n            crc32: function crc32(data) {\n              var tbl = util.crypto.crc32Table;\n              var crc = 0 ^ -1;\n\n              if (typeof data === 'string') {\n                data = util.buffer.toBuffer(data);\n              }\n\n              for (var i = 0; i < data.length; i++) {\n                var code = data.readUInt8(i);\n                crc = crc >>> 8 ^ tbl[(crc ^ code) & 0xFF];\n              }\n\n              return (crc ^ -1) >>> 0;\n            },\n            hmac: function hmac(key, string, digest, fn) {\n              if (!digest) digest = 'binary';\n\n              if (digest === 'buffer') {\n                digest = undefined;\n              }\n\n              if (!fn) fn = 'sha256';\n              if (typeof string === 'string') string = util.buffer.toBuffer(string);\n              return util.crypto.lib.createHmac(fn, key).update(string).digest(digest);\n            },\n            md5: function md5(data, digest, callback) {\n              return util.crypto.hash('md5', data, digest, callback);\n            },\n            sha256: function sha256(data, digest, callback) {\n              return util.crypto.hash('sha256', data, digest, callback);\n            },\n            hash: function (algorithm, data, digest, callback) {\n              var hash = util.crypto.createHash(algorithm);\n\n              if (!digest) {\n                digest = 'binary';\n              }\n\n              if (digest === 'buffer') {\n                digest = undefined;\n              }\n\n              if (typeof data === 'string') data = util.buffer.toBuffer(data);\n              var sliceFn = util.arraySliceFn(data);\n              var isBuffer = util.Buffer.isBuffer(data); //Identifying objects with an ArrayBuffer as buffers\n\n              if (util.isBrowser() && typeof ArrayBuffer !== 'undefined' && data && data.buffer instanceof ArrayBuffer) isBuffer = true;\n\n              if (callback && typeof data === 'object' && typeof data.on === 'function' && !isBuffer) {\n                data.on('data', function (chunk) {\n                  hash.update(chunk);\n                });\n                data.on('error', function (err) {\n                  callback(err);\n                });\n                data.on('end', function () {\n                  callback(null, hash.digest(digest));\n                });\n              } else if (callback && sliceFn && !isBuffer && typeof FileReader !== 'undefined') {\n                // this might be a File/Blob\n                var index = 0,\n                    size = 1024 * 512;\n                var reader = new FileReader();\n\n                reader.onerror = function () {\n                  callback(new Error('Failed to read data.'));\n                };\n\n                reader.onload = function () {\n                  var buf = new util.Buffer(new Uint8Array(reader.result));\n                  hash.update(buf);\n                  index += buf.length;\n\n                  reader._continueReading();\n                };\n\n                reader._continueReading = function () {\n                  if (index >= data.size) {\n                    callback(null, hash.digest(digest));\n                    return;\n                  }\n\n                  var back = index + size;\n                  if (back > data.size) back = data.size;\n                  reader.readAsArrayBuffer(sliceFn.call(data, index, back));\n                };\n\n                reader._continueReading();\n              } else {\n                if (util.isBrowser() && typeof data === 'object' && !isBuffer) {\n                  data = new util.Buffer(new Uint8Array(data));\n                }\n\n                var out = hash.update(data).digest(digest);\n                if (callback) callback(null, out);\n                return out;\n              }\n            },\n            toHex: function toHex(data) {\n              var out = [];\n\n              for (var i = 0; i < data.length; i++) {\n                out.push(('0' + data.charCodeAt(i).toString(16)).substr(-2, 2));\n              }\n\n              return out.join('');\n            },\n            createHash: function createHash(algorithm) {\n              return util.crypto.lib.createHash(algorithm);\n            }\n          },\n\n          /** @!ignore */\n\n          /* Abort constant */\n          abort: {},\n          each: function each(object, iterFunction) {\n            for (var key in object) {\n              if (Object.prototype.hasOwnProperty.call(object, key)) {\n                var ret = iterFunction.call(this, key, object[key]);\n                if (ret === util.abort) break;\n              }\n            }\n          },\n          arrayEach: function arrayEach(array, iterFunction) {\n            for (var idx in array) {\n              if (Object.prototype.hasOwnProperty.call(array, idx)) {\n                var ret = iterFunction.call(this, array[idx], parseInt(idx, 10));\n                if (ret === util.abort) break;\n              }\n            }\n          },\n          update: function update(obj1, obj2) {\n            util.each(obj2, function iterator(key, item) {\n              obj1[key] = item;\n            });\n            return obj1;\n          },\n          merge: function merge(obj1, obj2) {\n            return util.update(util.copy(obj1), obj2);\n          },\n          copy: function copy(object) {\n            if (object === null || object === undefined) return object;\n            var dupe = {}; // jshint forin:false\n\n            for (var key in object) {\n              dupe[key] = object[key];\n            }\n\n            return dupe;\n          },\n          isEmpty: function isEmpty(obj) {\n            for (var prop in obj) {\n              if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n                return false;\n              }\n            }\n\n            return true;\n          },\n          arraySliceFn: function arraySliceFn(obj) {\n            var fn = obj.slice || obj.webkitSlice || obj.mozSlice;\n            return typeof fn === 'function' ? fn : null;\n          },\n          isType: function isType(obj, type) {\n            // handle cross-\"frame\" objects\n            if (typeof type === 'function') type = util.typeName(type);\n            return Object.prototype.toString.call(obj) === '[object ' + type + ']';\n          },\n          typeName: function typeName(type) {\n            if (Object.prototype.hasOwnProperty.call(type, 'name')) return type.name;\n            var str = type.toString();\n            var match = str.match(/^\\s*function (.+)\\(/);\n            return match ? match[1] : str;\n          },\n          error: function error(err, options) {\n            var originalError = null;\n\n            if (typeof err.message === 'string' && err.message !== '') {\n              if (typeof options === 'string' || options && options.message) {\n                originalError = util.copy(err);\n                originalError.message = err.message;\n              }\n            }\n\n            err.message = err.message || null;\n\n            if (typeof options === 'string') {\n              err.message = options;\n            } else if (typeof options === 'object' && options !== null) {\n              util.update(err, options);\n              if (options.message) err.message = options.message;\n              if (options.code || options.name) err.code = options.code || options.name;\n              if (options.stack) err.stack = options.stack;\n            }\n\n            if (typeof Object.defineProperty === 'function') {\n              Object.defineProperty(err, 'name', {\n                writable: true,\n                enumerable: false\n              });\n              Object.defineProperty(err, 'message', {\n                enumerable: true\n              });\n            }\n\n            err.name = options && options.name || err.name || err.code || 'Error';\n            err.time = new Date();\n            if (originalError) err.originalError = originalError;\n            return err;\n          },\n\n          /**\n           * @api private\n           */\n          inherit: function inherit(klass, features) {\n            var newObject = null;\n\n            if (features === undefined) {\n              features = klass;\n              klass = Object;\n              newObject = {};\n            } else {\n              var ctor = function ConstructorWrapper() {};\n\n              ctor.prototype = klass.prototype;\n              newObject = new ctor();\n            } // constructor not supplied, create pass-through ctor\n\n\n            if (features.constructor === Object) {\n              features.constructor = function () {\n                if (klass !== Object) {\n                  return klass.apply(this, arguments);\n                }\n              };\n            }\n\n            features.constructor.prototype = newObject;\n            util.update(features.constructor.prototype, features);\n            features.constructor.__super__ = klass;\n            return features.constructor;\n          },\n\n          /**\n           * @api private\n           */\n          mixin: function mixin() {\n            var klass = arguments[0];\n\n            for (var i = 1; i < arguments.length; i++) {\n              // jshint forin:false\n              for (var prop in arguments[i].prototype) {\n                var fn = arguments[i].prototype[prop];\n\n                if (prop !== 'constructor') {\n                  klass.prototype[prop] = fn;\n                }\n              }\n            }\n\n            return klass;\n          },\n\n          /**\n           * @api private\n           */\n          hideProperties: function hideProperties(obj, props) {\n            if (typeof Object.defineProperty !== 'function') return;\n            util.arrayEach(props, function (key) {\n              Object.defineProperty(obj, key, {\n                enumerable: false,\n                writable: true,\n                configurable: true\n              });\n            });\n          },\n\n          /**\n           * @api private\n           */\n          property: function property(obj, name, value, enumerable, isValue) {\n            var opts = {\n              configurable: true,\n              enumerable: enumerable !== undefined ? enumerable : true\n            };\n\n            if (typeof value === 'function' && !isValue) {\n              opts.get = value;\n            } else {\n              opts.value = value;\n              opts.writable = true;\n            }\n\n            Object.defineProperty(obj, name, opts);\n          },\n\n          /**\n           * @api private\n           */\n          memoizedProperty: function memoizedProperty(obj, name, get, enumerable) {\n            var cachedValue = null; // build enumerable attribute for each value with lazy accessor.\n\n            util.property(obj, name, function () {\n              if (cachedValue === null) {\n                cachedValue = get();\n              }\n\n              return cachedValue;\n            }, enumerable);\n          },\n\n          /**\n           * TODO Remove in major version revision\n           * This backfill populates response data without the\n           * top-level payload name.\n           *\n           * @api private\n           */\n          hoistPayloadMember: function hoistPayloadMember(resp) {\n            var req = resp.request;\n            var operationName = req.operation;\n            var operation = req.service.api.operations[operationName];\n            var output = operation.output;\n\n            if (output.payload && !operation.hasEventOutput) {\n              var payloadMember = output.members[output.payload];\n              var responsePayload = resp.data[output.payload];\n\n              if (payloadMember.type === 'structure') {\n                util.each(responsePayload, function (key, value) {\n                  util.property(resp.data, key, value, false);\n                });\n              }\n            }\n          },\n\n          /**\n           * Compute SHA-256 checksums of streams\n           *\n           * @api private\n           */\n          computeSha256: function computeSha256(body, done) {\n            if (util.isNode()) {\n              var Stream = util.stream.Stream;\n\n              var fs = require('fs');\n\n              if (typeof Stream === 'function' && body instanceof Stream) {\n                if (typeof body.path === 'string') {\n                  // assume file object\n                  var settings = {};\n\n                  if (typeof body.start === 'number') {\n                    settings.start = body.start;\n                  }\n\n                  if (typeof body.end === 'number') {\n                    settings.end = body.end;\n                  }\n\n                  body = fs.createReadStream(body.path, settings);\n                } else {\n                  // TODO support other stream types\n                  return done(new Error('Non-file stream objects are ' + 'not supported with SigV4'));\n                }\n              }\n            }\n\n            util.crypto.sha256(body, 'hex', function (err, sha) {\n              if (err) done(err);else done(null, sha);\n            });\n          },\n\n          /**\n           * @api private\n           */\n          isClockSkewed: function isClockSkewed(serverTime) {\n            if (serverTime) {\n              util.property(AWS.config, 'isClockSkewed', Math.abs(new Date().getTime() - serverTime) >= 300000, false);\n              return AWS.config.isClockSkewed;\n            }\n          },\n          applyClockOffset: function applyClockOffset(serverTime) {\n            if (serverTime) AWS.config.systemClockOffset = serverTime - new Date().getTime();\n          },\n\n          /**\n           * @api private\n           */\n          extractRequestId: function extractRequestId(resp) {\n            var requestId = resp.httpResponse.headers['x-amz-request-id'] || resp.httpResponse.headers['x-amzn-requestid'];\n\n            if (!requestId && resp.data && resp.data.ResponseMetadata) {\n              requestId = resp.data.ResponseMetadata.RequestId;\n            }\n\n            if (requestId) {\n              resp.requestId = requestId;\n            }\n\n            if (resp.error) {\n              resp.error.requestId = requestId;\n            }\n          },\n\n          /**\n           * @api private\n           */\n          addPromises: function addPromises(constructors, PromiseDependency) {\n            var deletePromises = false;\n\n            if (PromiseDependency === undefined && AWS && AWS.config) {\n              PromiseDependency = AWS.config.getPromisesDependency();\n            }\n\n            if (PromiseDependency === undefined && typeof Promise !== 'undefined') {\n              PromiseDependency = Promise;\n            }\n\n            if (typeof PromiseDependency !== 'function') deletePromises = true;\n            if (!Array.isArray(constructors)) constructors = [constructors];\n\n            for (var ind = 0; ind < constructors.length; ind++) {\n              var constructor = constructors[ind];\n\n              if (deletePromises) {\n                if (constructor.deletePromisesFromClass) {\n                  constructor.deletePromisesFromClass();\n                }\n              } else if (constructor.addPromisesToClass) {\n                constructor.addPromisesToClass(PromiseDependency);\n              }\n            }\n          },\n\n          /**\n           * @api private\n           * Return a function that will return a promise whose fate is decided by the\n           * callback behavior of the given method with `methodName`. The method to be\n           * promisified should conform to node.js convention of accepting a callback as\n           * last argument and calling that callback with error as the first argument\n           * and success value on the second argument.\n           */\n          promisifyMethod: function promisifyMethod(methodName, PromiseDependency) {\n            return function promise() {\n              var self = this;\n              var args = Array.prototype.slice.call(arguments);\n              return new PromiseDependency(function (resolve, reject) {\n                args.push(function (err, data) {\n                  if (err) {\n                    reject(err);\n                  } else {\n                    resolve(data);\n                  }\n                });\n                self[methodName].apply(self, args);\n              });\n            };\n          },\n\n          /**\n           * @api private\n           */\n          isDualstackAvailable: function isDualstackAvailable(service) {\n            if (!service) return false;\n\n            var metadata = require('../apis/metadata.json');\n\n            if (typeof service !== 'string') service = service.serviceIdentifier;\n            if (typeof service !== 'string' || !metadata.hasOwnProperty(service)) return false;\n            return !!metadata[service].dualstackAvailable;\n          },\n\n          /**\n           * @api private\n           */\n          calculateRetryDelay: function calculateRetryDelay(retryCount, retryDelayOptions) {\n            if (!retryDelayOptions) retryDelayOptions = {};\n            var customBackoff = retryDelayOptions.customBackoff || null;\n\n            if (typeof customBackoff === 'function') {\n              return customBackoff(retryCount);\n            }\n\n            var base = typeof retryDelayOptions.base === 'number' ? retryDelayOptions.base : 100;\n            var delay = Math.random() * (Math.pow(2, retryCount) * base);\n            return delay;\n          },\n\n          /**\n           * @api private\n           */\n          handleRequestWithRetries: function handleRequestWithRetries(httpRequest, options, cb) {\n            if (!options) options = {};\n            var http = AWS.HttpClient.getInstance();\n            var httpOptions = options.httpOptions || {};\n            var retryCount = 0;\n\n            var errCallback = function (err) {\n              var maxRetries = options.maxRetries || 0;\n              if (err && err.code === 'TimeoutError') err.retryable = true;\n\n              if (err && err.retryable && retryCount < maxRetries) {\n                retryCount++;\n                var delay = util.calculateRetryDelay(retryCount, options.retryDelayOptions);\n                setTimeout(sendRequest, delay + (err.retryAfter || 0));\n              } else {\n                cb(err);\n              }\n            };\n\n            var sendRequest = function () {\n              var data = '';\n              http.handleRequest(httpRequest, httpOptions, function (httpResponse) {\n                httpResponse.on('data', function (chunk) {\n                  data += chunk.toString();\n                });\n                httpResponse.on('end', function () {\n                  var statusCode = httpResponse.statusCode;\n\n                  if (statusCode < 300) {\n                    cb(null, data);\n                  } else {\n                    var retryAfter = parseInt(httpResponse.headers['retry-after'], 10) * 1000 || 0;\n                    var err = util.error(new Error(), {\n                      retryable: statusCode >= 500 || statusCode === 429\n                    });\n                    if (retryAfter && err.retryable) err.retryAfter = retryAfter;\n                    errCallback(err);\n                  }\n                });\n              }, errCallback);\n            };\n\n            AWS.util.defer(sendRequest);\n          },\n\n          /**\n           * @api private\n           */\n          uuid: {\n            v4: function uuidV4() {\n              return require('uuid').v4();\n            }\n          },\n\n          /**\n           * @api private\n           */\n          convertPayloadToString: function convertPayloadToString(resp) {\n            var req = resp.request;\n            var operation = req.operation;\n            var rules = req.service.api.operations[operation].output || {};\n\n            if (rules.payload && resp.data[rules.payload]) {\n              resp.data[rules.payload] = resp.data[rules.payload].toString();\n            }\n          },\n\n          /**\n           * @api private\n           */\n          defer: function defer(callback) {\n            if (typeof process === 'object' && typeof process.nextTick === 'function') {\n              process.nextTick(callback);\n            } else if (typeof setImmediate === 'function') {\n              setImmediate(callback);\n            } else {\n              setTimeout(callback, 0);\n            }\n          },\n\n          /**\n           * @api private\n           */\n          getRequestPayloadShape: function getRequestPayloadShape(req) {\n            var operations = req.service.api.operations;\n            if (!operations) return undefined;\n            var operation = (operations || {})[req.operation];\n            if (!operation || !operation.input || !operation.input.payload) return undefined;\n            return operation.input.members[operation.input.payload];\n          },\n          getProfilesFromSharedConfig: function getProfilesFromSharedConfig(iniLoader, filename) {\n            var profiles = {};\n            var profilesFromConfig = {};\n\n            if (process.env[util.configOptInEnv]) {\n              var profilesFromConfig = iniLoader.loadFrom({\n                isConfig: true,\n                filename: process.env[util.sharedConfigFileEnv]\n              });\n            }\n\n            var profilesFromCreds = iniLoader.loadFrom({\n              filename: filename || process.env[util.configOptInEnv] && process.env[util.sharedCredentialsFileEnv]\n            });\n\n            for (var i = 0, profileNames = Object.keys(profilesFromConfig); i < profileNames.length; i++) {\n              profiles[profileNames[i]] = profilesFromConfig[profileNames[i]];\n            }\n\n            for (var i = 0, profileNames = Object.keys(profilesFromCreds); i < profileNames.length; i++) {\n              profiles[profileNames[i]] = profilesFromCreds[profileNames[i]];\n            }\n\n            return profiles;\n          },\n\n          /**\n           * @api private\n           */\n          defaultProfile: 'default',\n\n          /**\n           * @api private\n           */\n          configOptInEnv: 'AWS_SDK_LOAD_CONFIG',\n\n          /**\n           * @api private\n           */\n          sharedCredentialsFileEnv: 'AWS_SHARED_CREDENTIALS_FILE',\n\n          /**\n           * @api private\n           */\n          sharedConfigFileEnv: 'AWS_CONFIG_FILE',\n\n          /**\n           * @api private\n           */\n          imdsDisabledEnv: 'AWS_EC2_METADATA_DISABLED'\n        };\n        /**\n         * @api private\n         */\n\n        module.exports = util;\n      }).call(this);\n    }).call(this, require('_process'), require(\"timers\").setImmediate);\n  }, {\n    \"../apis/metadata.json\": 4,\n    \"./core\": 18,\n    \"_process\": 86,\n    \"fs\": 79,\n    \"timers\": 93,\n    \"uuid\": 98\n  }],\n  72: [function (require, module, exports) {\n    var util = require('../util');\n\n    var Shape = require('../model/shape');\n\n    function DomXmlParser() {}\n\n    DomXmlParser.prototype.parse = function (xml, shape) {\n      if (xml.replace(/^\\s+/, '') === '') return {};\n      var result, error;\n\n      try {\n        if (window.DOMParser) {\n          try {\n            var parser = new DOMParser();\n            result = parser.parseFromString(xml, 'text/xml');\n          } catch (syntaxError) {\n            throw util.error(new Error('Parse error in document'), {\n              originalError: syntaxError,\n              code: 'XMLParserError',\n              retryable: true\n            });\n          }\n\n          if (result.documentElement === null) {\n            throw util.error(new Error('Cannot parse empty document.'), {\n              code: 'XMLParserError',\n              retryable: true\n            });\n          }\n\n          var isError = result.getElementsByTagName('parsererror')[0];\n\n          if (isError && (isError.parentNode === result || isError.parentNode.nodeName === 'body' || isError.parentNode.parentNode === result || isError.parentNode.parentNode.nodeName === 'body')) {\n            var errorElement = isError.getElementsByTagName('div')[0] || isError;\n            throw util.error(new Error(errorElement.textContent || 'Parser error in document'), {\n              code: 'XMLParserError',\n              retryable: true\n            });\n          }\n        } else if (window.ActiveXObject) {\n          result = new window.ActiveXObject('Microsoft.XMLDOM');\n          result.async = false;\n\n          if (!result.loadXML(xml)) {\n            throw util.error(new Error('Parse error in document'), {\n              code: 'XMLParserError',\n              retryable: true\n            });\n          }\n        } else {\n          throw new Error('Cannot load XML parser');\n        }\n      } catch (e) {\n        error = e;\n      }\n\n      if (result && result.documentElement && !error) {\n        var data = parseXml(result.documentElement, shape);\n        var metadata = getElementByTagName(result.documentElement, 'ResponseMetadata');\n\n        if (metadata) {\n          data.ResponseMetadata = parseXml(metadata, {});\n        }\n\n        return data;\n      } else if (error) {\n        throw util.error(error || new Error(), {\n          code: 'XMLParserError',\n          retryable: true\n        });\n      } else {\n        // empty xml document\n        return {};\n      }\n    };\n\n    function getElementByTagName(xml, tag) {\n      var elements = xml.getElementsByTagName(tag);\n\n      for (var i = 0, iLen = elements.length; i < iLen; i++) {\n        if (elements[i].parentNode === xml) {\n          return elements[i];\n        }\n      }\n    }\n\n    function parseXml(xml, shape) {\n      if (!shape) shape = {};\n\n      switch (shape.type) {\n        case 'structure':\n          return parseStructure(xml, shape);\n\n        case 'map':\n          return parseMap(xml, shape);\n\n        case 'list':\n          return parseList(xml, shape);\n\n        case undefined:\n        case null:\n          return parseUnknown(xml);\n\n        default:\n          return parseScalar(xml, shape);\n      }\n    }\n\n    function parseStructure(xml, shape) {\n      var data = {};\n      if (xml === null) return data;\n      util.each(shape.members, function (memberName, memberShape) {\n        if (memberShape.isXmlAttribute) {\n          if (Object.prototype.hasOwnProperty.call(xml.attributes, memberShape.name)) {\n            var value = xml.attributes[memberShape.name].value;\n            data[memberName] = parseXml({\n              textContent: value\n            }, memberShape);\n          }\n        } else {\n          var xmlChild = memberShape.flattened ? xml : getElementByTagName(xml, memberShape.name);\n\n          if (xmlChild) {\n            data[memberName] = parseXml(xmlChild, memberShape);\n          } else if (!memberShape.flattened && memberShape.type === 'list') {\n            data[memberName] = memberShape.defaultValue;\n          }\n        }\n      });\n      return data;\n    }\n\n    function parseMap(xml, shape) {\n      var data = {};\n      var xmlKey = shape.key.name || 'key';\n      var xmlValue = shape.value.name || 'value';\n      var tagName = shape.flattened ? shape.name : 'entry';\n      var child = xml.firstElementChild;\n\n      while (child) {\n        if (child.nodeName === tagName) {\n          var key = getElementByTagName(child, xmlKey).textContent;\n          var value = getElementByTagName(child, xmlValue);\n          data[key] = parseXml(value, shape.value);\n        }\n\n        child = child.nextElementSibling;\n      }\n\n      return data;\n    }\n\n    function parseList(xml, shape) {\n      var data = [];\n      var tagName = shape.flattened ? shape.name : shape.member.name || 'member';\n      var child = xml.firstElementChild;\n\n      while (child) {\n        if (child.nodeName === tagName) {\n          data.push(parseXml(child, shape.member));\n        }\n\n        child = child.nextElementSibling;\n      }\n\n      return data;\n    }\n\n    function parseScalar(xml, shape) {\n      if (xml.getAttribute) {\n        var encoding = xml.getAttribute('encoding');\n\n        if (encoding === 'base64') {\n          shape = new Shape.create({\n            type: encoding\n          });\n        }\n      }\n\n      var text = xml.textContent;\n      if (text === '') text = null;\n\n      if (typeof shape.toType === 'function') {\n        return shape.toType(text);\n      } else {\n        return text;\n      }\n    }\n\n    function parseUnknown(xml) {\n      if (xml === undefined || xml === null) return ''; // empty object\n\n      if (!xml.firstElementChild) {\n        if (xml.parentNode.parentNode === null) return {};\n        if (xml.childNodes.length === 0) return '';else return xml.textContent;\n      } // object, parse as structure\n\n\n      var shape = {\n        type: 'structure',\n        members: {}\n      };\n      var child = xml.firstElementChild;\n\n      while (child) {\n        var tag = child.nodeName;\n\n        if (Object.prototype.hasOwnProperty.call(shape.members, tag)) {\n          // multiple tags of the same name makes it a list\n          shape.members[tag].type = 'list';\n        } else {\n          shape.members[tag] = {\n            name: tag\n          };\n        }\n\n        child = child.nextElementSibling;\n      }\n\n      return parseStructure(xml, shape);\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = DomXmlParser;\n  }, {\n    \"../model/shape\": 43,\n    \"../util\": 71\n  }],\n  73: [function (require, module, exports) {\n    var util = require('../util');\n\n    var XmlNode = require('./xml-node').XmlNode;\n\n    var XmlText = require('./xml-text').XmlText;\n\n    function XmlBuilder() {}\n\n    XmlBuilder.prototype.toXML = function (params, shape, rootElement, noEmpty) {\n      var xml = new XmlNode(rootElement);\n      applyNamespaces(xml, shape, true);\n      serialize(xml, params, shape);\n      return xml.children.length > 0 || noEmpty ? xml.toString() : '';\n    };\n\n    function serialize(xml, value, shape) {\n      switch (shape.type) {\n        case 'structure':\n          return serializeStructure(xml, value, shape);\n\n        case 'map':\n          return serializeMap(xml, value, shape);\n\n        case 'list':\n          return serializeList(xml, value, shape);\n\n        default:\n          return serializeScalar(xml, value, shape);\n      }\n    }\n\n    function serializeStructure(xml, params, shape) {\n      util.arrayEach(shape.memberNames, function (memberName) {\n        var memberShape = shape.members[memberName];\n        if (memberShape.location !== 'body') return;\n        var value = params[memberName];\n        var name = memberShape.name;\n\n        if (value !== undefined && value !== null) {\n          if (memberShape.isXmlAttribute) {\n            xml.addAttribute(name, value);\n          } else if (memberShape.flattened) {\n            serialize(xml, value, memberShape);\n          } else {\n            var element = new XmlNode(name);\n            xml.addChildNode(element);\n            applyNamespaces(element, memberShape);\n            serialize(element, value, memberShape);\n          }\n        }\n      });\n    }\n\n    function serializeMap(xml, map, shape) {\n      var xmlKey = shape.key.name || 'key';\n      var xmlValue = shape.value.name || 'value';\n      util.each(map, function (key, value) {\n        var entry = new XmlNode(shape.flattened ? shape.name : 'entry');\n        xml.addChildNode(entry);\n        var entryKey = new XmlNode(xmlKey);\n        var entryValue = new XmlNode(xmlValue);\n        entry.addChildNode(entryKey);\n        entry.addChildNode(entryValue);\n        serialize(entryKey, key, shape.key);\n        serialize(entryValue, value, shape.value);\n      });\n    }\n\n    function serializeList(xml, list, shape) {\n      if (shape.flattened) {\n        util.arrayEach(list, function (value) {\n          var name = shape.member.name || shape.name;\n          var element = new XmlNode(name);\n          xml.addChildNode(element);\n          serialize(element, value, shape.member);\n        });\n      } else {\n        util.arrayEach(list, function (value) {\n          var name = shape.member.name || 'member';\n          var element = new XmlNode(name);\n          xml.addChildNode(element);\n          serialize(element, value, shape.member);\n        });\n      }\n    }\n\n    function serializeScalar(xml, value, shape) {\n      xml.addChildNode(new XmlText(shape.toWireFormat(value)));\n    }\n\n    function applyNamespaces(xml, shape, isRoot) {\n      var uri,\n          prefix = 'xmlns';\n\n      if (shape.xmlNamespaceUri) {\n        uri = shape.xmlNamespaceUri;\n        if (shape.xmlNamespacePrefix) prefix += ':' + shape.xmlNamespacePrefix;\n      } else if (isRoot && shape.api.xmlNamespaceUri) {\n        uri = shape.api.xmlNamespaceUri;\n      }\n\n      if (uri) xml.addAttribute(prefix, uri);\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = XmlBuilder;\n  }, {\n    \"../util\": 71,\n    \"./xml-node\": 76,\n    \"./xml-text\": 77\n  }],\n  74: [function (require, module, exports) {\n    /**\n     * Escapes characters that can not be in an XML attribute.\n     */\n    function escapeAttribute(value) {\n      return value.replace(/&/g, '&amp;').replace(/'/g, '&apos;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;');\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = {\n      escapeAttribute: escapeAttribute\n    };\n  }, {}],\n  75: [function (require, module, exports) {\n    /**\n     * Escapes characters that can not be in an XML element.\n     */\n    function escapeElement(value) {\n      return value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n    }\n    /**\n     * @api private\n     */\n\n\n    module.exports = {\n      escapeElement: escapeElement\n    };\n  }, {}],\n  76: [function (require, module, exports) {\n    var escapeAttribute = require('./escape-attribute').escapeAttribute;\n    /**\n     * Represents an XML node.\n     * @api private\n     */\n\n\n    function XmlNode(name, children) {\n      if (children === void 0) {\n        children = [];\n      }\n\n      this.name = name;\n      this.children = children;\n      this.attributes = {};\n    }\n\n    XmlNode.prototype.addAttribute = function (name, value) {\n      this.attributes[name] = value;\n      return this;\n    };\n\n    XmlNode.prototype.addChildNode = function (child) {\n      this.children.push(child);\n      return this;\n    };\n\n    XmlNode.prototype.removeAttribute = function (name) {\n      delete this.attributes[name];\n      return this;\n    };\n\n    XmlNode.prototype.toString = function () {\n      var hasChildren = Boolean(this.children.length);\n      var xmlText = '<' + this.name; // add attributes\n\n      var attributes = this.attributes;\n\n      for (var i = 0, attributeNames = Object.keys(attributes); i < attributeNames.length; i++) {\n        var attributeName = attributeNames[i];\n        var attribute = attributes[attributeName];\n\n        if (typeof attribute !== 'undefined' && attribute !== null) {\n          xmlText += ' ' + attributeName + '=\\\"' + escapeAttribute('' + attribute) + '\\\"';\n        }\n      }\n\n      return xmlText += !hasChildren ? '/>' : '>' + this.children.map(function (c) {\n        return c.toString();\n      }).join('') + '</' + this.name + '>';\n    };\n    /**\n     * @api private\n     */\n\n\n    module.exports = {\n      XmlNode: XmlNode\n    };\n  }, {\n    \"./escape-attribute\": 74\n  }],\n  77: [function (require, module, exports) {\n    var escapeElement = require('./escape-element').escapeElement;\n    /**\n     * Represents an XML text value.\n     * @api private\n     */\n\n\n    function XmlText(value) {\n      this.value = value;\n    }\n\n    XmlText.prototype.toString = function () {\n      return escapeElement('' + this.value);\n    };\n    /**\n     * @api private\n     */\n\n\n    module.exports = {\n      XmlText: XmlText\n    };\n  }, {\n    \"./escape-element\": 75\n  }],\n  78: [function (require, module, exports) {\n    'use strict';\n\n    exports.byteLength = byteLength;\n    exports.toByteArray = toByteArray;\n    exports.fromByteArray = fromByteArray;\n    var lookup = [];\n    var revLookup = [];\n    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n    for (var i = 0, len = code.length; i < len; ++i) {\n      lookup[i] = code[i];\n      revLookup[code.charCodeAt(i)] = i;\n    } // Support decoding URL-safe base64 strings, as Node.js does.\n    // See: https://en.wikipedia.org/wiki/Base64#URL_applications\n\n\n    revLookup['-'.charCodeAt(0)] = 62;\n    revLookup['_'.charCodeAt(0)] = 63;\n\n    function getLens(b64) {\n      var len = b64.length;\n\n      if (len % 4 > 0) {\n        throw new Error('Invalid string. Length must be a multiple of 4');\n      } // Trim off extra bytes after placeholder bytes are found\n      // See: https://github.com/beatgammit/base64-js/issues/42\n\n\n      var validLen = b64.indexOf('=');\n      if (validLen === -1) validLen = len;\n      var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n      return [validLen, placeHoldersLen];\n    } // base64 is 4/3 + up to two characters of the original data\n\n\n    function byteLength(b64) {\n      var lens = getLens(b64);\n      var validLen = lens[0];\n      var placeHoldersLen = lens[1];\n      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n    }\n\n    function _byteLength(b64, validLen, placeHoldersLen) {\n      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n    }\n\n    function toByteArray(b64) {\n      var tmp;\n      var lens = getLens(b64);\n      var validLen = lens[0];\n      var placeHoldersLen = lens[1];\n      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n      var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars\n\n      var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n      var i;\n\n      for (i = 0; i < len; i += 4) {\n        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n        arr[curByte++] = tmp >> 16 & 0xFF;\n        arr[curByte++] = tmp >> 8 & 0xFF;\n        arr[curByte++] = tmp & 0xFF;\n      }\n\n      if (placeHoldersLen === 2) {\n        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n        arr[curByte++] = tmp & 0xFF;\n      }\n\n      if (placeHoldersLen === 1) {\n        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n        arr[curByte++] = tmp >> 8 & 0xFF;\n        arr[curByte++] = tmp & 0xFF;\n      }\n\n      return arr;\n    }\n\n    function tripletToBase64(num) {\n      return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n    }\n\n    function encodeChunk(uint8, start, end) {\n      var tmp;\n      var output = [];\n\n      for (var i = start; i < end; i += 3) {\n        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);\n        output.push(tripletToBase64(tmp));\n      }\n\n      return output.join('');\n    }\n\n    function fromByteArray(uint8) {\n      var tmp;\n      var len = uint8.length;\n      var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n\n      var parts = [];\n      var maxChunkLength = 16383; // must be multiple of 3\n      // go through the array every three bytes, we'll deal with trailing stuff later\n\n      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n        parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n      } // pad the end with zeros, but make sure to not forget the extra bytes\n\n\n      if (extraBytes === 1) {\n        tmp = uint8[len - 1];\n        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');\n      } else if (extraBytes === 2) {\n        tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');\n      }\n\n      return parts.join('');\n    }\n  }, {}],\n  79: [function (require, module, exports) {}, {}],\n  80: [function (require, module, exports) {\n    (function (global) {\n      (function () {\n        /*! https://mths.be/punycode v1.3.2 by @mathias */\n        ;\n\n        (function (root) {\n          /** Detect free variables */\n          var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n          var freeModule = typeof module == 'object' && module && !module.nodeType && module;\n          var freeGlobal = typeof global == 'object' && global;\n\n          if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {\n            root = freeGlobal;\n          }\n          /**\n           * The `punycode` object.\n           * @name punycode\n           * @type Object\n           */\n\n\n          var punycode,\n\n          /** Highest positive signed 32-bit float value */\n          maxInt = 2147483647,\n              // aka. 0x7FFFFFFF or 2^31-1\n\n          /** Bootstring parameters */\n          base = 36,\n              tMin = 1,\n              tMax = 26,\n              skew = 38,\n              damp = 700,\n              initialBias = 72,\n              initialN = 128,\n              // 0x80\n          delimiter = '-',\n              // '\\x2D'\n\n          /** Regular expressions */\n          regexPunycode = /^xn--/,\n              regexNonASCII = /[^\\x20-\\x7E]/,\n              // unprintable ASCII chars + non-ASCII chars\n          regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g,\n              // RFC 3490 separators\n\n          /** Error messages */\n          errors = {\n            'overflow': 'Overflow: input needs wider integers to process',\n            'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n            'invalid-input': 'Invalid input'\n          },\n\n          /** Convenience shortcuts */\n          baseMinusTMin = base - tMin,\n              floor = Math.floor,\n              stringFromCharCode = String.fromCharCode,\n\n          /** Temporary variable */\n          key;\n          /*--------------------------------------------------------------------------*/\n\n          /**\n           * A generic error utility function.\n           * @private\n           * @param {String} type The error type.\n           * @returns {Error} Throws a `RangeError` with the applicable error message.\n           */\n\n          function error(type) {\n            throw RangeError(errors[type]);\n          }\n          /**\n           * A generic `Array#map` utility function.\n           * @private\n           * @param {Array} array The array to iterate over.\n           * @param {Function} callback The function that gets called for every array\n           * item.\n           * @returns {Array} A new array of values returned by the callback function.\n           */\n\n\n          function map(array, fn) {\n            var length = array.length;\n            var result = [];\n\n            while (length--) {\n              result[length] = fn(array[length]);\n            }\n\n            return result;\n          }\n          /**\n           * A simple `Array#map`-like wrapper to work with domain name strings or email\n           * addresses.\n           * @private\n           * @param {String} domain The domain name or email address.\n           * @param {Function} callback The function that gets called for every\n           * character.\n           * @returns {Array} A new string of characters returned by the callback\n           * function.\n           */\n\n\n          function mapDomain(string, fn) {\n            var parts = string.split('@');\n            var result = '';\n\n            if (parts.length > 1) {\n              // In email addresses, only the domain name should be punycoded. Leave\n              // the local part (i.e. everything up to `@`) intact.\n              result = parts[0] + '@';\n              string = parts[1];\n            } // Avoid `split(regex)` for IE8 compatibility. See #17.\n\n\n            string = string.replace(regexSeparators, '\\x2E');\n            var labels = string.split('.');\n            var encoded = map(labels, fn).join('.');\n            return result + encoded;\n          }\n          /**\n           * Creates an array containing the numeric code points of each Unicode\n           * character in the string. While JavaScript uses UCS-2 internally,\n           * this function will convert a pair of surrogate halves (each of which\n           * UCS-2 exposes as separate characters) into a single code point,\n           * matching UTF-16.\n           * @see `punycode.ucs2.encode`\n           * @see <https://mathiasbynens.be/notes/javascript-encoding>\n           * @memberOf punycode.ucs2\n           * @name decode\n           * @param {String} string The Unicode input string (UCS-2).\n           * @returns {Array} The new array of code points.\n           */\n\n\n          function ucs2decode(string) {\n            var output = [],\n                counter = 0,\n                length = string.length,\n                value,\n                extra;\n\n            while (counter < length) {\n              value = string.charCodeAt(counter++);\n\n              if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n                // high surrogate, and there is a next character\n                extra = string.charCodeAt(counter++);\n\n                if ((extra & 0xFC00) == 0xDC00) {\n                  // low surrogate\n                  output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n                } else {\n                  // unmatched surrogate; only append this code unit, in case the next\n                  // code unit is the high surrogate of a surrogate pair\n                  output.push(value);\n                  counter--;\n                }\n              } else {\n                output.push(value);\n              }\n            }\n\n            return output;\n          }\n          /**\n           * Creates a string based on an array of numeric code points.\n           * @see `punycode.ucs2.decode`\n           * @memberOf punycode.ucs2\n           * @name encode\n           * @param {Array} codePoints The array of numeric code points.\n           * @returns {String} The new Unicode string (UCS-2).\n           */\n\n\n          function ucs2encode(array) {\n            return map(array, function (value) {\n              var output = '';\n\n              if (value > 0xFFFF) {\n                value -= 0x10000;\n                output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n                value = 0xDC00 | value & 0x3FF;\n              }\n\n              output += stringFromCharCode(value);\n              return output;\n            }).join('');\n          }\n          /**\n           * Converts a basic code point into a digit/integer.\n           * @see `digitToBasic()`\n           * @private\n           * @param {Number} codePoint The basic numeric code point value.\n           * @returns {Number} The numeric value of a basic code point (for use in\n           * representing integers) in the range `0` to `base - 1`, or `base` if\n           * the code point does not represent a value.\n           */\n\n\n          function basicToDigit(codePoint) {\n            if (codePoint - 48 < 10) {\n              return codePoint - 22;\n            }\n\n            if (codePoint - 65 < 26) {\n              return codePoint - 65;\n            }\n\n            if (codePoint - 97 < 26) {\n              return codePoint - 97;\n            }\n\n            return base;\n          }\n          /**\n           * Converts a digit/integer into a basic code point.\n           * @see `basicToDigit()`\n           * @private\n           * @param {Number} digit The numeric value of a basic code point.\n           * @returns {Number} The basic code point whose value (when used for\n           * representing integers) is `digit`, which needs to be in the range\n           * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n           * used; else, the lowercase form is used. The behavior is undefined\n           * if `flag` is non-zero and `digit` has no uppercase form.\n           */\n\n\n          function digitToBasic(digit, flag) {\n            //  0..25 map to ASCII a..z or A..Z\n            // 26..35 map to ASCII 0..9\n            return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n          }\n          /**\n           * Bias adaptation function as per section 3.4 of RFC 3492.\n           * http://tools.ietf.org/html/rfc3492#section-3.4\n           * @private\n           */\n\n\n          function adapt(delta, numPoints, firstTime) {\n            var k = 0;\n            delta = firstTime ? floor(delta / damp) : delta >> 1;\n            delta += floor(delta / numPoints);\n\n            for (; delta > baseMinusTMin * tMax >> 1; k += base) {\n              delta = floor(delta / baseMinusTMin);\n            }\n\n            return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n          }\n          /**\n           * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n           * symbols.\n           * @memberOf punycode\n           * @param {String} input The Punycode string of ASCII-only symbols.\n           * @returns {String} The resulting string of Unicode symbols.\n           */\n\n\n          function decode(input) {\n            // Don't use UCS-2\n            var output = [],\n                inputLength = input.length,\n                out,\n                i = 0,\n                n = initialN,\n                bias = initialBias,\n                basic,\n                j,\n                index,\n                oldi,\n                w,\n                k,\n                digit,\n                t,\n\n            /** Cached calculation results */\n            baseMinusT; // Handle the basic code points: let `basic` be the number of input code\n            // points before the last delimiter, or `0` if there is none, then copy\n            // the first basic code points to the output.\n\n            basic = input.lastIndexOf(delimiter);\n\n            if (basic < 0) {\n              basic = 0;\n            }\n\n            for (j = 0; j < basic; ++j) {\n              // if it's not a basic code point\n              if (input.charCodeAt(j) >= 0x80) {\n                error('not-basic');\n              }\n\n              output.push(input.charCodeAt(j));\n            } // Main decoding loop: start just after the last delimiter if any basic code\n            // points were copied; start at the beginning otherwise.\n\n\n            for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {\n              // `index` is the index of the next character to be consumed.\n              // Decode a generalized variable-length integer into `delta`,\n              // which gets added to `i`. The overflow checking is easier\n              // if we increase `i` as we go, then subtract off its starting\n              // value at the end to obtain `delta`.\n              for (oldi = i, w = 1, k = base;; k += base) {\n                if (index >= inputLength) {\n                  error('invalid-input');\n                }\n\n                digit = basicToDigit(input.charCodeAt(index++));\n\n                if (digit >= base || digit > floor((maxInt - i) / w)) {\n                  error('overflow');\n                }\n\n                i += digit * w;\n                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n                if (digit < t) {\n                  break;\n                }\n\n                baseMinusT = base - t;\n\n                if (w > floor(maxInt / baseMinusT)) {\n                  error('overflow');\n                }\n\n                w *= baseMinusT;\n              }\n\n              out = output.length + 1;\n              bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,\n              // incrementing `n` each time, so we'll fix that now:\n\n              if (floor(i / out) > maxInt - n) {\n                error('overflow');\n              }\n\n              n += floor(i / out);\n              i %= out; // Insert `n` at position `i` of the output\n\n              output.splice(i++, 0, n);\n            }\n\n            return ucs2encode(output);\n          }\n          /**\n           * Converts a string of Unicode symbols (e.g. a domain name label) to a\n           * Punycode string of ASCII-only symbols.\n           * @memberOf punycode\n           * @param {String} input The string of Unicode symbols.\n           * @returns {String} The resulting Punycode string of ASCII-only symbols.\n           */\n\n\n          function encode(input) {\n            var n,\n                delta,\n                handledCPCount,\n                basicLength,\n                bias,\n                j,\n                m,\n                q,\n                k,\n                t,\n                currentValue,\n                output = [],\n\n            /** `inputLength` will hold the number of code points in `input`. */\n            inputLength,\n\n            /** Cached calculation results */\n            handledCPCountPlusOne,\n                baseMinusT,\n                qMinusT; // Convert the input in UCS-2 to Unicode\n\n            input = ucs2decode(input); // Cache the length\n\n            inputLength = input.length; // Initialize the state\n\n            n = initialN;\n            delta = 0;\n            bias = initialBias; // Handle the basic code points\n\n            for (j = 0; j < inputLength; ++j) {\n              currentValue = input[j];\n\n              if (currentValue < 0x80) {\n                output.push(stringFromCharCode(currentValue));\n              }\n            }\n\n            handledCPCount = basicLength = output.length; // `handledCPCount` is the number of code points that have been handled;\n            // `basicLength` is the number of basic code points.\n            // Finish the basic string - if it is not empty - with a delimiter\n\n            if (basicLength) {\n              output.push(delimiter);\n            } // Main encoding loop:\n\n\n            while (handledCPCount < inputLength) {\n              // All non-basic code points < n have been handled already. Find the next\n              // larger one:\n              for (m = maxInt, j = 0; j < inputLength; ++j) {\n                currentValue = input[j];\n\n                if (currentValue >= n && currentValue < m) {\n                  m = currentValue;\n                }\n              } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n              // but guard against overflow\n\n\n              handledCPCountPlusOne = handledCPCount + 1;\n\n              if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n                error('overflow');\n              }\n\n              delta += (m - n) * handledCPCountPlusOne;\n              n = m;\n\n              for (j = 0; j < inputLength; ++j) {\n                currentValue = input[j];\n\n                if (currentValue < n && ++delta > maxInt) {\n                  error('overflow');\n                }\n\n                if (currentValue == n) {\n                  // Represent delta as a generalized variable-length integer\n                  for (q = delta, k = base;; k += base) {\n                    t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n                    if (q < t) {\n                      break;\n                    }\n\n                    qMinusT = q - t;\n                    baseMinusT = base - t;\n                    output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n                    q = floor(qMinusT / baseMinusT);\n                  }\n\n                  output.push(stringFromCharCode(digitToBasic(q, 0)));\n                  bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n                  delta = 0;\n                  ++handledCPCount;\n                }\n              }\n\n              ++delta;\n              ++n;\n            }\n\n            return output.join('');\n          }\n          /**\n           * Converts a Punycode string representing a domain name or an email address\n           * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n           * it doesn't matter if you call it on a string that has already been\n           * converted to Unicode.\n           * @memberOf punycode\n           * @param {String} input The Punycoded domain name or email address to\n           * convert to Unicode.\n           * @returns {String} The Unicode representation of the given Punycode\n           * string.\n           */\n\n\n          function toUnicode(input) {\n            return mapDomain(input, function (string) {\n              return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n            });\n          }\n          /**\n           * Converts a Unicode string representing a domain name or an email address to\n           * Punycode. Only the non-ASCII parts of the domain name will be converted,\n           * i.e. it doesn't matter if you call it with a domain that's already in\n           * ASCII.\n           * @memberOf punycode\n           * @param {String} input The domain name or email address to convert, as a\n           * Unicode string.\n           * @returns {String} The Punycode representation of the given domain name or\n           * email address.\n           */\n\n\n          function toASCII(input) {\n            return mapDomain(input, function (string) {\n              return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n            });\n          }\n          /*--------------------------------------------------------------------------*/\n\n          /** Define the public API */\n\n\n          punycode = {\n            /**\n             * A string representing the current Punycode.js version number.\n             * @memberOf punycode\n             * @type String\n             */\n            'version': '1.3.2',\n\n            /**\n             * An object of methods to convert from JavaScript's internal character\n             * representation (UCS-2) to Unicode code points, and back.\n             * @see <https://mathiasbynens.be/notes/javascript-encoding>\n             * @memberOf punycode\n             * @type Object\n             */\n            'ucs2': {\n              'decode': ucs2decode,\n              'encode': ucs2encode\n            },\n            'decode': decode,\n            'encode': encode,\n            'toASCII': toASCII,\n            'toUnicode': toUnicode\n          };\n          /** Expose `punycode` */\n          // Some AMD build optimizers, like r.js, check for specific condition patterns\n          // like the following:\n\n          if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n            define('punycode', function () {\n              return punycode;\n            });\n          } else if (freeExports && freeModule) {\n            if (module.exports == freeExports) {\n              // in Node.js or RingoJS v0.8.0+\n              freeModule.exports = punycode;\n            } else {\n              // in Narwhal or RingoJS v0.7.0-\n              for (key in punycode) {\n                punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n              }\n            }\n          } else {\n            // in Rhino or a web browser\n            root.punycode = punycode;\n          }\n        })(this);\n      }).call(this);\n    }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n  }, {}],\n  81: [function (require, module, exports) {\n    (function (global, Buffer) {\n      (function () {\n        /*!\n         * The buffer module from node.js, for the browser.\n         *\n         * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n         * @license  MIT\n         */\n\n        /* eslint-disable no-proto */\n        'use strict';\n\n        var base64 = require('base64-js');\n\n        var ieee754 = require('ieee754');\n\n        var isArray = require('isarray');\n\n        exports.Buffer = Buffer;\n        exports.SlowBuffer = SlowBuffer;\n        exports.INSPECT_MAX_BYTES = 50;\n        /**\n         * If `Buffer.TYPED_ARRAY_SUPPORT`:\n         *   === true    Use Uint8Array implementation (fastest)\n         *   === false   Use Object implementation (most compatible, even IE6)\n         *\n         * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n         * Opera 11.6+, iOS 4.2+.\n         *\n         * Due to various browser bugs, sometimes the Object implementation will be used even\n         * when the browser supports typed arrays.\n         *\n         * Note:\n         *\n         *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n         *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n         *\n         *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n         *\n         *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n         *     incorrect length in some situations.\n        \n         * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n         * get the Object implementation, which is slower but behaves correctly.\n         */\n\n        Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();\n        /*\n         * Export kMaxLength after typed array support is determined.\n         */\n\n        exports.kMaxLength = kMaxLength();\n\n        function typedArraySupport() {\n          try {\n            var arr = new Uint8Array(1);\n            arr.__proto__ = {\n              __proto__: Uint8Array.prototype,\n              foo: function () {\n                return 42;\n              }\n            };\n            return arr.foo() === 42 && // typed array instances can be augmented\n            typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n            arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`\n          } catch (e) {\n            return false;\n          }\n        }\n\n        function kMaxLength() {\n          return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;\n        }\n\n        function createBuffer(that, length) {\n          if (kMaxLength() < length) {\n            throw new RangeError('Invalid typed array length');\n          }\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            // Return an augmented `Uint8Array` instance, for best performance\n            that = new Uint8Array(length);\n            that.__proto__ = Buffer.prototype;\n          } else {\n            // Fallback: Return an object instance of the Buffer class\n            if (that === null) {\n              that = new Buffer(length);\n            }\n\n            that.length = length;\n          }\n\n          return that;\n        }\n        /**\n         * The Buffer constructor returns instances of `Uint8Array` that have their\n         * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n         * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n         * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n         * returns a single octet.\n         *\n         * The `Uint8Array` prototype remains unmodified.\n         */\n\n\n        function Buffer(arg, encodingOrOffset, length) {\n          if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n            return new Buffer(arg, encodingOrOffset, length);\n          } // Common case.\n\n\n          if (typeof arg === 'number') {\n            if (typeof encodingOrOffset === 'string') {\n              throw new Error('If encoding is specified then the first argument must be a string');\n            }\n\n            return allocUnsafe(this, arg);\n          }\n\n          return from(this, arg, encodingOrOffset, length);\n        }\n\n        Buffer.poolSize = 8192; // not used by this implementation\n        // TODO: Legacy, not needed anymore. Remove in next major version.\n\n        Buffer._augment = function (arr) {\n          arr.__proto__ = Buffer.prototype;\n          return arr;\n        };\n\n        function from(that, value, encodingOrOffset, length) {\n          if (typeof value === 'number') {\n            throw new TypeError('\"value\" argument must not be a number');\n          }\n\n          if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n            return fromArrayBuffer(that, value, encodingOrOffset, length);\n          }\n\n          if (typeof value === 'string') {\n            return fromString(that, value, encodingOrOffset);\n          }\n\n          return fromObject(that, value);\n        }\n        /**\n         * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n         * if value is a number.\n         * Buffer.from(str[, encoding])\n         * Buffer.from(array)\n         * Buffer.from(buffer)\n         * Buffer.from(arrayBuffer[, byteOffset[, length]])\n         **/\n\n\n        Buffer.from = function (value, encodingOrOffset, length) {\n          return from(null, value, encodingOrOffset, length);\n        };\n\n        if (Buffer.TYPED_ARRAY_SUPPORT) {\n          Buffer.prototype.__proto__ = Uint8Array.prototype;\n          Buffer.__proto__ = Uint8Array;\n\n          if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {\n            // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n            Object.defineProperty(Buffer, Symbol.species, {\n              value: null,\n              configurable: true\n            });\n          }\n        }\n\n        function assertSize(size) {\n          if (typeof size !== 'number') {\n            throw new TypeError('\"size\" argument must be a number');\n          } else if (size < 0) {\n            throw new RangeError('\"size\" argument must not be negative');\n          }\n        }\n\n        function alloc(that, size, fill, encoding) {\n          assertSize(size);\n\n          if (size <= 0) {\n            return createBuffer(that, size);\n          }\n\n          if (fill !== undefined) {\n            // Only pay attention to encoding if it's a string. This\n            // prevents accidentally sending in a number that would\n            // be interpretted as a start offset.\n            return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);\n          }\n\n          return createBuffer(that, size);\n        }\n        /**\n         * Creates a new filled Buffer instance.\n         * alloc(size[, fill[, encoding]])\n         **/\n\n\n        Buffer.alloc = function (size, fill, encoding) {\n          return alloc(null, size, fill, encoding);\n        };\n\n        function allocUnsafe(that, size) {\n          assertSize(size);\n          that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n\n          if (!Buffer.TYPED_ARRAY_SUPPORT) {\n            for (var i = 0; i < size; ++i) {\n              that[i] = 0;\n            }\n          }\n\n          return that;\n        }\n        /**\n         * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n         * */\n\n\n        Buffer.allocUnsafe = function (size) {\n          return allocUnsafe(null, size);\n        };\n        /**\n         * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n         */\n\n\n        Buffer.allocUnsafeSlow = function (size) {\n          return allocUnsafe(null, size);\n        };\n\n        function fromString(that, string, encoding) {\n          if (typeof encoding !== 'string' || encoding === '') {\n            encoding = 'utf8';\n          }\n\n          if (!Buffer.isEncoding(encoding)) {\n            throw new TypeError('\"encoding\" must be a valid string encoding');\n          }\n\n          var length = byteLength(string, encoding) | 0;\n          that = createBuffer(that, length);\n          var actual = that.write(string, encoding);\n\n          if (actual !== length) {\n            // Writing a hex string, for example, that contains invalid characters will\n            // cause everything after the first invalid character to be ignored. (e.g.\n            // 'abxxcd' will be treated as 'ab')\n            that = that.slice(0, actual);\n          }\n\n          return that;\n        }\n\n        function fromArrayLike(that, array) {\n          var length = array.length < 0 ? 0 : checked(array.length) | 0;\n          that = createBuffer(that, length);\n\n          for (var i = 0; i < length; i += 1) {\n            that[i] = array[i] & 255;\n          }\n\n          return that;\n        }\n\n        function fromArrayBuffer(that, array, byteOffset, length) {\n          array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n\n          if (byteOffset < 0 || array.byteLength < byteOffset) {\n            throw new RangeError('\\'offset\\' is out of bounds');\n          }\n\n          if (array.byteLength < byteOffset + (length || 0)) {\n            throw new RangeError('\\'length\\' is out of bounds');\n          }\n\n          if (byteOffset === undefined && length === undefined) {\n            array = new Uint8Array(array);\n          } else if (length === undefined) {\n            array = new Uint8Array(array, byteOffset);\n          } else {\n            array = new Uint8Array(array, byteOffset, length);\n          }\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            // Return an augmented `Uint8Array` instance, for best performance\n            that = array;\n            that.__proto__ = Buffer.prototype;\n          } else {\n            // Fallback: Return an object instance of the Buffer class\n            that = fromArrayLike(that, array);\n          }\n\n          return that;\n        }\n\n        function fromObject(that, obj) {\n          if (Buffer.isBuffer(obj)) {\n            var len = checked(obj.length) | 0;\n            that = createBuffer(that, len);\n\n            if (that.length === 0) {\n              return that;\n            }\n\n            obj.copy(that, 0, 0, len);\n            return that;\n          }\n\n          if (obj) {\n            if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {\n              if (typeof obj.length !== 'number' || isnan(obj.length)) {\n                return createBuffer(that, 0);\n              }\n\n              return fromArrayLike(that, obj);\n            }\n\n            if (obj.type === 'Buffer' && isArray(obj.data)) {\n              return fromArrayLike(that, obj.data);\n            }\n          }\n\n          throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');\n        }\n\n        function checked(length) {\n          // Note: cannot use `length < kMaxLength()` here because that fails when\n          // length is NaN (which is otherwise coerced to zero.)\n          if (length >= kMaxLength()) {\n            throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');\n          }\n\n          return length | 0;\n        }\n\n        function SlowBuffer(length) {\n          if (+length != length) {\n            // eslint-disable-line eqeqeq\n            length = 0;\n          }\n\n          return Buffer.alloc(+length);\n        }\n\n        Buffer.isBuffer = function isBuffer(b) {\n          return !!(b != null && b._isBuffer);\n        };\n\n        Buffer.compare = function compare(a, b) {\n          if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n            throw new TypeError('Arguments must be Buffers');\n          }\n\n          if (a === b) return 0;\n          var x = a.length;\n          var y = b.length;\n\n          for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n            if (a[i] !== b[i]) {\n              x = a[i];\n              y = b[i];\n              break;\n            }\n          }\n\n          if (x < y) return -1;\n          if (y < x) return 1;\n          return 0;\n        };\n\n        Buffer.isEncoding = function isEncoding(encoding) {\n          switch (String(encoding).toLowerCase()) {\n            case 'hex':\n            case 'utf8':\n            case 'utf-8':\n            case 'ascii':\n            case 'latin1':\n            case 'binary':\n            case 'base64':\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n              return true;\n\n            default:\n              return false;\n          }\n        };\n\n        Buffer.concat = function concat(list, length) {\n          if (!isArray(list)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n          }\n\n          if (list.length === 0) {\n            return Buffer.alloc(0);\n          }\n\n          var i;\n\n          if (length === undefined) {\n            length = 0;\n\n            for (i = 0; i < list.length; ++i) {\n              length += list[i].length;\n            }\n          }\n\n          var buffer = Buffer.allocUnsafe(length);\n          var pos = 0;\n\n          for (i = 0; i < list.length; ++i) {\n            var buf = list[i];\n\n            if (!Buffer.isBuffer(buf)) {\n              throw new TypeError('\"list\" argument must be an Array of Buffers');\n            }\n\n            buf.copy(buffer, pos);\n            pos += buf.length;\n          }\n\n          return buffer;\n        };\n\n        function byteLength(string, encoding) {\n          if (Buffer.isBuffer(string)) {\n            return string.length;\n          }\n\n          if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n            return string.byteLength;\n          }\n\n          if (typeof string !== 'string') {\n            string = '' + string;\n          }\n\n          var len = string.length;\n          if (len === 0) return 0; // Use a for loop to avoid recursion\n\n          var loweredCase = false;\n\n          for (;;) {\n            switch (encoding) {\n              case 'ascii':\n              case 'latin1':\n              case 'binary':\n                return len;\n\n              case 'utf8':\n              case 'utf-8':\n              case undefined:\n                return utf8ToBytes(string).length;\n\n              case 'ucs2':\n              case 'ucs-2':\n              case 'utf16le':\n              case 'utf-16le':\n                return len * 2;\n\n              case 'hex':\n                return len >>> 1;\n\n              case 'base64':\n                return base64ToBytes(string).length;\n\n              default:\n                if (loweredCase) return utf8ToBytes(string).length; // assume utf8\n\n                encoding = ('' + encoding).toLowerCase();\n                loweredCase = true;\n            }\n          }\n        }\n\n        Buffer.byteLength = byteLength;\n\n        function slowToString(encoding, start, end) {\n          var loweredCase = false; // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n          // property of a typed array.\n          // This behaves neither like String nor Uint8Array in that we set start/end\n          // to their upper/lower bounds if the value passed is out of range.\n          // undefined is handled specially as per ECMA-262 6th Edition,\n          // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\n          if (start === undefined || start < 0) {\n            start = 0;\n          } // Return early if start > this.length. Done here to prevent potential uint32\n          // coercion fail below.\n\n\n          if (start > this.length) {\n            return '';\n          }\n\n          if (end === undefined || end > this.length) {\n            end = this.length;\n          }\n\n          if (end <= 0) {\n            return '';\n          } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n\n\n          end >>>= 0;\n          start >>>= 0;\n\n          if (end <= start) {\n            return '';\n          }\n\n          if (!encoding) encoding = 'utf8';\n\n          while (true) {\n            switch (encoding) {\n              case 'hex':\n                return hexSlice(this, start, end);\n\n              case 'utf8':\n              case 'utf-8':\n                return utf8Slice(this, start, end);\n\n              case 'ascii':\n                return asciiSlice(this, start, end);\n\n              case 'latin1':\n              case 'binary':\n                return latin1Slice(this, start, end);\n\n              case 'base64':\n                return base64Slice(this, start, end);\n\n              case 'ucs2':\n              case 'ucs-2':\n              case 'utf16le':\n              case 'utf-16le':\n                return utf16leSlice(this, start, end);\n\n              default:\n                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n                encoding = (encoding + '').toLowerCase();\n                loweredCase = true;\n            }\n          }\n        } // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n        // Buffer instances.\n\n\n        Buffer.prototype._isBuffer = true;\n\n        function swap(b, n, m) {\n          var i = b[n];\n          b[n] = b[m];\n          b[m] = i;\n        }\n\n        Buffer.prototype.swap16 = function swap16() {\n          var len = this.length;\n\n          if (len % 2 !== 0) {\n            throw new RangeError('Buffer size must be a multiple of 16-bits');\n          }\n\n          for (var i = 0; i < len; i += 2) {\n            swap(this, i, i + 1);\n          }\n\n          return this;\n        };\n\n        Buffer.prototype.swap32 = function swap32() {\n          var len = this.length;\n\n          if (len % 4 !== 0) {\n            throw new RangeError('Buffer size must be a multiple of 32-bits');\n          }\n\n          for (var i = 0; i < len; i += 4) {\n            swap(this, i, i + 3);\n            swap(this, i + 1, i + 2);\n          }\n\n          return this;\n        };\n\n        Buffer.prototype.swap64 = function swap64() {\n          var len = this.length;\n\n          if (len % 8 !== 0) {\n            throw new RangeError('Buffer size must be a multiple of 64-bits');\n          }\n\n          for (var i = 0; i < len; i += 8) {\n            swap(this, i, i + 7);\n            swap(this, i + 1, i + 6);\n            swap(this, i + 2, i + 5);\n            swap(this, i + 3, i + 4);\n          }\n\n          return this;\n        };\n\n        Buffer.prototype.toString = function toString() {\n          var length = this.length | 0;\n          if (length === 0) return '';\n          if (arguments.length === 0) return utf8Slice(this, 0, length);\n          return slowToString.apply(this, arguments);\n        };\n\n        Buffer.prototype.equals = function equals(b) {\n          if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');\n          if (this === b) return true;\n          return Buffer.compare(this, b) === 0;\n        };\n\n        Buffer.prototype.inspect = function inspect() {\n          var str = '';\n          var max = exports.INSPECT_MAX_BYTES;\n\n          if (this.length > 0) {\n            str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n            if (this.length > max) str += ' ... ';\n          }\n\n          return '<Buffer ' + str + '>';\n        };\n\n        Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n          if (!Buffer.isBuffer(target)) {\n            throw new TypeError('Argument must be a Buffer');\n          }\n\n          if (start === undefined) {\n            start = 0;\n          }\n\n          if (end === undefined) {\n            end = target ? target.length : 0;\n          }\n\n          if (thisStart === undefined) {\n            thisStart = 0;\n          }\n\n          if (thisEnd === undefined) {\n            thisEnd = this.length;\n          }\n\n          if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n            throw new RangeError('out of range index');\n          }\n\n          if (thisStart >= thisEnd && start >= end) {\n            return 0;\n          }\n\n          if (thisStart >= thisEnd) {\n            return -1;\n          }\n\n          if (start >= end) {\n            return 1;\n          }\n\n          start >>>= 0;\n          end >>>= 0;\n          thisStart >>>= 0;\n          thisEnd >>>= 0;\n          if (this === target) return 0;\n          var x = thisEnd - thisStart;\n          var y = end - start;\n          var len = Math.min(x, y);\n          var thisCopy = this.slice(thisStart, thisEnd);\n          var targetCopy = target.slice(start, end);\n\n          for (var i = 0; i < len; ++i) {\n            if (thisCopy[i] !== targetCopy[i]) {\n              x = thisCopy[i];\n              y = targetCopy[i];\n              break;\n            }\n          }\n\n          if (x < y) return -1;\n          if (y < x) return 1;\n          return 0;\n        }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n        // OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n        //\n        // Arguments:\n        // - buffer - a Buffer to search\n        // - val - a string, Buffer, or number\n        // - byteOffset - an index into `buffer`; will be clamped to an int32\n        // - encoding - an optional encoding, relevant is val is a string\n        // - dir - true for indexOf, false for lastIndexOf\n\n\n        function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n          // Empty buffer means no match\n          if (buffer.length === 0) return -1; // Normalize byteOffset\n\n          if (typeof byteOffset === 'string') {\n            encoding = byteOffset;\n            byteOffset = 0;\n          } else if (byteOffset > 0x7fffffff) {\n            byteOffset = 0x7fffffff;\n          } else if (byteOffset < -0x80000000) {\n            byteOffset = -0x80000000;\n          }\n\n          byteOffset = +byteOffset; // Coerce to Number.\n\n          if (isNaN(byteOffset)) {\n            // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n            byteOffset = dir ? 0 : buffer.length - 1;\n          } // Normalize byteOffset: negative offsets start from the end of the buffer\n\n\n          if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n\n          if (byteOffset >= buffer.length) {\n            if (dir) return -1;else byteOffset = buffer.length - 1;\n          } else if (byteOffset < 0) {\n            if (dir) byteOffset = 0;else return -1;\n          } // Normalize val\n\n\n          if (typeof val === 'string') {\n            val = Buffer.from(val, encoding);\n          } // Finally, search either indexOf (if dir is true) or lastIndexOf\n\n\n          if (Buffer.isBuffer(val)) {\n            // Special case: looking for empty string/buffer always fails\n            if (val.length === 0) {\n              return -1;\n            }\n\n            return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n          } else if (typeof val === 'number') {\n            val = val & 0xFF; // Search for a byte value [0-255]\n\n            if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {\n              if (dir) {\n                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n              } else {\n                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n              }\n            }\n\n            return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n          }\n\n          throw new TypeError('val must be string, number or Buffer');\n        }\n\n        function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n          var indexSize = 1;\n          var arrLength = arr.length;\n          var valLength = val.length;\n\n          if (encoding !== undefined) {\n            encoding = String(encoding).toLowerCase();\n\n            if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {\n              if (arr.length < 2 || val.length < 2) {\n                return -1;\n              }\n\n              indexSize = 2;\n              arrLength /= 2;\n              valLength /= 2;\n              byteOffset /= 2;\n            }\n          }\n\n          function read(buf, i) {\n            if (indexSize === 1) {\n              return buf[i];\n            } else {\n              return buf.readUInt16BE(i * indexSize);\n            }\n          }\n\n          var i;\n\n          if (dir) {\n            var foundIndex = -1;\n\n            for (i = byteOffset; i < arrLength; i++) {\n              if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n                if (foundIndex === -1) foundIndex = i;\n                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n              } else {\n                if (foundIndex !== -1) i -= i - foundIndex;\n                foundIndex = -1;\n              }\n            }\n          } else {\n            if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n\n            for (i = byteOffset; i >= 0; i--) {\n              var found = true;\n\n              for (var j = 0; j < valLength; j++) {\n                if (read(arr, i + j) !== read(val, j)) {\n                  found = false;\n                  break;\n                }\n              }\n\n              if (found) return i;\n            }\n          }\n\n          return -1;\n        }\n\n        Buffer.prototype.includes = function includes(val, byteOffset, encoding) {\n          return this.indexOf(val, byteOffset, encoding) !== -1;\n        };\n\n        Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n          return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n        };\n\n        Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n          return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n        };\n\n        function hexWrite(buf, string, offset, length) {\n          offset = Number(offset) || 0;\n          var remaining = buf.length - offset;\n\n          if (!length) {\n            length = remaining;\n          } else {\n            length = Number(length);\n\n            if (length > remaining) {\n              length = remaining;\n            }\n          } // must be an even number of digits\n\n\n          var strLen = string.length;\n          if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');\n\n          if (length > strLen / 2) {\n            length = strLen / 2;\n          }\n\n          for (var i = 0; i < length; ++i) {\n            var parsed = parseInt(string.substr(i * 2, 2), 16);\n            if (isNaN(parsed)) return i;\n            buf[offset + i] = parsed;\n          }\n\n          return i;\n        }\n\n        function utf8Write(buf, string, offset, length) {\n          return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n        }\n\n        function asciiWrite(buf, string, offset, length) {\n          return blitBuffer(asciiToBytes(string), buf, offset, length);\n        }\n\n        function latin1Write(buf, string, offset, length) {\n          return asciiWrite(buf, string, offset, length);\n        }\n\n        function base64Write(buf, string, offset, length) {\n          return blitBuffer(base64ToBytes(string), buf, offset, length);\n        }\n\n        function ucs2Write(buf, string, offset, length) {\n          return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n        }\n\n        Buffer.prototype.write = function write(string, offset, length, encoding) {\n          // Buffer#write(string)\n          if (offset === undefined) {\n            encoding = 'utf8';\n            length = this.length;\n            offset = 0; // Buffer#write(string, encoding)\n          } else if (length === undefined && typeof offset === 'string') {\n            encoding = offset;\n            length = this.length;\n            offset = 0; // Buffer#write(string, offset[, length][, encoding])\n          } else if (isFinite(offset)) {\n            offset = offset | 0;\n\n            if (isFinite(length)) {\n              length = length | 0;\n              if (encoding === undefined) encoding = 'utf8';\n            } else {\n              encoding = length;\n              length = undefined;\n            } // legacy write(string, encoding, offset, length) - remove in v0.13\n\n          } else {\n            throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n          }\n\n          var remaining = this.length - offset;\n          if (length === undefined || length > remaining) length = remaining;\n\n          if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n            throw new RangeError('Attempt to write outside buffer bounds');\n          }\n\n          if (!encoding) encoding = 'utf8';\n          var loweredCase = false;\n\n          for (;;) {\n            switch (encoding) {\n              case 'hex':\n                return hexWrite(this, string, offset, length);\n\n              case 'utf8':\n              case 'utf-8':\n                return utf8Write(this, string, offset, length);\n\n              case 'ascii':\n                return asciiWrite(this, string, offset, length);\n\n              case 'latin1':\n              case 'binary':\n                return latin1Write(this, string, offset, length);\n\n              case 'base64':\n                // Warning: maxLength not taken into account in base64Write\n                return base64Write(this, string, offset, length);\n\n              case 'ucs2':\n              case 'ucs-2':\n              case 'utf16le':\n              case 'utf-16le':\n                return ucs2Write(this, string, offset, length);\n\n              default:\n                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n                encoding = ('' + encoding).toLowerCase();\n                loweredCase = true;\n            }\n          }\n        };\n\n        Buffer.prototype.toJSON = function toJSON() {\n          return {\n            type: 'Buffer',\n            data: Array.prototype.slice.call(this._arr || this, 0)\n          };\n        };\n\n        function base64Slice(buf, start, end) {\n          if (start === 0 && end === buf.length) {\n            return base64.fromByteArray(buf);\n          } else {\n            return base64.fromByteArray(buf.slice(start, end));\n          }\n        }\n\n        function utf8Slice(buf, start, end) {\n          end = Math.min(buf.length, end);\n          var res = [];\n          var i = start;\n\n          while (i < end) {\n            var firstByte = buf[i];\n            var codePoint = null;\n            var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n\n            if (i + bytesPerSequence <= end) {\n              var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n              switch (bytesPerSequence) {\n                case 1:\n                  if (firstByte < 0x80) {\n                    codePoint = firstByte;\n                  }\n\n                  break;\n\n                case 2:\n                  secondByte = buf[i + 1];\n\n                  if ((secondByte & 0xC0) === 0x80) {\n                    tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n\n                    if (tempCodePoint > 0x7F) {\n                      codePoint = tempCodePoint;\n                    }\n                  }\n\n                  break;\n\n                case 3:\n                  secondByte = buf[i + 1];\n                  thirdByte = buf[i + 2];\n\n                  if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                    tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n\n                    if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n                      codePoint = tempCodePoint;\n                    }\n                  }\n\n                  break;\n\n                case 4:\n                  secondByte = buf[i + 1];\n                  thirdByte = buf[i + 2];\n                  fourthByte = buf[i + 3];\n\n                  if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                    tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n\n                    if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n                      codePoint = tempCodePoint;\n                    }\n                  }\n\n              }\n            }\n\n            if (codePoint === null) {\n              // we did not generate a valid codePoint so insert a\n              // replacement char (U+FFFD) and advance only 1 byte\n              codePoint = 0xFFFD;\n              bytesPerSequence = 1;\n            } else if (codePoint > 0xFFFF) {\n              // encode to utf16 (surrogate pair dance)\n              codePoint -= 0x10000;\n              res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n              codePoint = 0xDC00 | codePoint & 0x3FF;\n            }\n\n            res.push(codePoint);\n            i += bytesPerSequence;\n          }\n\n          return decodeCodePointsArray(res);\n        } // Based on http://stackoverflow.com/a/22747272/680742, the browser with\n        // the lowest limit is Chrome, with 0x10000 args.\n        // We go 1 magnitude less, for safety\n\n\n        var MAX_ARGUMENTS_LENGTH = 0x1000;\n\n        function decodeCodePointsArray(codePoints) {\n          var len = codePoints.length;\n\n          if (len <= MAX_ARGUMENTS_LENGTH) {\n            return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n          } // Decode in chunks to avoid \"call stack size exceeded\".\n\n\n          var res = '';\n          var i = 0;\n\n          while (i < len) {\n            res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n          }\n\n          return res;\n        }\n\n        function asciiSlice(buf, start, end) {\n          var ret = '';\n          end = Math.min(buf.length, end);\n\n          for (var i = start; i < end; ++i) {\n            ret += String.fromCharCode(buf[i] & 0x7F);\n          }\n\n          return ret;\n        }\n\n        function latin1Slice(buf, start, end) {\n          var ret = '';\n          end = Math.min(buf.length, end);\n\n          for (var i = start; i < end; ++i) {\n            ret += String.fromCharCode(buf[i]);\n          }\n\n          return ret;\n        }\n\n        function hexSlice(buf, start, end) {\n          var len = buf.length;\n          if (!start || start < 0) start = 0;\n          if (!end || end < 0 || end > len) end = len;\n          var out = '';\n\n          for (var i = start; i < end; ++i) {\n            out += toHex(buf[i]);\n          }\n\n          return out;\n        }\n\n        function utf16leSlice(buf, start, end) {\n          var bytes = buf.slice(start, end);\n          var res = '';\n\n          for (var i = 0; i < bytes.length; i += 2) {\n            res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n          }\n\n          return res;\n        }\n\n        Buffer.prototype.slice = function slice(start, end) {\n          var len = this.length;\n          start = ~~start;\n          end = end === undefined ? len : ~~end;\n\n          if (start < 0) {\n            start += len;\n            if (start < 0) start = 0;\n          } else if (start > len) {\n            start = len;\n          }\n\n          if (end < 0) {\n            end += len;\n            if (end < 0) end = 0;\n          } else if (end > len) {\n            end = len;\n          }\n\n          if (end < start) end = start;\n          var newBuf;\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            newBuf = this.subarray(start, end);\n            newBuf.__proto__ = Buffer.prototype;\n          } else {\n            var sliceLen = end - start;\n            newBuf = new Buffer(sliceLen, undefined);\n\n            for (var i = 0; i < sliceLen; ++i) {\n              newBuf[i] = this[i + start];\n            }\n          }\n\n          return newBuf;\n        };\n        /*\n         * Need to make sure that buffer isn't trying to write out of bounds.\n         */\n\n\n        function checkOffset(offset, ext, length) {\n          if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n          if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n        }\n\n        Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n          offset = offset | 0;\n          byteLength = byteLength | 0;\n          if (!noAssert) checkOffset(offset, byteLength, this.length);\n          var val = this[offset];\n          var mul = 1;\n          var i = 0;\n\n          while (++i < byteLength && (mul *= 0x100)) {\n            val += this[offset + i] * mul;\n          }\n\n          return val;\n        };\n\n        Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n          offset = offset | 0;\n          byteLength = byteLength | 0;\n\n          if (!noAssert) {\n            checkOffset(offset, byteLength, this.length);\n          }\n\n          var val = this[offset + --byteLength];\n          var mul = 1;\n\n          while (byteLength > 0 && (mul *= 0x100)) {\n            val += this[offset + --byteLength] * mul;\n          }\n\n          return val;\n        };\n\n        Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 1, this.length);\n          return this[offset];\n        };\n\n        Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 2, this.length);\n          return this[offset] | this[offset + 1] << 8;\n        };\n\n        Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 2, this.length);\n          return this[offset] << 8 | this[offset + 1];\n        };\n\n        Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 4, this.length);\n          return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n        };\n\n        Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 4, this.length);\n          return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n        };\n\n        Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n          offset = offset | 0;\n          byteLength = byteLength | 0;\n          if (!noAssert) checkOffset(offset, byteLength, this.length);\n          var val = this[offset];\n          var mul = 1;\n          var i = 0;\n\n          while (++i < byteLength && (mul *= 0x100)) {\n            val += this[offset + i] * mul;\n          }\n\n          mul *= 0x80;\n          if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n          return val;\n        };\n\n        Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n          offset = offset | 0;\n          byteLength = byteLength | 0;\n          if (!noAssert) checkOffset(offset, byteLength, this.length);\n          var i = byteLength;\n          var mul = 1;\n          var val = this[offset + --i];\n\n          while (i > 0 && (mul *= 0x100)) {\n            val += this[offset + --i] * mul;\n          }\n\n          mul *= 0x80;\n          if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n          return val;\n        };\n\n        Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 1, this.length);\n          if (!(this[offset] & 0x80)) return this[offset];\n          return (0xff - this[offset] + 1) * -1;\n        };\n\n        Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 2, this.length);\n          var val = this[offset] | this[offset + 1] << 8;\n          return val & 0x8000 ? val | 0xFFFF0000 : val;\n        };\n\n        Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 2, this.length);\n          var val = this[offset + 1] | this[offset] << 8;\n          return val & 0x8000 ? val | 0xFFFF0000 : val;\n        };\n\n        Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 4, this.length);\n          return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n        };\n\n        Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 4, this.length);\n          return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n        };\n\n        Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 4, this.length);\n          return ieee754.read(this, offset, true, 23, 4);\n        };\n\n        Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 4, this.length);\n          return ieee754.read(this, offset, false, 23, 4);\n        };\n\n        Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 8, this.length);\n          return ieee754.read(this, offset, true, 52, 8);\n        };\n\n        Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 8, this.length);\n          return ieee754.read(this, offset, false, 52, 8);\n        };\n\n        function checkInt(buf, value, offset, ext, max, min) {\n          if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n          if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n          if (offset + ext > buf.length) throw new RangeError('Index out of range');\n        }\n\n        Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          byteLength = byteLength | 0;\n\n          if (!noAssert) {\n            var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n            checkInt(this, value, offset, byteLength, maxBytes, 0);\n          }\n\n          var mul = 1;\n          var i = 0;\n          this[offset] = value & 0xFF;\n\n          while (++i < byteLength && (mul *= 0x100)) {\n            this[offset + i] = value / mul & 0xFF;\n          }\n\n          return offset + byteLength;\n        };\n\n        Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          byteLength = byteLength | 0;\n\n          if (!noAssert) {\n            var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n            checkInt(this, value, offset, byteLength, maxBytes, 0);\n          }\n\n          var i = byteLength - 1;\n          var mul = 1;\n          this[offset + i] = value & 0xFF;\n\n          while (--i >= 0 && (mul *= 0x100)) {\n            this[offset + i] = value / mul & 0xFF;\n          }\n\n          return offset + byteLength;\n        };\n\n        Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n          if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n          this[offset] = value & 0xff;\n          return offset + 1;\n        };\n\n        function objectWriteUInt16(buf, value, offset, littleEndian) {\n          if (value < 0) value = 0xffff + value + 1;\n\n          for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n            buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;\n          }\n        }\n\n        Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            this[offset] = value & 0xff;\n            this[offset + 1] = value >>> 8;\n          } else {\n            objectWriteUInt16(this, value, offset, true);\n          }\n\n          return offset + 2;\n        };\n\n        Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            this[offset] = value >>> 8;\n            this[offset + 1] = value & 0xff;\n          } else {\n            objectWriteUInt16(this, value, offset, false);\n          }\n\n          return offset + 2;\n        };\n\n        function objectWriteUInt32(buf, value, offset, littleEndian) {\n          if (value < 0) value = 0xffffffff + value + 1;\n\n          for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n            buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;\n          }\n        }\n\n        Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            this[offset + 3] = value >>> 24;\n            this[offset + 2] = value >>> 16;\n            this[offset + 1] = value >>> 8;\n            this[offset] = value & 0xff;\n          } else {\n            objectWriteUInt32(this, value, offset, true);\n          }\n\n          return offset + 4;\n        };\n\n        Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            this[offset] = value >>> 24;\n            this[offset + 1] = value >>> 16;\n            this[offset + 2] = value >>> 8;\n            this[offset + 3] = value & 0xff;\n          } else {\n            objectWriteUInt32(this, value, offset, false);\n          }\n\n          return offset + 4;\n        };\n\n        Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n          value = +value;\n          offset = offset | 0;\n\n          if (!noAssert) {\n            var limit = Math.pow(2, 8 * byteLength - 1);\n            checkInt(this, value, offset, byteLength, limit - 1, -limit);\n          }\n\n          var i = 0;\n          var mul = 1;\n          var sub = 0;\n          this[offset] = value & 0xFF;\n\n          while (++i < byteLength && (mul *= 0x100)) {\n            if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n              sub = 1;\n            }\n\n            this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n          }\n\n          return offset + byteLength;\n        };\n\n        Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n          value = +value;\n          offset = offset | 0;\n\n          if (!noAssert) {\n            var limit = Math.pow(2, 8 * byteLength - 1);\n            checkInt(this, value, offset, byteLength, limit - 1, -limit);\n          }\n\n          var i = byteLength - 1;\n          var mul = 1;\n          var sub = 0;\n          this[offset + i] = value & 0xFF;\n\n          while (--i >= 0 && (mul *= 0x100)) {\n            if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n              sub = 1;\n            }\n\n            this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n          }\n\n          return offset + byteLength;\n        };\n\n        Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n          if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n          if (value < 0) value = 0xff + value + 1;\n          this[offset] = value & 0xff;\n          return offset + 1;\n        };\n\n        Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            this[offset] = value & 0xff;\n            this[offset + 1] = value >>> 8;\n          } else {\n            objectWriteUInt16(this, value, offset, true);\n          }\n\n          return offset + 2;\n        };\n\n        Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            this[offset] = value >>> 8;\n            this[offset + 1] = value & 0xff;\n          } else {\n            objectWriteUInt16(this, value, offset, false);\n          }\n\n          return offset + 2;\n        };\n\n        Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            this[offset] = value & 0xff;\n            this[offset + 1] = value >>> 8;\n            this[offset + 2] = value >>> 16;\n            this[offset + 3] = value >>> 24;\n          } else {\n            objectWriteUInt32(this, value, offset, true);\n          }\n\n          return offset + 4;\n        };\n\n        Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n          if (value < 0) value = 0xffffffff + value + 1;\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            this[offset] = value >>> 24;\n            this[offset + 1] = value >>> 16;\n            this[offset + 2] = value >>> 8;\n            this[offset + 3] = value & 0xff;\n          } else {\n            objectWriteUInt32(this, value, offset, false);\n          }\n\n          return offset + 4;\n        };\n\n        function checkIEEE754(buf, value, offset, ext, max, min) {\n          if (offset + ext > buf.length) throw new RangeError('Index out of range');\n          if (offset < 0) throw new RangeError('Index out of range');\n        }\n\n        function writeFloat(buf, value, offset, littleEndian, noAssert) {\n          if (!noAssert) {\n            checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);\n          }\n\n          ieee754.write(buf, value, offset, littleEndian, 23, 4);\n          return offset + 4;\n        }\n\n        Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n          return writeFloat(this, value, offset, true, noAssert);\n        };\n\n        Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n          return writeFloat(this, value, offset, false, noAssert);\n        };\n\n        function writeDouble(buf, value, offset, littleEndian, noAssert) {\n          if (!noAssert) {\n            checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);\n          }\n\n          ieee754.write(buf, value, offset, littleEndian, 52, 8);\n          return offset + 8;\n        }\n\n        Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n          return writeDouble(this, value, offset, true, noAssert);\n        };\n\n        Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n          return writeDouble(this, value, offset, false, noAssert);\n        }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\n\n        Buffer.prototype.copy = function copy(target, targetStart, start, end) {\n          if (!start) start = 0;\n          if (!end && end !== 0) end = this.length;\n          if (targetStart >= target.length) targetStart = target.length;\n          if (!targetStart) targetStart = 0;\n          if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done\n\n          if (end === start) return 0;\n          if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions\n\n          if (targetStart < 0) {\n            throw new RangeError('targetStart out of bounds');\n          }\n\n          if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');\n          if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?\n\n          if (end > this.length) end = this.length;\n\n          if (target.length - targetStart < end - start) {\n            end = target.length - targetStart + start;\n          }\n\n          var len = end - start;\n          var i;\n\n          if (this === target && start < targetStart && targetStart < end) {\n            // descending copy from end\n            for (i = len - 1; i >= 0; --i) {\n              target[i + targetStart] = this[i + start];\n            }\n          } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n            // ascending copy from start\n            for (i = 0; i < len; ++i) {\n              target[i + targetStart] = this[i + start];\n            }\n          } else {\n            Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);\n          }\n\n          return len;\n        }; // Usage:\n        //    buffer.fill(number[, offset[, end]])\n        //    buffer.fill(buffer[, offset[, end]])\n        //    buffer.fill(string[, offset[, end]][, encoding])\n\n\n        Buffer.prototype.fill = function fill(val, start, end, encoding) {\n          // Handle string cases:\n          if (typeof val === 'string') {\n            if (typeof start === 'string') {\n              encoding = start;\n              start = 0;\n              end = this.length;\n            } else if (typeof end === 'string') {\n              encoding = end;\n              end = this.length;\n            }\n\n            if (val.length === 1) {\n              var code = val.charCodeAt(0);\n\n              if (code < 256) {\n                val = code;\n              }\n            }\n\n            if (encoding !== undefined && typeof encoding !== 'string') {\n              throw new TypeError('encoding must be a string');\n            }\n\n            if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n              throw new TypeError('Unknown encoding: ' + encoding);\n            }\n          } else if (typeof val === 'number') {\n            val = val & 255;\n          } // Invalid ranges are not set to a default, so can range check early.\n\n\n          if (start < 0 || this.length < start || this.length < end) {\n            throw new RangeError('Out of range index');\n          }\n\n          if (end <= start) {\n            return this;\n          }\n\n          start = start >>> 0;\n          end = end === undefined ? this.length : end >>> 0;\n          if (!val) val = 0;\n          var i;\n\n          if (typeof val === 'number') {\n            for (i = start; i < end; ++i) {\n              this[i] = val;\n            }\n          } else {\n            var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());\n            var len = bytes.length;\n\n            for (i = 0; i < end - start; ++i) {\n              this[i + start] = bytes[i % len];\n            }\n          }\n\n          return this;\n        }; // HELPER FUNCTIONS\n        // ================\n\n\n        var INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n\n        function base64clean(str) {\n          // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n          str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''\n\n          if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\n          while (str.length % 4 !== 0) {\n            str = str + '=';\n          }\n\n          return str;\n        }\n\n        function stringtrim(str) {\n          if (str.trim) return str.trim();\n          return str.replace(/^\\s+|\\s+$/g, '');\n        }\n\n        function toHex(n) {\n          if (n < 16) return '0' + n.toString(16);\n          return n.toString(16);\n        }\n\n        function utf8ToBytes(string, units) {\n          units = units || Infinity;\n          var codePoint;\n          var length = string.length;\n          var leadSurrogate = null;\n          var bytes = [];\n\n          for (var i = 0; i < length; ++i) {\n            codePoint = string.charCodeAt(i); // is surrogate component\n\n            if (codePoint > 0xD7FF && codePoint < 0xE000) {\n              // last char was a lead\n              if (!leadSurrogate) {\n                // no lead yet\n                if (codePoint > 0xDBFF) {\n                  // unexpected trail\n                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                  continue;\n                } else if (i + 1 === length) {\n                  // unpaired lead\n                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                  continue;\n                } // valid lead\n\n\n                leadSurrogate = codePoint;\n                continue;\n              } // 2 leads in a row\n\n\n              if (codePoint < 0xDC00) {\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                leadSurrogate = codePoint;\n                continue;\n              } // valid surrogate pair\n\n\n              codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n            } else if (leadSurrogate) {\n              // valid bmp char, but last char was a lead\n              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n            }\n\n            leadSurrogate = null; // encode utf8\n\n            if (codePoint < 0x80) {\n              if ((units -= 1) < 0) break;\n              bytes.push(codePoint);\n            } else if (codePoint < 0x800) {\n              if ((units -= 2) < 0) break;\n              bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n            } else if (codePoint < 0x10000) {\n              if ((units -= 3) < 0) break;\n              bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n            } else if (codePoint < 0x110000) {\n              if ((units -= 4) < 0) break;\n              bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n            } else {\n              throw new Error('Invalid code point');\n            }\n          }\n\n          return bytes;\n        }\n\n        function asciiToBytes(str) {\n          var byteArray = [];\n\n          for (var i = 0; i < str.length; ++i) {\n            // Node's code seems to be doing this and not & 0x7F..\n            byteArray.push(str.charCodeAt(i) & 0xFF);\n          }\n\n          return byteArray;\n        }\n\n        function utf16leToBytes(str, units) {\n          var c, hi, lo;\n          var byteArray = [];\n\n          for (var i = 0; i < str.length; ++i) {\n            if ((units -= 2) < 0) break;\n            c = str.charCodeAt(i);\n            hi = c >> 8;\n            lo = c % 256;\n            byteArray.push(lo);\n            byteArray.push(hi);\n          }\n\n          return byteArray;\n        }\n\n        function base64ToBytes(str) {\n          return base64.toByteArray(base64clean(str));\n        }\n\n        function blitBuffer(src, dst, offset, length) {\n          for (var i = 0; i < length; ++i) {\n            if (i + offset >= dst.length || i >= src.length) break;\n            dst[i + offset] = src[i];\n          }\n\n          return i;\n        }\n\n        function isnan(val) {\n          return val !== val; // eslint-disable-line no-self-compare\n        }\n      }).call(this);\n    }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"buffer\").Buffer);\n  }, {\n    \"base64-js\": 78,\n    \"buffer\": 81,\n    \"ieee754\": 83,\n    \"isarray\": 84\n  }],\n  82: [function (require, module, exports) {\n    // Copyright Joyent, Inc. and other Node contributors.\n    //\n    // Permission is hereby granted, free of charge, to any person obtaining a\n    // copy of this software and associated documentation files (the\n    // \"Software\"), to deal in the Software without restriction, including\n    // without limitation the rights to use, copy, modify, merge, publish,\n    // distribute, sublicense, and/or sell copies of the Software, and to permit\n    // persons to whom the Software is furnished to do so, subject to the\n    // following conditions:\n    //\n    // The above copyright notice and this permission notice shall be included\n    // in all copies or substantial portions of the Software.\n    //\n    // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n    // USE OR OTHER DEALINGS IN THE SOFTWARE.\n    function EventEmitter() {\n      this._events = this._events || {};\n      this._maxListeners = this._maxListeners || undefined;\n    }\n\n    module.exports = EventEmitter; // Backwards-compat with node 0.10.x\n\n    EventEmitter.EventEmitter = EventEmitter;\n    EventEmitter.prototype._events = undefined;\n    EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are\n    // added to it. This is a useful default which helps finding memory leaks.\n\n    EventEmitter.defaultMaxListeners = 10; // Obviously not all Emitters should be limited to 10. This function allows\n    // that to be increased. Set to zero for unlimited.\n\n    EventEmitter.prototype.setMaxListeners = function (n) {\n      if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');\n      this._maxListeners = n;\n      return this;\n    };\n\n    EventEmitter.prototype.emit = function (type) {\n      var er, handler, len, args, i, listeners;\n      if (!this._events) this._events = {}; // If there is no 'error' event listener then throw.\n\n      if (type === 'error') {\n        if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {\n          er = arguments[1];\n\n          if (er instanceof Error) {\n            throw er; // Unhandled 'error' event\n          } else {\n            // At least give some kind of context to the user\n            var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n            err.context = er;\n            throw err;\n          }\n        }\n      }\n\n      handler = this._events[type];\n      if (isUndefined(handler)) return false;\n\n      if (isFunction(handler)) {\n        switch (arguments.length) {\n          // fast cases\n          case 1:\n            handler.call(this);\n            break;\n\n          case 2:\n            handler.call(this, arguments[1]);\n            break;\n\n          case 3:\n            handler.call(this, arguments[1], arguments[2]);\n            break;\n          // slower\n\n          default:\n            args = Array.prototype.slice.call(arguments, 1);\n            handler.apply(this, args);\n        }\n      } else if (isObject(handler)) {\n        args = Array.prototype.slice.call(arguments, 1);\n        listeners = handler.slice();\n        len = listeners.length;\n\n        for (i = 0; i < len; i++) listeners[i].apply(this, args);\n      }\n\n      return true;\n    };\n\n    EventEmitter.prototype.addListener = function (type, listener) {\n      var m;\n      if (!isFunction(listener)) throw TypeError('listener must be a function');\n      if (!this._events) this._events = {}; // To avoid recursion in the case that type === \"newListener\"! Before\n      // adding it to the listeners, first emit \"newListener\".\n\n      if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);\n      if (!this._events[type]) // Optimize the case of one listener. Don't need the extra array object.\n        this._events[type] = listener;else if (isObject(this._events[type])) // If we've already got an array, just append.\n        this._events[type].push(listener);else // Adding the second element, need to change to array.\n        this._events[type] = [this._events[type], listener]; // Check for listener leak\n\n      if (isObject(this._events[type]) && !this._events[type].warned) {\n        if (!isUndefined(this._maxListeners)) {\n          m = this._maxListeners;\n        } else {\n          m = EventEmitter.defaultMaxListeners;\n        }\n\n        if (m && m > 0 && this._events[type].length > m) {\n          this._events[type].warned = true;\n          console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);\n\n          if (typeof console.trace === 'function') {\n            // not supported in IE 10\n            console.trace();\n          }\n        }\n      }\n\n      return this;\n    };\n\n    EventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n    EventEmitter.prototype.once = function (type, listener) {\n      if (!isFunction(listener)) throw TypeError('listener must be a function');\n      var fired = false;\n\n      function g() {\n        this.removeListener(type, g);\n\n        if (!fired) {\n          fired = true;\n          listener.apply(this, arguments);\n        }\n      }\n\n      g.listener = listener;\n      this.on(type, g);\n      return this;\n    }; // emits a 'removeListener' event iff the listener was removed\n\n\n    EventEmitter.prototype.removeListener = function (type, listener) {\n      var list, position, length, i;\n      if (!isFunction(listener)) throw TypeError('listener must be a function');\n      if (!this._events || !this._events[type]) return this;\n      list = this._events[type];\n      length = list.length;\n      position = -1;\n\n      if (list === listener || isFunction(list.listener) && list.listener === listener) {\n        delete this._events[type];\n        if (this._events.removeListener) this.emit('removeListener', type, listener);\n      } else if (isObject(list)) {\n        for (i = length; i-- > 0;) {\n          if (list[i] === listener || list[i].listener && list[i].listener === listener) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0) return this;\n\n        if (list.length === 1) {\n          list.length = 0;\n          delete this._events[type];\n        } else {\n          list.splice(position, 1);\n        }\n\n        if (this._events.removeListener) this.emit('removeListener', type, listener);\n      }\n\n      return this;\n    };\n\n    EventEmitter.prototype.removeAllListeners = function (type) {\n      var key, listeners;\n      if (!this._events) return this; // not listening for removeListener, no need to emit\n\n      if (!this._events.removeListener) {\n        if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];\n        return this;\n      } // emit removeListener for all listeners on all events\n\n\n      if (arguments.length === 0) {\n        for (key in this._events) {\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n\n        this.removeAllListeners('removeListener');\n        this._events = {};\n        return this;\n      }\n\n      listeners = this._events[type];\n\n      if (isFunction(listeners)) {\n        this.removeListener(type, listeners);\n      } else if (listeners) {\n        // LIFO order\n        while (listeners.length) this.removeListener(type, listeners[listeners.length - 1]);\n      }\n\n      delete this._events[type];\n      return this;\n    };\n\n    EventEmitter.prototype.listeners = function (type) {\n      var ret;\n      if (!this._events || !this._events[type]) ret = [];else if (isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();\n      return ret;\n    };\n\n    EventEmitter.prototype.listenerCount = function (type) {\n      if (this._events) {\n        var evlistener = this._events[type];\n        if (isFunction(evlistener)) return 1;else if (evlistener) return evlistener.length;\n      }\n\n      return 0;\n    };\n\n    EventEmitter.listenerCount = function (emitter, type) {\n      return emitter.listenerCount(type);\n    };\n\n    function isFunction(arg) {\n      return typeof arg === 'function';\n    }\n\n    function isNumber(arg) {\n      return typeof arg === 'number';\n    }\n\n    function isObject(arg) {\n      return typeof arg === 'object' && arg !== null;\n    }\n\n    function isUndefined(arg) {\n      return arg === void 0;\n    }\n  }, {}],\n  83: [function (require, module, exports) {\n    exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n      var e, m;\n      var eLen = nBytes * 8 - mLen - 1;\n      var eMax = (1 << eLen) - 1;\n      var eBias = eMax >> 1;\n      var nBits = -7;\n      var i = isLE ? nBytes - 1 : 0;\n      var d = isLE ? -1 : 1;\n      var s = buffer[offset + i];\n      i += d;\n      e = s & (1 << -nBits) - 1;\n      s >>= -nBits;\n      nBits += eLen;\n\n      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n      m = e & (1 << -nBits) - 1;\n      e >>= -nBits;\n      nBits += mLen;\n\n      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n      if (e === 0) {\n        e = 1 - eBias;\n      } else if (e === eMax) {\n        return m ? NaN : (s ? -1 : 1) * Infinity;\n      } else {\n        m = m + Math.pow(2, mLen);\n        e = e - eBias;\n      }\n\n      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n    };\n\n    exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n      var e, m, c;\n      var eLen = nBytes * 8 - mLen - 1;\n      var eMax = (1 << eLen) - 1;\n      var eBias = eMax >> 1;\n      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n      var i = isLE ? 0 : nBytes - 1;\n      var d = isLE ? 1 : -1;\n      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n      value = Math.abs(value);\n\n      if (isNaN(value) || value === Infinity) {\n        m = isNaN(value) ? 1 : 0;\n        e = eMax;\n      } else {\n        e = Math.floor(Math.log(value) / Math.LN2);\n\n        if (value * (c = Math.pow(2, -e)) < 1) {\n          e--;\n          c *= 2;\n        }\n\n        if (e + eBias >= 1) {\n          value += rt / c;\n        } else {\n          value += rt * Math.pow(2, 1 - eBias);\n        }\n\n        if (value * c >= 2) {\n          e++;\n          c /= 2;\n        }\n\n        if (e + eBias >= eMax) {\n          m = 0;\n          e = eMax;\n        } else if (e + eBias >= 1) {\n          m = (value * c - 1) * Math.pow(2, mLen);\n          e = e + eBias;\n        } else {\n          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n          e = 0;\n        }\n      }\n\n      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n      e = e << mLen | m;\n      eLen += mLen;\n\n      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n      buffer[offset + i - d] |= s * 128;\n    };\n  }, {}],\n  84: [function (require, module, exports) {\n    var toString = {}.toString;\n\n    module.exports = Array.isArray || function (arr) {\n      return toString.call(arr) == '[object Array]';\n    };\n  }, {}],\n  85: [function (require, module, exports) {\n    (function (exports) {\n      \"use strict\";\n\n      function isArray(obj) {\n        if (obj !== null) {\n          return Object.prototype.toString.call(obj) === \"[object Array]\";\n        } else {\n          return false;\n        }\n      }\n\n      function isObject(obj) {\n        if (obj !== null) {\n          return Object.prototype.toString.call(obj) === \"[object Object]\";\n        } else {\n          return false;\n        }\n      }\n\n      function strictDeepEqual(first, second) {\n        // Check the scalar case first.\n        if (first === second) {\n          return true;\n        } // Check if they are the same type.\n\n\n        var firstType = Object.prototype.toString.call(first);\n\n        if (firstType !== Object.prototype.toString.call(second)) {\n          return false;\n        } // We know that first and second have the same type so we can just check the\n        // first type from now on.\n\n\n        if (isArray(first) === true) {\n          // Short circuit if they're not the same length;\n          if (first.length !== second.length) {\n            return false;\n          }\n\n          for (var i = 0; i < first.length; i++) {\n            if (strictDeepEqual(first[i], second[i]) === false) {\n              return false;\n            }\n          }\n\n          return true;\n        }\n\n        if (isObject(first) === true) {\n          // An object is equal if it has the same key/value pairs.\n          var keysSeen = {};\n\n          for (var key in first) {\n            if (hasOwnProperty.call(first, key)) {\n              if (strictDeepEqual(first[key], second[key]) === false) {\n                return false;\n              }\n\n              keysSeen[key] = true;\n            }\n          } // Now check that there aren't any keys in second that weren't\n          // in first.\n\n\n          for (var key2 in second) {\n            if (hasOwnProperty.call(second, key2)) {\n              if (keysSeen[key2] !== true) {\n                return false;\n              }\n            }\n          }\n\n          return true;\n        }\n\n        return false;\n      }\n\n      function isFalse(obj) {\n        // From the spec:\n        // A false value corresponds to the following values:\n        // Empty list\n        // Empty object\n        // Empty string\n        // False boolean\n        // null value\n        // First check the scalar values.\n        if (obj === \"\" || obj === false || obj === null) {\n          return true;\n        } else if (isArray(obj) && obj.length === 0) {\n          // Check for an empty array.\n          return true;\n        } else if (isObject(obj)) {\n          // Check for an empty object.\n          for (var key in obj) {\n            // If there are any keys, then\n            // the object is not empty so the object\n            // is not false.\n            if (obj.hasOwnProperty(key)) {\n              return false;\n            }\n          }\n\n          return true;\n        } else {\n          return false;\n        }\n      }\n\n      function objValues(obj) {\n        var keys = Object.keys(obj);\n        var values = [];\n\n        for (var i = 0; i < keys.length; i++) {\n          values.push(obj[keys[i]]);\n        }\n\n        return values;\n      }\n\n      function merge(a, b) {\n        var merged = {};\n\n        for (var key in a) {\n          merged[key] = a[key];\n        }\n\n        for (var key2 in b) {\n          merged[key2] = b[key2];\n        }\n\n        return merged;\n      }\n\n      var trimLeft;\n\n      if (typeof String.prototype.trimLeft === \"function\") {\n        trimLeft = function (str) {\n          return str.trimLeft();\n        };\n      } else {\n        trimLeft = function (str) {\n          return str.match(/^\\s*(.*)/)[1];\n        };\n      } // Type constants used to define functions.\n\n\n      var TYPE_NUMBER = 0;\n      var TYPE_ANY = 1;\n      var TYPE_STRING = 2;\n      var TYPE_ARRAY = 3;\n      var TYPE_OBJECT = 4;\n      var TYPE_BOOLEAN = 5;\n      var TYPE_EXPREF = 6;\n      var TYPE_NULL = 7;\n      var TYPE_ARRAY_NUMBER = 8;\n      var TYPE_ARRAY_STRING = 9;\n      var TOK_EOF = \"EOF\";\n      var TOK_UNQUOTEDIDENTIFIER = \"UnquotedIdentifier\";\n      var TOK_QUOTEDIDENTIFIER = \"QuotedIdentifier\";\n      var TOK_RBRACKET = \"Rbracket\";\n      var TOK_RPAREN = \"Rparen\";\n      var TOK_COMMA = \"Comma\";\n      var TOK_COLON = \"Colon\";\n      var TOK_RBRACE = \"Rbrace\";\n      var TOK_NUMBER = \"Number\";\n      var TOK_CURRENT = \"Current\";\n      var TOK_EXPREF = \"Expref\";\n      var TOK_PIPE = \"Pipe\";\n      var TOK_OR = \"Or\";\n      var TOK_AND = \"And\";\n      var TOK_EQ = \"EQ\";\n      var TOK_GT = \"GT\";\n      var TOK_LT = \"LT\";\n      var TOK_GTE = \"GTE\";\n      var TOK_LTE = \"LTE\";\n      var TOK_NE = \"NE\";\n      var TOK_FLATTEN = \"Flatten\";\n      var TOK_STAR = \"Star\";\n      var TOK_FILTER = \"Filter\";\n      var TOK_DOT = \"Dot\";\n      var TOK_NOT = \"Not\";\n      var TOK_LBRACE = \"Lbrace\";\n      var TOK_LBRACKET = \"Lbracket\";\n      var TOK_LPAREN = \"Lparen\";\n      var TOK_LITERAL = \"Literal\"; // The \"&\", \"[\", \"<\", \">\" tokens\n      // are not in basicToken because\n      // there are two token variants\n      // (\"&&\", \"[?\", \"<=\", \">=\").  This is specially handled\n      // below.\n\n      var basicTokens = {\n        \".\": TOK_DOT,\n        \"*\": TOK_STAR,\n        \",\": TOK_COMMA,\n        \":\": TOK_COLON,\n        \"{\": TOK_LBRACE,\n        \"}\": TOK_RBRACE,\n        \"]\": TOK_RBRACKET,\n        \"(\": TOK_LPAREN,\n        \")\": TOK_RPAREN,\n        \"@\": TOK_CURRENT\n      };\n      var operatorStartToken = {\n        \"<\": true,\n        \">\": true,\n        \"=\": true,\n        \"!\": true\n      };\n      var skipChars = {\n        \" \": true,\n        \"\\t\": true,\n        \"\\n\": true\n      };\n\n      function isAlpha(ch) {\n        return ch >= \"a\" && ch <= \"z\" || ch >= \"A\" && ch <= \"Z\" || ch === \"_\";\n      }\n\n      function isNum(ch) {\n        return ch >= \"0\" && ch <= \"9\" || ch === \"-\";\n      }\n\n      function isAlphaNum(ch) {\n        return ch >= \"a\" && ch <= \"z\" || ch >= \"A\" && ch <= \"Z\" || ch >= \"0\" && ch <= \"9\" || ch === \"_\";\n      }\n\n      function Lexer() {}\n\n      Lexer.prototype = {\n        tokenize: function (stream) {\n          var tokens = [];\n          this._current = 0;\n          var start;\n          var identifier;\n          var token;\n\n          while (this._current < stream.length) {\n            if (isAlpha(stream[this._current])) {\n              start = this._current;\n              identifier = this._consumeUnquotedIdentifier(stream);\n              tokens.push({\n                type: TOK_UNQUOTEDIDENTIFIER,\n                value: identifier,\n                start: start\n              });\n            } else if (basicTokens[stream[this._current]] !== undefined) {\n              tokens.push({\n                type: basicTokens[stream[this._current]],\n                value: stream[this._current],\n                start: this._current\n              });\n              this._current++;\n            } else if (isNum(stream[this._current])) {\n              token = this._consumeNumber(stream);\n              tokens.push(token);\n            } else if (stream[this._current] === \"[\") {\n              // No need to increment this._current.  This happens\n              // in _consumeLBracket\n              token = this._consumeLBracket(stream);\n              tokens.push(token);\n            } else if (stream[this._current] === \"\\\"\") {\n              start = this._current;\n              identifier = this._consumeQuotedIdentifier(stream);\n              tokens.push({\n                type: TOK_QUOTEDIDENTIFIER,\n                value: identifier,\n                start: start\n              });\n            } else if (stream[this._current] === \"'\") {\n              start = this._current;\n              identifier = this._consumeRawStringLiteral(stream);\n              tokens.push({\n                type: TOK_LITERAL,\n                value: identifier,\n                start: start\n              });\n            } else if (stream[this._current] === \"`\") {\n              start = this._current;\n\n              var literal = this._consumeLiteral(stream);\n\n              tokens.push({\n                type: TOK_LITERAL,\n                value: literal,\n                start: start\n              });\n            } else if (operatorStartToken[stream[this._current]] !== undefined) {\n              tokens.push(this._consumeOperator(stream));\n            } else if (skipChars[stream[this._current]] !== undefined) {\n              // Ignore whitespace.\n              this._current++;\n            } else if (stream[this._current] === \"&\") {\n              start = this._current;\n              this._current++;\n\n              if (stream[this._current] === \"&\") {\n                this._current++;\n                tokens.push({\n                  type: TOK_AND,\n                  value: \"&&\",\n                  start: start\n                });\n              } else {\n                tokens.push({\n                  type: TOK_EXPREF,\n                  value: \"&\",\n                  start: start\n                });\n              }\n            } else if (stream[this._current] === \"|\") {\n              start = this._current;\n              this._current++;\n\n              if (stream[this._current] === \"|\") {\n                this._current++;\n                tokens.push({\n                  type: TOK_OR,\n                  value: \"||\",\n                  start: start\n                });\n              } else {\n                tokens.push({\n                  type: TOK_PIPE,\n                  value: \"|\",\n                  start: start\n                });\n              }\n            } else {\n              var error = new Error(\"Unknown character:\" + stream[this._current]);\n              error.name = \"LexerError\";\n              throw error;\n            }\n          }\n\n          return tokens;\n        },\n        _consumeUnquotedIdentifier: function (stream) {\n          var start = this._current;\n          this._current++;\n\n          while (this._current < stream.length && isAlphaNum(stream[this._current])) {\n            this._current++;\n          }\n\n          return stream.slice(start, this._current);\n        },\n        _consumeQuotedIdentifier: function (stream) {\n          var start = this._current;\n          this._current++;\n          var maxLength = stream.length;\n\n          while (stream[this._current] !== \"\\\"\" && this._current < maxLength) {\n            // You can escape a double quote and you can escape an escape.\n            var current = this._current;\n\n            if (stream[current] === \"\\\\\" && (stream[current + 1] === \"\\\\\" || stream[current + 1] === \"\\\"\")) {\n              current += 2;\n            } else {\n              current++;\n            }\n\n            this._current = current;\n          }\n\n          this._current++;\n          return JSON.parse(stream.slice(start, this._current));\n        },\n        _consumeRawStringLiteral: function (stream) {\n          var start = this._current;\n          this._current++;\n          var maxLength = stream.length;\n\n          while (stream[this._current] !== \"'\" && this._current < maxLength) {\n            // You can escape a single quote and you can escape an escape.\n            var current = this._current;\n\n            if (stream[current] === \"\\\\\" && (stream[current + 1] === \"\\\\\" || stream[current + 1] === \"'\")) {\n              current += 2;\n            } else {\n              current++;\n            }\n\n            this._current = current;\n          }\n\n          this._current++;\n          var literal = stream.slice(start + 1, this._current - 1);\n          return literal.replace(\"\\\\'\", \"'\");\n        },\n        _consumeNumber: function (stream) {\n          var start = this._current;\n          this._current++;\n          var maxLength = stream.length;\n\n          while (isNum(stream[this._current]) && this._current < maxLength) {\n            this._current++;\n          }\n\n          var value = parseInt(stream.slice(start, this._current));\n          return {\n            type: TOK_NUMBER,\n            value: value,\n            start: start\n          };\n        },\n        _consumeLBracket: function (stream) {\n          var start = this._current;\n          this._current++;\n\n          if (stream[this._current] === \"?\") {\n            this._current++;\n            return {\n              type: TOK_FILTER,\n              value: \"[?\",\n              start: start\n            };\n          } else if (stream[this._current] === \"]\") {\n            this._current++;\n            return {\n              type: TOK_FLATTEN,\n              value: \"[]\",\n              start: start\n            };\n          } else {\n            return {\n              type: TOK_LBRACKET,\n              value: \"[\",\n              start: start\n            };\n          }\n        },\n        _consumeOperator: function (stream) {\n          var start = this._current;\n          var startingChar = stream[start];\n          this._current++;\n\n          if (startingChar === \"!\") {\n            if (stream[this._current] === \"=\") {\n              this._current++;\n              return {\n                type: TOK_NE,\n                value: \"!=\",\n                start: start\n              };\n            } else {\n              return {\n                type: TOK_NOT,\n                value: \"!\",\n                start: start\n              };\n            }\n          } else if (startingChar === \"<\") {\n            if (stream[this._current] === \"=\") {\n              this._current++;\n              return {\n                type: TOK_LTE,\n                value: \"<=\",\n                start: start\n              };\n            } else {\n              return {\n                type: TOK_LT,\n                value: \"<\",\n                start: start\n              };\n            }\n          } else if (startingChar === \">\") {\n            if (stream[this._current] === \"=\") {\n              this._current++;\n              return {\n                type: TOK_GTE,\n                value: \">=\",\n                start: start\n              };\n            } else {\n              return {\n                type: TOK_GT,\n                value: \">\",\n                start: start\n              };\n            }\n          } else if (startingChar === \"=\") {\n            if (stream[this._current] === \"=\") {\n              this._current++;\n              return {\n                type: TOK_EQ,\n                value: \"==\",\n                start: start\n              };\n            }\n          }\n        },\n        _consumeLiteral: function (stream) {\n          this._current++;\n          var start = this._current;\n          var maxLength = stream.length;\n          var literal;\n\n          while (stream[this._current] !== \"`\" && this._current < maxLength) {\n            // You can escape a literal char or you can escape the escape.\n            var current = this._current;\n\n            if (stream[current] === \"\\\\\" && (stream[current + 1] === \"\\\\\" || stream[current + 1] === \"`\")) {\n              current += 2;\n            } else {\n              current++;\n            }\n\n            this._current = current;\n          }\n\n          var literalString = trimLeft(stream.slice(start, this._current));\n          literalString = literalString.replace(\"\\\\`\", \"`\");\n\n          if (this._looksLikeJSON(literalString)) {\n            literal = JSON.parse(literalString);\n          } else {\n            // Try to JSON parse it as \"<literal>\"\n            literal = JSON.parse(\"\\\"\" + literalString + \"\\\"\");\n          } // +1 gets us to the ending \"`\", +1 to move on to the next char.\n\n\n          this._current++;\n          return literal;\n        },\n        _looksLikeJSON: function (literalString) {\n          var startingChars = \"[{\\\"\";\n          var jsonLiterals = [\"true\", \"false\", \"null\"];\n          var numberLooking = \"-0123456789\";\n\n          if (literalString === \"\") {\n            return false;\n          } else if (startingChars.indexOf(literalString[0]) >= 0) {\n            return true;\n          } else if (jsonLiterals.indexOf(literalString) >= 0) {\n            return true;\n          } else if (numberLooking.indexOf(literalString[0]) >= 0) {\n            try {\n              JSON.parse(literalString);\n              return true;\n            } catch (ex) {\n              return false;\n            }\n          } else {\n            return false;\n          }\n        }\n      };\n      var bindingPower = {};\n      bindingPower[TOK_EOF] = 0;\n      bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;\n      bindingPower[TOK_QUOTEDIDENTIFIER] = 0;\n      bindingPower[TOK_RBRACKET] = 0;\n      bindingPower[TOK_RPAREN] = 0;\n      bindingPower[TOK_COMMA] = 0;\n      bindingPower[TOK_RBRACE] = 0;\n      bindingPower[TOK_NUMBER] = 0;\n      bindingPower[TOK_CURRENT] = 0;\n      bindingPower[TOK_EXPREF] = 0;\n      bindingPower[TOK_PIPE] = 1;\n      bindingPower[TOK_OR] = 2;\n      bindingPower[TOK_AND] = 3;\n      bindingPower[TOK_EQ] = 5;\n      bindingPower[TOK_GT] = 5;\n      bindingPower[TOK_LT] = 5;\n      bindingPower[TOK_GTE] = 5;\n      bindingPower[TOK_LTE] = 5;\n      bindingPower[TOK_NE] = 5;\n      bindingPower[TOK_FLATTEN] = 9;\n      bindingPower[TOK_STAR] = 20;\n      bindingPower[TOK_FILTER] = 21;\n      bindingPower[TOK_DOT] = 40;\n      bindingPower[TOK_NOT] = 45;\n      bindingPower[TOK_LBRACE] = 50;\n      bindingPower[TOK_LBRACKET] = 55;\n      bindingPower[TOK_LPAREN] = 60;\n\n      function Parser() {}\n\n      Parser.prototype = {\n        parse: function (expression) {\n          this._loadTokens(expression);\n\n          this.index = 0;\n          var ast = this.expression(0);\n\n          if (this._lookahead(0) !== TOK_EOF) {\n            var t = this._lookaheadToken(0);\n\n            var error = new Error(\"Unexpected token type: \" + t.type + \", value: \" + t.value);\n            error.name = \"ParserError\";\n            throw error;\n          }\n\n          return ast;\n        },\n        _loadTokens: function (expression) {\n          var lexer = new Lexer();\n          var tokens = lexer.tokenize(expression);\n          tokens.push({\n            type: TOK_EOF,\n            value: \"\",\n            start: expression.length\n          });\n          this.tokens = tokens;\n        },\n        expression: function (rbp) {\n          var leftToken = this._lookaheadToken(0);\n\n          this._advance();\n\n          var left = this.nud(leftToken);\n\n          var currentToken = this._lookahead(0);\n\n          while (rbp < bindingPower[currentToken]) {\n            this._advance();\n\n            left = this.led(currentToken, left);\n            currentToken = this._lookahead(0);\n          }\n\n          return left;\n        },\n        _lookahead: function (number) {\n          return this.tokens[this.index + number].type;\n        },\n        _lookaheadToken: function (number) {\n          return this.tokens[this.index + number];\n        },\n        _advance: function () {\n          this.index++;\n        },\n        nud: function (token) {\n          var left;\n          var right;\n          var expression;\n\n          switch (token.type) {\n            case TOK_LITERAL:\n              return {\n                type: \"Literal\",\n                value: token.value\n              };\n\n            case TOK_UNQUOTEDIDENTIFIER:\n              return {\n                type: \"Field\",\n                name: token.value\n              };\n\n            case TOK_QUOTEDIDENTIFIER:\n              var node = {\n                type: \"Field\",\n                name: token.value\n              };\n\n              if (this._lookahead(0) === TOK_LPAREN) {\n                throw new Error(\"Quoted identifier not allowed for function names.\");\n              } else {\n                return node;\n              }\n\n              break;\n\n            case TOK_NOT:\n              right = this.expression(bindingPower.Not);\n              return {\n                type: \"NotExpression\",\n                children: [right]\n              };\n\n            case TOK_STAR:\n              left = {\n                type: \"Identity\"\n              };\n              right = null;\n\n              if (this._lookahead(0) === TOK_RBRACKET) {\n                // This can happen in a multiselect,\n                // [a, b, *]\n                right = {\n                  type: \"Identity\"\n                };\n              } else {\n                right = this._parseProjectionRHS(bindingPower.Star);\n              }\n\n              return {\n                type: \"ValueProjection\",\n                children: [left, right]\n              };\n\n            case TOK_FILTER:\n              return this.led(token.type, {\n                type: \"Identity\"\n              });\n\n            case TOK_LBRACE:\n              return this._parseMultiselectHash();\n\n            case TOK_FLATTEN:\n              left = {\n                type: TOK_FLATTEN,\n                children: [{\n                  type: \"Identity\"\n                }]\n              };\n              right = this._parseProjectionRHS(bindingPower.Flatten);\n              return {\n                type: \"Projection\",\n                children: [left, right]\n              };\n\n            case TOK_LBRACKET:\n              if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {\n                right = this._parseIndexExpression();\n                return this._projectIfSlice({\n                  type: \"Identity\"\n                }, right);\n              } else if (this._lookahead(0) === TOK_STAR && this._lookahead(1) === TOK_RBRACKET) {\n                this._advance();\n\n                this._advance();\n\n                right = this._parseProjectionRHS(bindingPower.Star);\n                return {\n                  type: \"Projection\",\n                  children: [{\n                    type: \"Identity\"\n                  }, right]\n                };\n              } else {\n                return this._parseMultiselectList();\n              }\n\n              break;\n\n            case TOK_CURRENT:\n              return {\n                type: TOK_CURRENT\n              };\n\n            case TOK_EXPREF:\n              expression = this.expression(bindingPower.Expref);\n              return {\n                type: \"ExpressionReference\",\n                children: [expression]\n              };\n\n            case TOK_LPAREN:\n              var args = [];\n\n              while (this._lookahead(0) !== TOK_RPAREN) {\n                if (this._lookahead(0) === TOK_CURRENT) {\n                  expression = {\n                    type: TOK_CURRENT\n                  };\n\n                  this._advance();\n                } else {\n                  expression = this.expression(0);\n                }\n\n                args.push(expression);\n              }\n\n              this._match(TOK_RPAREN);\n\n              return args[0];\n\n            default:\n              this._errorToken(token);\n\n          }\n        },\n        led: function (tokenName, left) {\n          var right;\n\n          switch (tokenName) {\n            case TOK_DOT:\n              var rbp = bindingPower.Dot;\n\n              if (this._lookahead(0) !== TOK_STAR) {\n                right = this._parseDotRHS(rbp);\n                return {\n                  type: \"Subexpression\",\n                  children: [left, right]\n                };\n              } else {\n                // Creating a projection.\n                this._advance();\n\n                right = this._parseProjectionRHS(rbp);\n                return {\n                  type: \"ValueProjection\",\n                  children: [left, right]\n                };\n              }\n\n              break;\n\n            case TOK_PIPE:\n              right = this.expression(bindingPower.Pipe);\n              return {\n                type: TOK_PIPE,\n                children: [left, right]\n              };\n\n            case TOK_OR:\n              right = this.expression(bindingPower.Or);\n              return {\n                type: \"OrExpression\",\n                children: [left, right]\n              };\n\n            case TOK_AND:\n              right = this.expression(bindingPower.And);\n              return {\n                type: \"AndExpression\",\n                children: [left, right]\n              };\n\n            case TOK_LPAREN:\n              var name = left.name;\n              var args = [];\n              var expression, node;\n\n              while (this._lookahead(0) !== TOK_RPAREN) {\n                if (this._lookahead(0) === TOK_CURRENT) {\n                  expression = {\n                    type: TOK_CURRENT\n                  };\n\n                  this._advance();\n                } else {\n                  expression = this.expression(0);\n                }\n\n                if (this._lookahead(0) === TOK_COMMA) {\n                  this._match(TOK_COMMA);\n                }\n\n                args.push(expression);\n              }\n\n              this._match(TOK_RPAREN);\n\n              node = {\n                type: \"Function\",\n                name: name,\n                children: args\n              };\n              return node;\n\n            case TOK_FILTER:\n              var condition = this.expression(0);\n\n              this._match(TOK_RBRACKET);\n\n              if (this._lookahead(0) === TOK_FLATTEN) {\n                right = {\n                  type: \"Identity\"\n                };\n              } else {\n                right = this._parseProjectionRHS(bindingPower.Filter);\n              }\n\n              return {\n                type: \"FilterProjection\",\n                children: [left, right, condition]\n              };\n\n            case TOK_FLATTEN:\n              var leftNode = {\n                type: TOK_FLATTEN,\n                children: [left]\n              };\n\n              var rightNode = this._parseProjectionRHS(bindingPower.Flatten);\n\n              return {\n                type: \"Projection\",\n                children: [leftNode, rightNode]\n              };\n\n            case TOK_EQ:\n            case TOK_NE:\n            case TOK_GT:\n            case TOK_GTE:\n            case TOK_LT:\n            case TOK_LTE:\n              return this._parseComparator(left, tokenName);\n\n            case TOK_LBRACKET:\n              var token = this._lookaheadToken(0);\n\n              if (token.type === TOK_NUMBER || token.type === TOK_COLON) {\n                right = this._parseIndexExpression();\n                return this._projectIfSlice(left, right);\n              } else {\n                this._match(TOK_STAR);\n\n                this._match(TOK_RBRACKET);\n\n                right = this._parseProjectionRHS(bindingPower.Star);\n                return {\n                  type: \"Projection\",\n                  children: [left, right]\n                };\n              }\n\n              break;\n\n            default:\n              this._errorToken(this._lookaheadToken(0));\n\n          }\n        },\n        _match: function (tokenType) {\n          if (this._lookahead(0) === tokenType) {\n            this._advance();\n          } else {\n            var t = this._lookaheadToken(0);\n\n            var error = new Error(\"Expected \" + tokenType + \", got: \" + t.type);\n            error.name = \"ParserError\";\n            throw error;\n          }\n        },\n        _errorToken: function (token) {\n          var error = new Error(\"Invalid token (\" + token.type + \"): \\\"\" + token.value + \"\\\"\");\n          error.name = \"ParserError\";\n          throw error;\n        },\n        _parseIndexExpression: function () {\n          if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {\n            return this._parseSliceExpression();\n          } else {\n            var node = {\n              type: \"Index\",\n              value: this._lookaheadToken(0).value\n            };\n\n            this._advance();\n\n            this._match(TOK_RBRACKET);\n\n            return node;\n          }\n        },\n        _projectIfSlice: function (left, right) {\n          var indexExpr = {\n            type: \"IndexExpression\",\n            children: [left, right]\n          };\n\n          if (right.type === \"Slice\") {\n            return {\n              type: \"Projection\",\n              children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]\n            };\n          } else {\n            return indexExpr;\n          }\n        },\n        _parseSliceExpression: function () {\n          // [start:end:step] where each part is optional, as well as the last\n          // colon.\n          var parts = [null, null, null];\n          var index = 0;\n\n          var currentToken = this._lookahead(0);\n\n          while (currentToken !== TOK_RBRACKET && index < 3) {\n            if (currentToken === TOK_COLON) {\n              index++;\n\n              this._advance();\n            } else if (currentToken === TOK_NUMBER) {\n              parts[index] = this._lookaheadToken(0).value;\n\n              this._advance();\n            } else {\n              var t = this._lookahead(0);\n\n              var error = new Error(\"Syntax error, unexpected token: \" + t.value + \"(\" + t.type + \")\");\n              error.name = \"Parsererror\";\n              throw error;\n            }\n\n            currentToken = this._lookahead(0);\n          }\n\n          this._match(TOK_RBRACKET);\n\n          return {\n            type: \"Slice\",\n            children: parts\n          };\n        },\n        _parseComparator: function (left, comparator) {\n          var right = this.expression(bindingPower[comparator]);\n          return {\n            type: \"Comparator\",\n            name: comparator,\n            children: [left, right]\n          };\n        },\n        _parseDotRHS: function (rbp) {\n          var lookahead = this._lookahead(0);\n\n          var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];\n\n          if (exprTokens.indexOf(lookahead) >= 0) {\n            return this.expression(rbp);\n          } else if (lookahead === TOK_LBRACKET) {\n            this._match(TOK_LBRACKET);\n\n            return this._parseMultiselectList();\n          } else if (lookahead === TOK_LBRACE) {\n            this._match(TOK_LBRACE);\n\n            return this._parseMultiselectHash();\n          }\n        },\n        _parseProjectionRHS: function (rbp) {\n          var right;\n\n          if (bindingPower[this._lookahead(0)] < 10) {\n            right = {\n              type: \"Identity\"\n            };\n          } else if (this._lookahead(0) === TOK_LBRACKET) {\n            right = this.expression(rbp);\n          } else if (this._lookahead(0) === TOK_FILTER) {\n            right = this.expression(rbp);\n          } else if (this._lookahead(0) === TOK_DOT) {\n            this._match(TOK_DOT);\n\n            right = this._parseDotRHS(rbp);\n          } else {\n            var t = this._lookaheadToken(0);\n\n            var error = new Error(\"Sytanx error, unexpected token: \" + t.value + \"(\" + t.type + \")\");\n            error.name = \"ParserError\";\n            throw error;\n          }\n\n          return right;\n        },\n        _parseMultiselectList: function () {\n          var expressions = [];\n\n          while (this._lookahead(0) !== TOK_RBRACKET) {\n            var expression = this.expression(0);\n            expressions.push(expression);\n\n            if (this._lookahead(0) === TOK_COMMA) {\n              this._match(TOK_COMMA);\n\n              if (this._lookahead(0) === TOK_RBRACKET) {\n                throw new Error(\"Unexpected token Rbracket\");\n              }\n            }\n          }\n\n          this._match(TOK_RBRACKET);\n\n          return {\n            type: \"MultiSelectList\",\n            children: expressions\n          };\n        },\n        _parseMultiselectHash: function () {\n          var pairs = [];\n          var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];\n          var keyToken, keyName, value, node;\n\n          for (;;) {\n            keyToken = this._lookaheadToken(0);\n\n            if (identifierTypes.indexOf(keyToken.type) < 0) {\n              throw new Error(\"Expecting an identifier token, got: \" + keyToken.type);\n            }\n\n            keyName = keyToken.value;\n\n            this._advance();\n\n            this._match(TOK_COLON);\n\n            value = this.expression(0);\n            node = {\n              type: \"KeyValuePair\",\n              name: keyName,\n              value: value\n            };\n            pairs.push(node);\n\n            if (this._lookahead(0) === TOK_COMMA) {\n              this._match(TOK_COMMA);\n            } else if (this._lookahead(0) === TOK_RBRACE) {\n              this._match(TOK_RBRACE);\n\n              break;\n            }\n          }\n\n          return {\n            type: \"MultiSelectHash\",\n            children: pairs\n          };\n        }\n      };\n\n      function TreeInterpreter(runtime) {\n        this.runtime = runtime;\n      }\n\n      TreeInterpreter.prototype = {\n        search: function (node, value) {\n          return this.visit(node, value);\n        },\n        visit: function (node, value) {\n          var matched, current, result, first, second, field, left, right, collected, i;\n\n          switch (node.type) {\n            case \"Field\":\n              if (value === null) {\n                return null;\n              } else if (isObject(value)) {\n                field = value[node.name];\n\n                if (field === undefined) {\n                  return null;\n                } else {\n                  return field;\n                }\n              } else {\n                return null;\n              }\n\n              break;\n\n            case \"Subexpression\":\n              result = this.visit(node.children[0], value);\n\n              for (i = 1; i < node.children.length; i++) {\n                result = this.visit(node.children[1], result);\n\n                if (result === null) {\n                  return null;\n                }\n              }\n\n              return result;\n\n            case \"IndexExpression\":\n              left = this.visit(node.children[0], value);\n              right = this.visit(node.children[1], left);\n              return right;\n\n            case \"Index\":\n              if (!isArray(value)) {\n                return null;\n              }\n\n              var index = node.value;\n\n              if (index < 0) {\n                index = value.length + index;\n              }\n\n              result = value[index];\n\n              if (result === undefined) {\n                result = null;\n              }\n\n              return result;\n\n            case \"Slice\":\n              if (!isArray(value)) {\n                return null;\n              }\n\n              var sliceParams = node.children.slice(0);\n              var computed = this.computeSliceParams(value.length, sliceParams);\n              var start = computed[0];\n              var stop = computed[1];\n              var step = computed[2];\n              result = [];\n\n              if (step > 0) {\n                for (i = start; i < stop; i += step) {\n                  result.push(value[i]);\n                }\n              } else {\n                for (i = start; i > stop; i += step) {\n                  result.push(value[i]);\n                }\n              }\n\n              return result;\n\n            case \"Projection\":\n              // Evaluate left child.\n              var base = this.visit(node.children[0], value);\n\n              if (!isArray(base)) {\n                return null;\n              }\n\n              collected = [];\n\n              for (i = 0; i < base.length; i++) {\n                current = this.visit(node.children[1], base[i]);\n\n                if (current !== null) {\n                  collected.push(current);\n                }\n              }\n\n              return collected;\n\n            case \"ValueProjection\":\n              // Evaluate left child.\n              base = this.visit(node.children[0], value);\n\n              if (!isObject(base)) {\n                return null;\n              }\n\n              collected = [];\n              var values = objValues(base);\n\n              for (i = 0; i < values.length; i++) {\n                current = this.visit(node.children[1], values[i]);\n\n                if (current !== null) {\n                  collected.push(current);\n                }\n              }\n\n              return collected;\n\n            case \"FilterProjection\":\n              base = this.visit(node.children[0], value);\n\n              if (!isArray(base)) {\n                return null;\n              }\n\n              var filtered = [];\n              var finalResults = [];\n\n              for (i = 0; i < base.length; i++) {\n                matched = this.visit(node.children[2], base[i]);\n\n                if (!isFalse(matched)) {\n                  filtered.push(base[i]);\n                }\n              }\n\n              for (var j = 0; j < filtered.length; j++) {\n                current = this.visit(node.children[1], filtered[j]);\n\n                if (current !== null) {\n                  finalResults.push(current);\n                }\n              }\n\n              return finalResults;\n\n            case \"Comparator\":\n              first = this.visit(node.children[0], value);\n              second = this.visit(node.children[1], value);\n\n              switch (node.name) {\n                case TOK_EQ:\n                  result = strictDeepEqual(first, second);\n                  break;\n\n                case TOK_NE:\n                  result = !strictDeepEqual(first, second);\n                  break;\n\n                case TOK_GT:\n                  result = first > second;\n                  break;\n\n                case TOK_GTE:\n                  result = first >= second;\n                  break;\n\n                case TOK_LT:\n                  result = first < second;\n                  break;\n\n                case TOK_LTE:\n                  result = first <= second;\n                  break;\n\n                default:\n                  throw new Error(\"Unknown comparator: \" + node.name);\n              }\n\n              return result;\n\n            case TOK_FLATTEN:\n              var original = this.visit(node.children[0], value);\n\n              if (!isArray(original)) {\n                return null;\n              }\n\n              var merged = [];\n\n              for (i = 0; i < original.length; i++) {\n                current = original[i];\n\n                if (isArray(current)) {\n                  merged.push.apply(merged, current);\n                } else {\n                  merged.push(current);\n                }\n              }\n\n              return merged;\n\n            case \"Identity\":\n              return value;\n\n            case \"MultiSelectList\":\n              if (value === null) {\n                return null;\n              }\n\n              collected = [];\n\n              for (i = 0; i < node.children.length; i++) {\n                collected.push(this.visit(node.children[i], value));\n              }\n\n              return collected;\n\n            case \"MultiSelectHash\":\n              if (value === null) {\n                return null;\n              }\n\n              collected = {};\n              var child;\n\n              for (i = 0; i < node.children.length; i++) {\n                child = node.children[i];\n                collected[child.name] = this.visit(child.value, value);\n              }\n\n              return collected;\n\n            case \"OrExpression\":\n              matched = this.visit(node.children[0], value);\n\n              if (isFalse(matched)) {\n                matched = this.visit(node.children[1], value);\n              }\n\n              return matched;\n\n            case \"AndExpression\":\n              first = this.visit(node.children[0], value);\n\n              if (isFalse(first) === true) {\n                return first;\n              }\n\n              return this.visit(node.children[1], value);\n\n            case \"NotExpression\":\n              first = this.visit(node.children[0], value);\n              return isFalse(first);\n\n            case \"Literal\":\n              return node.value;\n\n            case TOK_PIPE:\n              left = this.visit(node.children[0], value);\n              return this.visit(node.children[1], left);\n\n            case TOK_CURRENT:\n              return value;\n\n            case \"Function\":\n              var resolvedArgs = [];\n\n              for (i = 0; i < node.children.length; i++) {\n                resolvedArgs.push(this.visit(node.children[i], value));\n              }\n\n              return this.runtime.callFunction(node.name, resolvedArgs);\n\n            case \"ExpressionReference\":\n              var refNode = node.children[0]; // Tag the node with a specific attribute so the type\n              // checker verify the type.\n\n              refNode.jmespathType = TOK_EXPREF;\n              return refNode;\n\n            default:\n              throw new Error(\"Unknown node type: \" + node.type);\n          }\n        },\n        computeSliceParams: function (arrayLength, sliceParams) {\n          var start = sliceParams[0];\n          var stop = sliceParams[1];\n          var step = sliceParams[2];\n          var computed = [null, null, null];\n\n          if (step === null) {\n            step = 1;\n          } else if (step === 0) {\n            var error = new Error(\"Invalid slice, step cannot be 0\");\n            error.name = \"RuntimeError\";\n            throw error;\n          }\n\n          var stepValueNegative = step < 0 ? true : false;\n\n          if (start === null) {\n            start = stepValueNegative ? arrayLength - 1 : 0;\n          } else {\n            start = this.capSliceRange(arrayLength, start, step);\n          }\n\n          if (stop === null) {\n            stop = stepValueNegative ? -1 : arrayLength;\n          } else {\n            stop = this.capSliceRange(arrayLength, stop, step);\n          }\n\n          computed[0] = start;\n          computed[1] = stop;\n          computed[2] = step;\n          return computed;\n        },\n        capSliceRange: function (arrayLength, actualValue, step) {\n          if (actualValue < 0) {\n            actualValue += arrayLength;\n\n            if (actualValue < 0) {\n              actualValue = step < 0 ? -1 : 0;\n            }\n          } else if (actualValue >= arrayLength) {\n            actualValue = step < 0 ? arrayLength - 1 : arrayLength;\n          }\n\n          return actualValue;\n        }\n      };\n\n      function Runtime(interpreter) {\n        this._interpreter = interpreter;\n        this.functionTable = {\n          // name: [function, <signature>]\n          // The <signature> can be:\n          //\n          // {\n          //   args: [[type1, type2], [type1, type2]],\n          //   variadic: true|false\n          // }\n          //\n          // Each arg in the arg list is a list of valid types\n          // (if the function is overloaded and supports multiple\n          // types.  If the type is \"any\" then no type checking\n          // occurs on the argument.  Variadic is optional\n          // and if not provided is assumed to be false.\n          abs: {\n            _func: this._functionAbs,\n            _signature: [{\n              types: [TYPE_NUMBER]\n            }]\n          },\n          avg: {\n            _func: this._functionAvg,\n            _signature: [{\n              types: [TYPE_ARRAY_NUMBER]\n            }]\n          },\n          ceil: {\n            _func: this._functionCeil,\n            _signature: [{\n              types: [TYPE_NUMBER]\n            }]\n          },\n          contains: {\n            _func: this._functionContains,\n            _signature: [{\n              types: [TYPE_STRING, TYPE_ARRAY]\n            }, {\n              types: [TYPE_ANY]\n            }]\n          },\n          \"ends_with\": {\n            _func: this._functionEndsWith,\n            _signature: [{\n              types: [TYPE_STRING]\n            }, {\n              types: [TYPE_STRING]\n            }]\n          },\n          floor: {\n            _func: this._functionFloor,\n            _signature: [{\n              types: [TYPE_NUMBER]\n            }]\n          },\n          length: {\n            _func: this._functionLength,\n            _signature: [{\n              types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT]\n            }]\n          },\n          map: {\n            _func: this._functionMap,\n            _signature: [{\n              types: [TYPE_EXPREF]\n            }, {\n              types: [TYPE_ARRAY]\n            }]\n          },\n          max: {\n            _func: this._functionMax,\n            _signature: [{\n              types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]\n            }]\n          },\n          \"merge\": {\n            _func: this._functionMerge,\n            _signature: [{\n              types: [TYPE_OBJECT],\n              variadic: true\n            }]\n          },\n          \"max_by\": {\n            _func: this._functionMaxBy,\n            _signature: [{\n              types: [TYPE_ARRAY]\n            }, {\n              types: [TYPE_EXPREF]\n            }]\n          },\n          sum: {\n            _func: this._functionSum,\n            _signature: [{\n              types: [TYPE_ARRAY_NUMBER]\n            }]\n          },\n          \"starts_with\": {\n            _func: this._functionStartsWith,\n            _signature: [{\n              types: [TYPE_STRING]\n            }, {\n              types: [TYPE_STRING]\n            }]\n          },\n          min: {\n            _func: this._functionMin,\n            _signature: [{\n              types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]\n            }]\n          },\n          \"min_by\": {\n            _func: this._functionMinBy,\n            _signature: [{\n              types: [TYPE_ARRAY]\n            }, {\n              types: [TYPE_EXPREF]\n            }]\n          },\n          type: {\n            _func: this._functionType,\n            _signature: [{\n              types: [TYPE_ANY]\n            }]\n          },\n          keys: {\n            _func: this._functionKeys,\n            _signature: [{\n              types: [TYPE_OBJECT]\n            }]\n          },\n          values: {\n            _func: this._functionValues,\n            _signature: [{\n              types: [TYPE_OBJECT]\n            }]\n          },\n          sort: {\n            _func: this._functionSort,\n            _signature: [{\n              types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER]\n            }]\n          },\n          \"sort_by\": {\n            _func: this._functionSortBy,\n            _signature: [{\n              types: [TYPE_ARRAY]\n            }, {\n              types: [TYPE_EXPREF]\n            }]\n          },\n          join: {\n            _func: this._functionJoin,\n            _signature: [{\n              types: [TYPE_STRING]\n            }, {\n              types: [TYPE_ARRAY_STRING]\n            }]\n          },\n          reverse: {\n            _func: this._functionReverse,\n            _signature: [{\n              types: [TYPE_STRING, TYPE_ARRAY]\n            }]\n          },\n          \"to_array\": {\n            _func: this._functionToArray,\n            _signature: [{\n              types: [TYPE_ANY]\n            }]\n          },\n          \"to_string\": {\n            _func: this._functionToString,\n            _signature: [{\n              types: [TYPE_ANY]\n            }]\n          },\n          \"to_number\": {\n            _func: this._functionToNumber,\n            _signature: [{\n              types: [TYPE_ANY]\n            }]\n          },\n          \"not_null\": {\n            _func: this._functionNotNull,\n            _signature: [{\n              types: [TYPE_ANY],\n              variadic: true\n            }]\n          }\n        };\n      }\n\n      Runtime.prototype = {\n        callFunction: function (name, resolvedArgs) {\n          var functionEntry = this.functionTable[name];\n\n          if (functionEntry === undefined) {\n            throw new Error(\"Unknown function: \" + name + \"()\");\n          }\n\n          this._validateArgs(name, resolvedArgs, functionEntry._signature);\n\n          return functionEntry._func.call(this, resolvedArgs);\n        },\n        _validateArgs: function (name, args, signature) {\n          // Validating the args requires validating\n          // the correct arity and the correct type of each arg.\n          // If the last argument is declared as variadic, then we need\n          // a minimum number of args to be required.  Otherwise it has to\n          // be an exact amount.\n          var pluralized;\n\n          if (signature[signature.length - 1].variadic) {\n            if (args.length < signature.length) {\n              pluralized = signature.length === 1 ? \" argument\" : \" arguments\";\n              throw new Error(\"ArgumentError: \" + name + \"() \" + \"takes at least\" + signature.length + pluralized + \" but received \" + args.length);\n            }\n          } else if (args.length !== signature.length) {\n            pluralized = signature.length === 1 ? \" argument\" : \" arguments\";\n            throw new Error(\"ArgumentError: \" + name + \"() \" + \"takes \" + signature.length + pluralized + \" but received \" + args.length);\n          }\n\n          var currentSpec;\n          var actualType;\n          var typeMatched;\n\n          for (var i = 0; i < signature.length; i++) {\n            typeMatched = false;\n            currentSpec = signature[i].types;\n            actualType = this._getTypeName(args[i]);\n\n            for (var j = 0; j < currentSpec.length; j++) {\n              if (this._typeMatches(actualType, currentSpec[j], args[i])) {\n                typeMatched = true;\n                break;\n              }\n            }\n\n            if (!typeMatched) {\n              throw new Error(\"TypeError: \" + name + \"() \" + \"expected argument \" + (i + 1) + \" to be type \" + currentSpec + \" but received type \" + actualType + \" instead.\");\n            }\n          }\n        },\n        _typeMatches: function (actual, expected, argValue) {\n          if (expected === TYPE_ANY) {\n            return true;\n          }\n\n          if (expected === TYPE_ARRAY_STRING || expected === TYPE_ARRAY_NUMBER || expected === TYPE_ARRAY) {\n            // The expected type can either just be array,\n            // or it can require a specific subtype (array of numbers).\n            //\n            // The simplest case is if \"array\" with no subtype is specified.\n            if (expected === TYPE_ARRAY) {\n              return actual === TYPE_ARRAY;\n            } else if (actual === TYPE_ARRAY) {\n              // Otherwise we need to check subtypes.\n              // I think this has potential to be improved.\n              var subtype;\n\n              if (expected === TYPE_ARRAY_NUMBER) {\n                subtype = TYPE_NUMBER;\n              } else if (expected === TYPE_ARRAY_STRING) {\n                subtype = TYPE_STRING;\n              }\n\n              for (var i = 0; i < argValue.length; i++) {\n                if (!this._typeMatches(this._getTypeName(argValue[i]), subtype, argValue[i])) {\n                  return false;\n                }\n              }\n\n              return true;\n            }\n          } else {\n            return actual === expected;\n          }\n        },\n        _getTypeName: function (obj) {\n          switch (Object.prototype.toString.call(obj)) {\n            case \"[object String]\":\n              return TYPE_STRING;\n\n            case \"[object Number]\":\n              return TYPE_NUMBER;\n\n            case \"[object Array]\":\n              return TYPE_ARRAY;\n\n            case \"[object Boolean]\":\n              return TYPE_BOOLEAN;\n\n            case \"[object Null]\":\n              return TYPE_NULL;\n\n            case \"[object Object]\":\n              // Check if it's an expref.  If it has, it's been\n              // tagged with a jmespathType attr of 'Expref';\n              if (obj.jmespathType === TOK_EXPREF) {\n                return TYPE_EXPREF;\n              } else {\n                return TYPE_OBJECT;\n              }\n\n          }\n        },\n        _functionStartsWith: function (resolvedArgs) {\n          return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;\n        },\n        _functionEndsWith: function (resolvedArgs) {\n          var searchStr = resolvedArgs[0];\n          var suffix = resolvedArgs[1];\n          return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;\n        },\n        _functionReverse: function (resolvedArgs) {\n          var typeName = this._getTypeName(resolvedArgs[0]);\n\n          if (typeName === TYPE_STRING) {\n            var originalStr = resolvedArgs[0];\n            var reversedStr = \"\";\n\n            for (var i = originalStr.length - 1; i >= 0; i--) {\n              reversedStr += originalStr[i];\n            }\n\n            return reversedStr;\n          } else {\n            var reversedArray = resolvedArgs[0].slice(0);\n            reversedArray.reverse();\n            return reversedArray;\n          }\n        },\n        _functionAbs: function (resolvedArgs) {\n          return Math.abs(resolvedArgs[0]);\n        },\n        _functionCeil: function (resolvedArgs) {\n          return Math.ceil(resolvedArgs[0]);\n        },\n        _functionAvg: function (resolvedArgs) {\n          var sum = 0;\n          var inputArray = resolvedArgs[0];\n\n          for (var i = 0; i < inputArray.length; i++) {\n            sum += inputArray[i];\n          }\n\n          return sum / inputArray.length;\n        },\n        _functionContains: function (resolvedArgs) {\n          return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;\n        },\n        _functionFloor: function (resolvedArgs) {\n          return Math.floor(resolvedArgs[0]);\n        },\n        _functionLength: function (resolvedArgs) {\n          if (!isObject(resolvedArgs[0])) {\n            return resolvedArgs[0].length;\n          } else {\n            // As far as I can tell, there's no way to get the length\n            // of an object without O(n) iteration through the object.\n            return Object.keys(resolvedArgs[0]).length;\n          }\n        },\n        _functionMap: function (resolvedArgs) {\n          var mapped = [];\n          var interpreter = this._interpreter;\n          var exprefNode = resolvedArgs[0];\n          var elements = resolvedArgs[1];\n\n          for (var i = 0; i < elements.length; i++) {\n            mapped.push(interpreter.visit(exprefNode, elements[i]));\n          }\n\n          return mapped;\n        },\n        _functionMerge: function (resolvedArgs) {\n          var merged = {};\n\n          for (var i = 0; i < resolvedArgs.length; i++) {\n            var current = resolvedArgs[i];\n\n            for (var key in current) {\n              merged[key] = current[key];\n            }\n          }\n\n          return merged;\n        },\n        _functionMax: function (resolvedArgs) {\n          if (resolvedArgs[0].length > 0) {\n            var typeName = this._getTypeName(resolvedArgs[0][0]);\n\n            if (typeName === TYPE_NUMBER) {\n              return Math.max.apply(Math, resolvedArgs[0]);\n            } else {\n              var elements = resolvedArgs[0];\n              var maxElement = elements[0];\n\n              for (var i = 1; i < elements.length; i++) {\n                if (maxElement.localeCompare(elements[i]) < 0) {\n                  maxElement = elements[i];\n                }\n              }\n\n              return maxElement;\n            }\n          } else {\n            return null;\n          }\n        },\n        _functionMin: function (resolvedArgs) {\n          if (resolvedArgs[0].length > 0) {\n            var typeName = this._getTypeName(resolvedArgs[0][0]);\n\n            if (typeName === TYPE_NUMBER) {\n              return Math.min.apply(Math, resolvedArgs[0]);\n            } else {\n              var elements = resolvedArgs[0];\n              var minElement = elements[0];\n\n              for (var i = 1; i < elements.length; i++) {\n                if (elements[i].localeCompare(minElement) < 0) {\n                  minElement = elements[i];\n                }\n              }\n\n              return minElement;\n            }\n          } else {\n            return null;\n          }\n        },\n        _functionSum: function (resolvedArgs) {\n          var sum = 0;\n          var listToSum = resolvedArgs[0];\n\n          for (var i = 0; i < listToSum.length; i++) {\n            sum += listToSum[i];\n          }\n\n          return sum;\n        },\n        _functionType: function (resolvedArgs) {\n          switch (this._getTypeName(resolvedArgs[0])) {\n            case TYPE_NUMBER:\n              return \"number\";\n\n            case TYPE_STRING:\n              return \"string\";\n\n            case TYPE_ARRAY:\n              return \"array\";\n\n            case TYPE_OBJECT:\n              return \"object\";\n\n            case TYPE_BOOLEAN:\n              return \"boolean\";\n\n            case TYPE_EXPREF:\n              return \"expref\";\n\n            case TYPE_NULL:\n              return \"null\";\n          }\n        },\n        _functionKeys: function (resolvedArgs) {\n          return Object.keys(resolvedArgs[0]);\n        },\n        _functionValues: function (resolvedArgs) {\n          var obj = resolvedArgs[0];\n          var keys = Object.keys(obj);\n          var values = [];\n\n          for (var i = 0; i < keys.length; i++) {\n            values.push(obj[keys[i]]);\n          }\n\n          return values;\n        },\n        _functionJoin: function (resolvedArgs) {\n          var joinChar = resolvedArgs[0];\n          var listJoin = resolvedArgs[1];\n          return listJoin.join(joinChar);\n        },\n        _functionToArray: function (resolvedArgs) {\n          if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {\n            return resolvedArgs[0];\n          } else {\n            return [resolvedArgs[0]];\n          }\n        },\n        _functionToString: function (resolvedArgs) {\n          if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {\n            return resolvedArgs[0];\n          } else {\n            return JSON.stringify(resolvedArgs[0]);\n          }\n        },\n        _functionToNumber: function (resolvedArgs) {\n          var typeName = this._getTypeName(resolvedArgs[0]);\n\n          var convertedValue;\n\n          if (typeName === TYPE_NUMBER) {\n            return resolvedArgs[0];\n          } else if (typeName === TYPE_STRING) {\n            convertedValue = +resolvedArgs[0];\n\n            if (!isNaN(convertedValue)) {\n              return convertedValue;\n            }\n          }\n\n          return null;\n        },\n        _functionNotNull: function (resolvedArgs) {\n          for (var i = 0; i < resolvedArgs.length; i++) {\n            if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {\n              return resolvedArgs[i];\n            }\n          }\n\n          return null;\n        },\n        _functionSort: function (resolvedArgs) {\n          var sortedArray = resolvedArgs[0].slice(0);\n          sortedArray.sort();\n          return sortedArray;\n        },\n        _functionSortBy: function (resolvedArgs) {\n          var sortedArray = resolvedArgs[0].slice(0);\n\n          if (sortedArray.length === 0) {\n            return sortedArray;\n          }\n\n          var interpreter = this._interpreter;\n          var exprefNode = resolvedArgs[1];\n\n          var requiredType = this._getTypeName(interpreter.visit(exprefNode, sortedArray[0]));\n\n          if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {\n            throw new Error(\"TypeError\");\n          }\n\n          var that = this; // In order to get a stable sort out of an unstable\n          // sort algorithm, we decorate/sort/undecorate (DSU)\n          // by creating a new list of [index, element] pairs.\n          // In the cmp function, if the evaluated elements are\n          // equal, then the index will be used as the tiebreaker.\n          // After the decorated list has been sorted, it will be\n          // undecorated to extract the original elements.\n\n          var decorated = [];\n\n          for (var i = 0; i < sortedArray.length; i++) {\n            decorated.push([i, sortedArray[i]]);\n          }\n\n          decorated.sort(function (a, b) {\n            var exprA = interpreter.visit(exprefNode, a[1]);\n            var exprB = interpreter.visit(exprefNode, b[1]);\n\n            if (that._getTypeName(exprA) !== requiredType) {\n              throw new Error(\"TypeError: expected \" + requiredType + \", received \" + that._getTypeName(exprA));\n            } else if (that._getTypeName(exprB) !== requiredType) {\n              throw new Error(\"TypeError: expected \" + requiredType + \", received \" + that._getTypeName(exprB));\n            }\n\n            if (exprA > exprB) {\n              return 1;\n            } else if (exprA < exprB) {\n              return -1;\n            } else {\n              // If they're equal compare the items by their\n              // order to maintain relative order of equal keys\n              // (i.e. to get a stable sort).\n              return a[0] - b[0];\n            }\n          }); // Undecorate: extract out the original list elements.\n\n          for (var j = 0; j < decorated.length; j++) {\n            sortedArray[j] = decorated[j][1];\n          }\n\n          return sortedArray;\n        },\n        _functionMaxBy: function (resolvedArgs) {\n          var exprefNode = resolvedArgs[1];\n          var resolvedArray = resolvedArgs[0];\n          var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n          var maxNumber = -Infinity;\n          var maxRecord;\n          var current;\n\n          for (var i = 0; i < resolvedArray.length; i++) {\n            current = keyFunction(resolvedArray[i]);\n\n            if (current > maxNumber) {\n              maxNumber = current;\n              maxRecord = resolvedArray[i];\n            }\n          }\n\n          return maxRecord;\n        },\n        _functionMinBy: function (resolvedArgs) {\n          var exprefNode = resolvedArgs[1];\n          var resolvedArray = resolvedArgs[0];\n          var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n          var minNumber = Infinity;\n          var minRecord;\n          var current;\n\n          for (var i = 0; i < resolvedArray.length; i++) {\n            current = keyFunction(resolvedArray[i]);\n\n            if (current < minNumber) {\n              minNumber = current;\n              minRecord = resolvedArray[i];\n            }\n          }\n\n          return minRecord;\n        },\n        createKeyFunction: function (exprefNode, allowedTypes) {\n          var that = this;\n          var interpreter = this._interpreter;\n\n          var keyFunc = function (x) {\n            var current = interpreter.visit(exprefNode, x);\n\n            if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {\n              var msg = \"TypeError: expected one of \" + allowedTypes + \", received \" + that._getTypeName(current);\n\n              throw new Error(msg);\n            }\n\n            return current;\n          };\n\n          return keyFunc;\n        }\n      };\n\n      function compile(stream) {\n        var parser = new Parser();\n        var ast = parser.parse(stream);\n        return ast;\n      }\n\n      function tokenize(stream) {\n        var lexer = new Lexer();\n        return lexer.tokenize(stream);\n      }\n\n      function search(data, expression) {\n        var parser = new Parser(); // This needs to be improved.  Both the interpreter and runtime depend on\n        // each other.  The runtime needs the interpreter to support exprefs.\n        // There's likely a clean way to avoid the cyclic dependency.\n\n        var runtime = new Runtime();\n        var interpreter = new TreeInterpreter(runtime);\n        runtime._interpreter = interpreter;\n        var node = parser.parse(expression);\n        return interpreter.search(node, data);\n      }\n\n      exports.tokenize = tokenize;\n      exports.compile = compile;\n      exports.search = search;\n      exports.strictDeepEqual = strictDeepEqual;\n    })(typeof exports === \"undefined\" ? this.jmespath = {} : exports);\n  }, {}],\n  86: [function (require, module, exports) {\n    // shim for using process in browser\n    var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n    // don't break things.  But we need to wrap it in a try catch in case it is\n    // wrapped in strict mode code which doesn't define any globals.  It's inside a\n    // function because try/catches deoptimize in certain engines.\n\n    var cachedSetTimeout;\n    var cachedClearTimeout;\n\n    function defaultSetTimout() {\n      throw new Error('setTimeout has not been defined');\n    }\n\n    function defaultClearTimeout() {\n      throw new Error('clearTimeout has not been defined');\n    }\n\n    (function () {\n      try {\n        if (typeof setTimeout === 'function') {\n          cachedSetTimeout = setTimeout;\n        } else {\n          cachedSetTimeout = defaultSetTimout;\n        }\n      } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n      }\n\n      try {\n        if (typeof clearTimeout === 'function') {\n          cachedClearTimeout = clearTimeout;\n        } else {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n      }\n    })();\n\n    function runTimeout(fun) {\n      if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n      } // if setTimeout wasn't available but was latter defined\n\n\n      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n      }\n\n      try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n      } catch (e) {\n        try {\n          // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n          return cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n          // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n          return cachedSetTimeout.call(this, fun, 0);\n        }\n      }\n    }\n\n    function runClearTimeout(marker) {\n      if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n      } // if clearTimeout wasn't available but was latter defined\n\n\n      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n      }\n\n      try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n      } catch (e) {\n        try {\n          // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n          return cachedClearTimeout.call(null, marker);\n        } catch (e) {\n          // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n          // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n          return cachedClearTimeout.call(this, marker);\n        }\n      }\n    }\n\n    var queue = [];\n    var draining = false;\n    var currentQueue;\n    var queueIndex = -1;\n\n    function cleanUpNextTick() {\n      if (!draining || !currentQueue) {\n        return;\n      }\n\n      draining = false;\n\n      if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n      } else {\n        queueIndex = -1;\n      }\n\n      if (queue.length) {\n        drainQueue();\n      }\n    }\n\n    function drainQueue() {\n      if (draining) {\n        return;\n      }\n\n      var timeout = runTimeout(cleanUpNextTick);\n      draining = true;\n      var len = queue.length;\n\n      while (len) {\n        currentQueue = queue;\n        queue = [];\n\n        while (++queueIndex < len) {\n          if (currentQueue) {\n            currentQueue[queueIndex].run();\n          }\n        }\n\n        queueIndex = -1;\n        len = queue.length;\n      }\n\n      currentQueue = null;\n      draining = false;\n      runClearTimeout(timeout);\n    }\n\n    process.nextTick = function (fun) {\n      var args = new Array(arguments.length - 1);\n\n      if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n          args[i - 1] = arguments[i];\n        }\n      }\n\n      queue.push(new Item(fun, args));\n\n      if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n      }\n    }; // v8 likes predictible objects\n\n\n    function Item(fun, array) {\n      this.fun = fun;\n      this.array = array;\n    }\n\n    Item.prototype.run = function () {\n      this.fun.apply(null, this.array);\n    };\n\n    process.title = 'browser';\n    process.browser = true;\n    process.env = {};\n    process.argv = [];\n    process.version = ''; // empty string to avoid regexp issues\n\n    process.versions = {};\n\n    function noop() {}\n\n    process.on = noop;\n    process.addListener = noop;\n    process.once = noop;\n    process.off = noop;\n    process.removeListener = noop;\n    process.removeAllListeners = noop;\n    process.emit = noop;\n    process.prependListener = noop;\n    process.prependOnceListener = noop;\n\n    process.listeners = function (name) {\n      return [];\n    };\n\n    process.binding = function (name) {\n      throw new Error('process.binding is not supported');\n    };\n\n    process.cwd = function () {\n      return '/';\n    };\n\n    process.chdir = function (dir) {\n      throw new Error('process.chdir is not supported');\n    };\n\n    process.umask = function () {\n      return 0;\n    };\n  }, {}],\n  87: [function (require, module, exports) {\n    // Copyright Joyent, Inc. and other Node contributors.\n    //\n    // Permission is hereby granted, free of charge, to any person obtaining a\n    // copy of this software and associated documentation files (the\n    // \"Software\"), to deal in the Software without restriction, including\n    // without limitation the rights to use, copy, modify, merge, publish,\n    // distribute, sublicense, and/or sell copies of the Software, and to permit\n    // persons to whom the Software is furnished to do so, subject to the\n    // following conditions:\n    //\n    // The above copyright notice and this permission notice shall be included\n    // in all copies or substantial portions of the Software.\n    //\n    // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n    // USE OR OTHER DEALINGS IN THE SOFTWARE.\n    'use strict'; // If obj.hasOwnProperty has been overridden, then calling\n    // obj.hasOwnProperty(prop) will break.\n    // See: https://github.com/joyent/node/issues/1707\n\n    function hasOwnProperty(obj, prop) {\n      return Object.prototype.hasOwnProperty.call(obj, prop);\n    }\n\n    module.exports = function (qs, sep, eq, options) {\n      sep = sep || '&';\n      eq = eq || '=';\n      var obj = {};\n\n      if (typeof qs !== 'string' || qs.length === 0) {\n        return obj;\n      }\n\n      var regexp = /\\+/g;\n      qs = qs.split(sep);\n      var maxKeys = 1000;\n\n      if (options && typeof options.maxKeys === 'number') {\n        maxKeys = options.maxKeys;\n      }\n\n      var len = qs.length; // maxKeys <= 0 means that we should not limit keys count\n\n      if (maxKeys > 0 && len > maxKeys) {\n        len = maxKeys;\n      }\n\n      for (var i = 0; i < len; ++i) {\n        var x = qs[i].replace(regexp, '%20'),\n            idx = x.indexOf(eq),\n            kstr,\n            vstr,\n            k,\n            v;\n\n        if (idx >= 0) {\n          kstr = x.substr(0, idx);\n          vstr = x.substr(idx + 1);\n        } else {\n          kstr = x;\n          vstr = '';\n        }\n\n        k = decodeURIComponent(kstr);\n        v = decodeURIComponent(vstr);\n\n        if (!hasOwnProperty(obj, k)) {\n          obj[k] = v;\n        } else if (isArray(obj[k])) {\n          obj[k].push(v);\n        } else {\n          obj[k] = [obj[k], v];\n        }\n      }\n\n      return obj;\n    };\n\n    var isArray = Array.isArray || function (xs) {\n      return Object.prototype.toString.call(xs) === '[object Array]';\n    };\n  }, {}],\n  88: [function (require, module, exports) {\n    // Copyright Joyent, Inc. and other Node contributors.\n    //\n    // Permission is hereby granted, free of charge, to any person obtaining a\n    // copy of this software and associated documentation files (the\n    // \"Software\"), to deal in the Software without restriction, including\n    // without limitation the rights to use, copy, modify, merge, publish,\n    // distribute, sublicense, and/or sell copies of the Software, and to permit\n    // persons to whom the Software is furnished to do so, subject to the\n    // following conditions:\n    //\n    // The above copyright notice and this permission notice shall be included\n    // in all copies or substantial portions of the Software.\n    //\n    // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n    // USE OR OTHER DEALINGS IN THE SOFTWARE.\n    'use strict';\n\n    var stringifyPrimitive = function (v) {\n      switch (typeof v) {\n        case 'string':\n          return v;\n\n        case 'boolean':\n          return v ? 'true' : 'false';\n\n        case 'number':\n          return isFinite(v) ? v : '';\n\n        default:\n          return '';\n      }\n    };\n\n    module.exports = function (obj, sep, eq, name) {\n      sep = sep || '&';\n      eq = eq || '=';\n\n      if (obj === null) {\n        obj = undefined;\n      }\n\n      if (typeof obj === 'object') {\n        return map(objectKeys(obj), function (k) {\n          var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n\n          if (isArray(obj[k])) {\n            return map(obj[k], function (v) {\n              return ks + encodeURIComponent(stringifyPrimitive(v));\n            }).join(sep);\n          } else {\n            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n          }\n        }).join(sep);\n      }\n\n      if (!name) return '';\n      return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));\n    };\n\n    var isArray = Array.isArray || function (xs) {\n      return Object.prototype.toString.call(xs) === '[object Array]';\n    };\n\n    function map(xs, f) {\n      if (xs.map) return xs.map(f);\n      var res = [];\n\n      for (var i = 0; i < xs.length; i++) {\n        res.push(f(xs[i], i));\n      }\n\n      return res;\n    }\n\n    var objectKeys = Object.keys || function (obj) {\n      var res = [];\n\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n      }\n\n      return res;\n    };\n  }, {}],\n  89: [function (require, module, exports) {\n    'use strict';\n\n    exports.decode = exports.parse = require('./decode');\n    exports.encode = exports.stringify = require('./encode');\n  }, {\n    \"./decode\": 87,\n    \"./encode\": 88\n  }],\n  90: [function (require, module, exports) {\n    // Copyright Joyent, Inc. and other Node contributors.\n    //\n    // Permission is hereby granted, free of charge, to any person obtaining a\n    // copy of this software and associated documentation files (the\n    // \"Software\"), to deal in the Software without restriction, including\n    // without limitation the rights to use, copy, modify, merge, publish,\n    // distribute, sublicense, and/or sell copies of the Software, and to permit\n    // persons to whom the Software is furnished to do so, subject to the\n    // following conditions:\n    //\n    // The above copyright notice and this permission notice shall be included\n    // in all copies or substantial portions of the Software.\n    //\n    // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n    // USE OR OTHER DEALINGS IN THE SOFTWARE.\n    'use strict'; // If obj.hasOwnProperty has been overridden, then calling\n    // obj.hasOwnProperty(prop) will break.\n    // See: https://github.com/joyent/node/issues/1707\n\n    function hasOwnProperty(obj, prop) {\n      return Object.prototype.hasOwnProperty.call(obj, prop);\n    }\n\n    module.exports = function (qs, sep, eq, options) {\n      sep = sep || '&';\n      eq = eq || '=';\n      var obj = {};\n\n      if (typeof qs !== 'string' || qs.length === 0) {\n        return obj;\n      }\n\n      var regexp = /\\+/g;\n      qs = qs.split(sep);\n      var maxKeys = 1000;\n\n      if (options && typeof options.maxKeys === 'number') {\n        maxKeys = options.maxKeys;\n      }\n\n      var len = qs.length; // maxKeys <= 0 means that we should not limit keys count\n\n      if (maxKeys > 0 && len > maxKeys) {\n        len = maxKeys;\n      }\n\n      for (var i = 0; i < len; ++i) {\n        var x = qs[i].replace(regexp, '%20'),\n            idx = x.indexOf(eq),\n            kstr,\n            vstr,\n            k,\n            v;\n\n        if (idx >= 0) {\n          kstr = x.substr(0, idx);\n          vstr = x.substr(idx + 1);\n        } else {\n          kstr = x;\n          vstr = '';\n        }\n\n        k = decodeURIComponent(kstr);\n        v = decodeURIComponent(vstr);\n\n        if (!hasOwnProperty(obj, k)) {\n          obj[k] = v;\n        } else if (Array.isArray(obj[k])) {\n          obj[k].push(v);\n        } else {\n          obj[k] = [obj[k], v];\n        }\n      }\n\n      return obj;\n    };\n  }, {}],\n  91: [function (require, module, exports) {\n    // Copyright Joyent, Inc. and other Node contributors.\n    //\n    // Permission is hereby granted, free of charge, to any person obtaining a\n    // copy of this software and associated documentation files (the\n    // \"Software\"), to deal in the Software without restriction, including\n    // without limitation the rights to use, copy, modify, merge, publish,\n    // distribute, sublicense, and/or sell copies of the Software, and to permit\n    // persons to whom the Software is furnished to do so, subject to the\n    // following conditions:\n    //\n    // The above copyright notice and this permission notice shall be included\n    // in all copies or substantial portions of the Software.\n    //\n    // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n    // USE OR OTHER DEALINGS IN THE SOFTWARE.\n    'use strict';\n\n    var stringifyPrimitive = function (v) {\n      switch (typeof v) {\n        case 'string':\n          return v;\n\n        case 'boolean':\n          return v ? 'true' : 'false';\n\n        case 'number':\n          return isFinite(v) ? v : '';\n\n        default:\n          return '';\n      }\n    };\n\n    module.exports = function (obj, sep, eq, name) {\n      sep = sep || '&';\n      eq = eq || '=';\n\n      if (obj === null) {\n        obj = undefined;\n      }\n\n      if (typeof obj === 'object') {\n        return Object.keys(obj).map(function (k) {\n          var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n\n          if (Array.isArray(obj[k])) {\n            return obj[k].map(function (v) {\n              return ks + encodeURIComponent(stringifyPrimitive(v));\n            }).join(sep);\n          } else {\n            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n          }\n        }).join(sep);\n      }\n\n      if (!name) return '';\n      return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));\n    };\n  }, {}],\n  92: [function (require, module, exports) {\n    arguments[4][89][0].apply(exports, arguments);\n  }, {\n    \"./decode\": 90,\n    \"./encode\": 91,\n    \"dup\": 89\n  }],\n  93: [function (require, module, exports) {\n    (function (setImmediate, clearImmediate) {\n      (function () {\n        var nextTick = require('process/browser.js').nextTick;\n\n        var apply = Function.prototype.apply;\n        var slice = Array.prototype.slice;\n        var immediateIds = {};\n        var nextImmediateId = 0; // DOM APIs, for completeness\n\n        exports.setTimeout = function () {\n          return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n        };\n\n        exports.setInterval = function () {\n          return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n        };\n\n        exports.clearTimeout = exports.clearInterval = function (timeout) {\n          timeout.close();\n        };\n\n        function Timeout(id, clearFn) {\n          this._id = id;\n          this._clearFn = clearFn;\n        }\n\n        Timeout.prototype.unref = Timeout.prototype.ref = function () {};\n\n        Timeout.prototype.close = function () {\n          this._clearFn.call(window, this._id);\n        }; // Does not start the time, just sets up the members needed.\n\n\n        exports.enroll = function (item, msecs) {\n          clearTimeout(item._idleTimeoutId);\n          item._idleTimeout = msecs;\n        };\n\n        exports.unenroll = function (item) {\n          clearTimeout(item._idleTimeoutId);\n          item._idleTimeout = -1;\n        };\n\n        exports._unrefActive = exports.active = function (item) {\n          clearTimeout(item._idleTimeoutId);\n          var msecs = item._idleTimeout;\n\n          if (msecs >= 0) {\n            item._idleTimeoutId = setTimeout(function onTimeout() {\n              if (item._onTimeout) item._onTimeout();\n            }, msecs);\n          }\n        }; // That's not how node.js implements it but the exposed api is the same.\n\n\n        exports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function (fn) {\n          var id = nextImmediateId++;\n          var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n          immediateIds[id] = true;\n          nextTick(function onNextTick() {\n            if (immediateIds[id]) {\n              // fn.call() is faster so we optimize for the common use-case\n              // @see http://jsperf.com/call-apply-segu\n              if (args) {\n                fn.apply(null, args);\n              } else {\n                fn.call(null);\n              } // Prevent ids from leaking\n\n\n              exports.clearImmediate(id);\n            }\n          });\n          return id;\n        };\n        exports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function (id) {\n          delete immediateIds[id];\n        };\n      }).call(this);\n    }).call(this, require(\"timers\").setImmediate, require(\"timers\").clearImmediate);\n  }, {\n    \"process/browser.js\": 86,\n    \"timers\": 93\n  }],\n  94: [function (require, module, exports) {\n    // Copyright Joyent, Inc. and other Node contributors.\n    //\n    // Permission is hereby granted, free of charge, to any person obtaining a\n    // copy of this software and associated documentation files (the\n    // \"Software\"), to deal in the Software without restriction, including\n    // without limitation the rights to use, copy, modify, merge, publish,\n    // distribute, sublicense, and/or sell copies of the Software, and to permit\n    // persons to whom the Software is furnished to do so, subject to the\n    // following conditions:\n    //\n    // The above copyright notice and this permission notice shall be included\n    // in all copies or substantial portions of the Software.\n    //\n    // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n    // USE OR OTHER DEALINGS IN THE SOFTWARE.\n    var punycode = require('punycode');\n\n    exports.parse = urlParse;\n    exports.resolve = urlResolve;\n    exports.resolveObject = urlResolveObject;\n    exports.format = urlFormat;\n    exports.Url = Url;\n\n    function Url() {\n      this.protocol = null;\n      this.slashes = null;\n      this.auth = null;\n      this.host = null;\n      this.port = null;\n      this.hostname = null;\n      this.hash = null;\n      this.search = null;\n      this.query = null;\n      this.pathname = null;\n      this.path = null;\n      this.href = null;\n    } // Reference: RFC 3986, RFC 1808, RFC 2396\n    // define these here so at least they only have to be\n    // compiled once on the first module load.\n\n\n    var protocolPattern = /^([a-z0-9.+-]+:)/i,\n        portPattern = /:[0-9]*$/,\n        // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n        // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n        // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n        // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n        hostEndingChars = ['/', '?', '#'],\n        hostnameMaxLen = 255,\n        hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,\n        hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,\n        // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n        // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n        // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n        querystring = require('querystring');\n\n    function urlParse(url, parseQueryString, slashesDenoteHost) {\n      if (url && isObject(url) && url instanceof Url) return url;\n      var u = new Url();\n      u.parse(url, parseQueryString, slashesDenoteHost);\n      return u;\n    }\n\n    Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {\n      if (!isString(url)) {\n        throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n      }\n\n      var rest = url; // trim before proceeding.\n      // This is to support parse stuff like \"  http://foo.com  \\n\"\n\n      rest = rest.trim();\n      var proto = protocolPattern.exec(rest);\n\n      if (proto) {\n        proto = proto[0];\n        var lowerProto = proto.toLowerCase();\n        this.protocol = lowerProto;\n        rest = rest.substr(proto.length);\n      } // figure out if it's got a host\n      // user@server is *always* interpreted as a hostname, and url\n      // resolution will treat //foo/bar as host=foo,path=bar because that's\n      // how the browser resolves relative URLs.\n\n\n      if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n        var slashes = rest.substr(0, 2) === '//';\n\n        if (slashes && !(proto && hostlessProtocol[proto])) {\n          rest = rest.substr(2);\n          this.slashes = true;\n        }\n      }\n\n      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\n        // there's a hostname.\n        // the first instance of /, ?, ;, or # ends the host.\n        //\n        // If there is an @ in the hostname, then non-host chars *are* allowed\n        // to the left of the last @ sign, unless some host-ending character\n        // comes *before* the @-sign.\n        // URLs are obnoxious.\n        //\n        // ex:\n        // http://a@b@c/ => user:a@b host:c\n        // http://a@b?@c => user:a host:c path:/?@c\n        // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n        // Review our test case against browsers more comprehensively.\n        // find the first instance of any hostEndingChars\n        var hostEnd = -1;\n\n        for (var i = 0; i < hostEndingChars.length; i++) {\n          var hec = rest.indexOf(hostEndingChars[i]);\n          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n        } // at this point, either we have an explicit point where the\n        // auth portion cannot go past, or the last @ char is the decider.\n\n\n        var auth, atSign;\n\n        if (hostEnd === -1) {\n          // atSign can be anywhere.\n          atSign = rest.lastIndexOf('@');\n        } else {\n          // atSign must be in auth portion.\n          // http://a@b/c@d => host:b auth:a path:/c@d\n          atSign = rest.lastIndexOf('@', hostEnd);\n        } // Now we have a portion which is definitely the auth.\n        // Pull that off.\n\n\n        if (atSign !== -1) {\n          auth = rest.slice(0, atSign);\n          rest = rest.slice(atSign + 1);\n          this.auth = decodeURIComponent(auth);\n        } // the host is the remaining to the left of the first non-host char\n\n\n        hostEnd = -1;\n\n        for (var i = 0; i < nonHostChars.length; i++) {\n          var hec = rest.indexOf(nonHostChars[i]);\n          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n        } // if we still have not hit it, then the entire thing is a host.\n\n\n        if (hostEnd === -1) hostEnd = rest.length;\n        this.host = rest.slice(0, hostEnd);\n        rest = rest.slice(hostEnd); // pull out port.\n\n        this.parseHost(); // we've indicated that there is a hostname,\n        // so even if it's empty, it has to be present.\n\n        this.hostname = this.hostname || ''; // if hostname begins with [ and ends with ]\n        // assume that it's an IPv6 address.\n\n        var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']'; // validate a little.\n\n        if (!ipv6Hostname) {\n          var hostparts = this.hostname.split(/\\./);\n\n          for (var i = 0, l = hostparts.length; i < l; i++) {\n            var part = hostparts[i];\n            if (!part) continue;\n\n            if (!part.match(hostnamePartPattern)) {\n              var newpart = '';\n\n              for (var j = 0, k = part.length; j < k; j++) {\n                if (part.charCodeAt(j) > 127) {\n                  // we replace non-ASCII char with a temporary placeholder\n                  // we need this to make sure size of hostname is not\n                  // broken by replacing non-ASCII by nothing\n                  newpart += 'x';\n                } else {\n                  newpart += part[j];\n                }\n              } // we test again with ASCII char only\n\n\n              if (!newpart.match(hostnamePartPattern)) {\n                var validParts = hostparts.slice(0, i);\n                var notHost = hostparts.slice(i + 1);\n                var bit = part.match(hostnamePartStart);\n\n                if (bit) {\n                  validParts.push(bit[1]);\n                  notHost.unshift(bit[2]);\n                }\n\n                if (notHost.length) {\n                  rest = '/' + notHost.join('.') + rest;\n                }\n\n                this.hostname = validParts.join('.');\n                break;\n              }\n            }\n          }\n        }\n\n        if (this.hostname.length > hostnameMaxLen) {\n          this.hostname = '';\n        } else {\n          // hostnames are always lower case.\n          this.hostname = this.hostname.toLowerCase();\n        }\n\n        if (!ipv6Hostname) {\n          // IDNA Support: Returns a puny coded representation of \"domain\".\n          // It only converts the part of the domain name that\n          // has non ASCII characters. I.e. it dosent matter if\n          // you call it with a domain that already is in ASCII.\n          var domainArray = this.hostname.split('.');\n          var newOut = [];\n\n          for (var i = 0; i < domainArray.length; ++i) {\n            var s = domainArray[i];\n            newOut.push(s.match(/[^A-Za-z0-9_-]/) ? 'xn--' + punycode.encode(s) : s);\n          }\n\n          this.hostname = newOut.join('.');\n        }\n\n        var p = this.port ? ':' + this.port : '';\n        var h = this.hostname || '';\n        this.host = h + p;\n        this.href += this.host; // strip [ and ] from the hostname\n        // the host field still retains them, though\n\n        if (ipv6Hostname) {\n          this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n\n          if (rest[0] !== '/') {\n            rest = '/' + rest;\n          }\n        }\n      } // now rest is set to the post-host stuff.\n      // chop off any delim chars.\n\n\n      if (!unsafeProtocol[lowerProto]) {\n        // First, make 100% sure that any \"autoEscape\" chars get\n        // escaped, even if encodeURIComponent doesn't think they\n        // need to be.\n        for (var i = 0, l = autoEscape.length; i < l; i++) {\n          var ae = autoEscape[i];\n          var esc = encodeURIComponent(ae);\n\n          if (esc === ae) {\n            esc = escape(ae);\n          }\n\n          rest = rest.split(ae).join(esc);\n        }\n      } // chop off from the tail first.\n\n\n      var hash = rest.indexOf('#');\n\n      if (hash !== -1) {\n        // got a fragment string.\n        this.hash = rest.substr(hash);\n        rest = rest.slice(0, hash);\n      }\n\n      var qm = rest.indexOf('?');\n\n      if (qm !== -1) {\n        this.search = rest.substr(qm);\n        this.query = rest.substr(qm + 1);\n\n        if (parseQueryString) {\n          this.query = querystring.parse(this.query);\n        }\n\n        rest = rest.slice(0, qm);\n      } else if (parseQueryString) {\n        // no query string, but parseQueryString still requested\n        this.search = '';\n        this.query = {};\n      }\n\n      if (rest) this.pathname = rest;\n\n      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n        this.pathname = '/';\n      } //to support http.request\n\n\n      if (this.pathname || this.search) {\n        var p = this.pathname || '';\n        var s = this.search || '';\n        this.path = p + s;\n      } // finally, reconstruct the href based on what has been validated.\n\n\n      this.href = this.format();\n      return this;\n    }; // format a parsed object into a url string\n\n\n    function urlFormat(obj) {\n      // ensure it's an object, and not a string url.\n      // If it's an obj, this is a no-op.\n      // this way, you can call url_format() on strings\n      // to clean up potentially wonky urls.\n      if (isString(obj)) obj = urlParse(obj);\n      if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n      return obj.format();\n    }\n\n    Url.prototype.format = function () {\n      var auth = this.auth || '';\n\n      if (auth) {\n        auth = encodeURIComponent(auth);\n        auth = auth.replace(/%3A/i, ':');\n        auth += '@';\n      }\n\n      var protocol = this.protocol || '',\n          pathname = this.pathname || '',\n          hash = this.hash || '',\n          host = false,\n          query = '';\n\n      if (this.host) {\n        host = auth + this.host;\n      } else if (this.hostname) {\n        host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');\n\n        if (this.port) {\n          host += ':' + this.port;\n        }\n      }\n\n      if (this.query && isObject(this.query) && Object.keys(this.query).length) {\n        query = querystring.stringify(this.query);\n      }\n\n      var search = this.search || query && '?' + query || '';\n      if (protocol && protocol.substr(-1) !== ':') protocol += ':'; // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n      // unless they had them to begin with.\n\n      if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {\n        host = '//' + (host || '');\n        if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n      } else if (!host) {\n        host = '';\n      }\n\n      if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n      if (search && search.charAt(0) !== '?') search = '?' + search;\n      pathname = pathname.replace(/[?#]/g, function (match) {\n        return encodeURIComponent(match);\n      });\n      search = search.replace('#', '%23');\n      return protocol + host + pathname + search + hash;\n    };\n\n    function urlResolve(source, relative) {\n      return urlParse(source, false, true).resolve(relative);\n    }\n\n    Url.prototype.resolve = function (relative) {\n      return this.resolveObject(urlParse(relative, false, true)).format();\n    };\n\n    function urlResolveObject(source, relative) {\n      if (!source) return relative;\n      return urlParse(source, false, true).resolveObject(relative);\n    }\n\n    Url.prototype.resolveObject = function (relative) {\n      if (isString(relative)) {\n        var rel = new Url();\n        rel.parse(relative, false, true);\n        relative = rel;\n      }\n\n      var result = new Url();\n      Object.keys(this).forEach(function (k) {\n        result[k] = this[k];\n      }, this); // hash is always overridden, no matter what.\n      // even href=\"\" will remove it.\n\n      result.hash = relative.hash; // if the relative url is empty, then there's nothing left to do here.\n\n      if (relative.href === '') {\n        result.href = result.format();\n        return result;\n      } // hrefs like //foo/bar always cut to the protocol.\n\n\n      if (relative.slashes && !relative.protocol) {\n        // take everything except the protocol from relative\n        Object.keys(relative).forEach(function (k) {\n          if (k !== 'protocol') result[k] = relative[k];\n        }); //urlParse appends trailing / to urls like http://www.example.com\n\n        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {\n          result.path = result.pathname = '/';\n        }\n\n        result.href = result.format();\n        return result;\n      }\n\n      if (relative.protocol && relative.protocol !== result.protocol) {\n        // if it's a known url protocol, then changing\n        // the protocol does weird things\n        // first, if it's not file:, then we MUST have a host,\n        // and if there was a path\n        // to begin with, then we MUST have a path.\n        // if it is file:, then the host is dropped,\n        // because that's known to be hostless.\n        // anything else is assumed to be absolute.\n        if (!slashedProtocol[relative.protocol]) {\n          Object.keys(relative).forEach(function (k) {\n            result[k] = relative[k];\n          });\n          result.href = result.format();\n          return result;\n        }\n\n        result.protocol = relative.protocol;\n\n        if (!relative.host && !hostlessProtocol[relative.protocol]) {\n          var relPath = (relative.pathname || '').split('/');\n\n          while (relPath.length && !(relative.host = relPath.shift()));\n\n          if (!relative.host) relative.host = '';\n          if (!relative.hostname) relative.hostname = '';\n          if (relPath[0] !== '') relPath.unshift('');\n          if (relPath.length < 2) relPath.unshift('');\n          result.pathname = relPath.join('/');\n        } else {\n          result.pathname = relative.pathname;\n        }\n\n        result.search = relative.search;\n        result.query = relative.query;\n        result.host = relative.host || '';\n        result.auth = relative.auth;\n        result.hostname = relative.hostname || relative.host;\n        result.port = relative.port; // to support http.request\n\n        if (result.pathname || result.search) {\n          var p = result.pathname || '';\n          var s = result.search || '';\n          result.path = p + s;\n        }\n\n        result.slashes = result.slashes || relative.slashes;\n        result.href = result.format();\n        return result;\n      }\n\n      var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',\n          isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',\n          mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,\n          removeAllDots = mustEndAbs,\n          srcPath = result.pathname && result.pathname.split('/') || [],\n          relPath = relative.pathname && relative.pathname.split('/') || [],\n          psychotic = result.protocol && !slashedProtocol[result.protocol]; // if the url is a non-slashed url, then relative\n      // links like ../.. should be able\n      // to crawl up to the hostname, as well.  This is strange.\n      // result.protocol has already been set by now.\n      // Later on, put the first path part into the host field.\n\n      if (psychotic) {\n        result.hostname = '';\n        result.port = null;\n\n        if (result.host) {\n          if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);\n        }\n\n        result.host = '';\n\n        if (relative.protocol) {\n          relative.hostname = null;\n          relative.port = null;\n\n          if (relative.host) {\n            if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);\n          }\n\n          relative.host = null;\n        }\n\n        mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n      }\n\n      if (isRelAbs) {\n        // it's absolute.\n        result.host = relative.host || relative.host === '' ? relative.host : result.host;\n        result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;\n        result.search = relative.search;\n        result.query = relative.query;\n        srcPath = relPath; // fall through to the dot-handling below.\n      } else if (relPath.length) {\n        // it's relative\n        // throw away the existing file, and take the new path instead.\n        if (!srcPath) srcPath = [];\n        srcPath.pop();\n        srcPath = srcPath.concat(relPath);\n        result.search = relative.search;\n        result.query = relative.query;\n      } else if (!isNullOrUndefined(relative.search)) {\n        // just pull out the search.\n        // like href='?foo'.\n        // Put this after the other two cases because it simplifies the booleans\n        if (psychotic) {\n          result.hostname = result.host = srcPath.shift(); //occationaly the auth can get stuck only in host\n          //this especialy happens in cases like\n          //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n\n          var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n\n          if (authInHost) {\n            result.auth = authInHost.shift();\n            result.host = result.hostname = authInHost.shift();\n          }\n        }\n\n        result.search = relative.search;\n        result.query = relative.query; //to support http.request\n\n        if (!isNull(result.pathname) || !isNull(result.search)) {\n          result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n        }\n\n        result.href = result.format();\n        return result;\n      }\n\n      if (!srcPath.length) {\n        // no path at all.  easy.\n        // we've already handled the other stuff above.\n        result.pathname = null; //to support http.request\n\n        if (result.search) {\n          result.path = '/' + result.search;\n        } else {\n          result.path = null;\n        }\n\n        result.href = result.format();\n        return result;\n      } // if a url ENDs in . or .., then it must get a trailing slash.\n      // however, if it ends in anything else non-slashy,\n      // then it must NOT get a trailing slash.\n\n\n      var last = srcPath.slice(-1)[0];\n      var hasTrailingSlash = (result.host || relative.host) && (last === '.' || last === '..') || last === ''; // strip single dots, resolve double dots to parent dir\n      // if the path tries to go above the root, `up` ends up > 0\n\n      var up = 0;\n\n      for (var i = srcPath.length; i >= 0; i--) {\n        last = srcPath[i];\n\n        if (last == '.') {\n          srcPath.splice(i, 1);\n        } else if (last === '..') {\n          srcPath.splice(i, 1);\n          up++;\n        } else if (up) {\n          srcPath.splice(i, 1);\n          up--;\n        }\n      } // if the path is allowed to go above the root, restore leading ..s\n\n\n      if (!mustEndAbs && !removeAllDots) {\n        for (; up--; up) {\n          srcPath.unshift('..');\n        }\n      }\n\n      if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n        srcPath.unshift('');\n      }\n\n      if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {\n        srcPath.push('');\n      }\n\n      var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/'; // put the host back\n\n      if (psychotic) {\n        result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : ''; //occationaly the auth can get stuck only in host\n        //this especialy happens in cases like\n        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n\n        var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n\n        if (authInHost) {\n          result.auth = authInHost.shift();\n          result.host = result.hostname = authInHost.shift();\n        }\n      }\n\n      mustEndAbs = mustEndAbs || result.host && srcPath.length;\n\n      if (mustEndAbs && !isAbsolute) {\n        srcPath.unshift('');\n      }\n\n      if (!srcPath.length) {\n        result.pathname = null;\n        result.path = null;\n      } else {\n        result.pathname = srcPath.join('/');\n      } //to support request.http\n\n\n      if (!isNull(result.pathname) || !isNull(result.search)) {\n        result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n      }\n\n      result.auth = relative.auth || result.auth;\n      result.slashes = result.slashes || relative.slashes;\n      result.href = result.format();\n      return result;\n    };\n\n    Url.prototype.parseHost = function () {\n      var host = this.host;\n      var port = portPattern.exec(host);\n\n      if (port) {\n        port = port[0];\n\n        if (port !== ':') {\n          this.port = port.substr(1);\n        }\n\n        host = host.substr(0, host.length - port.length);\n      }\n\n      if (host) this.hostname = host;\n    };\n\n    function isString(arg) {\n      return typeof arg === \"string\";\n    }\n\n    function isObject(arg) {\n      return typeof arg === 'object' && arg !== null;\n    }\n\n    function isNull(arg) {\n      return arg === null;\n    }\n\n    function isNullOrUndefined(arg) {\n      return arg == null;\n    }\n  }, {\n    \"punycode\": 80,\n    \"querystring\": 89\n  }],\n  95: [function (require, module, exports) {\n    if (typeof Object.create === 'function') {\n      // implementation from standard node.js 'util' module\n      module.exports = function inherits(ctor, superCtor) {\n        ctor.super_ = superCtor;\n        ctor.prototype = Object.create(superCtor.prototype, {\n          constructor: {\n            value: ctor,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n      };\n    } else {\n      // old school shim for old browsers\n      module.exports = function inherits(ctor, superCtor) {\n        ctor.super_ = superCtor;\n\n        var TempCtor = function () {};\n\n        TempCtor.prototype = superCtor.prototype;\n        ctor.prototype = new TempCtor();\n        ctor.prototype.constructor = ctor;\n      };\n    }\n  }, {}],\n  96: [function (require, module, exports) {\n    module.exports = function isBuffer(arg) {\n      return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';\n    };\n  }, {}],\n  97: [function (require, module, exports) {\n    (function (process, global) {\n      (function () {\n        // Copyright Joyent, Inc. and other Node contributors.\n        //\n        // Permission is hereby granted, free of charge, to any person obtaining a\n        // copy of this software and associated documentation files (the\n        // \"Software\"), to deal in the Software without restriction, including\n        // without limitation the rights to use, copy, modify, merge, publish,\n        // distribute, sublicense, and/or sell copies of the Software, and to permit\n        // persons to whom the Software is furnished to do so, subject to the\n        // following conditions:\n        //\n        // The above copyright notice and this permission notice shall be included\n        // in all copies or substantial portions of the Software.\n        //\n        // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n        // USE OR OTHER DEALINGS IN THE SOFTWARE.\n        var formatRegExp = /%[sdj%]/g;\n\n        exports.format = function (f) {\n          if (!isString(f)) {\n            var objects = [];\n\n            for (var i = 0; i < arguments.length; i++) {\n              objects.push(inspect(arguments[i]));\n            }\n\n            return objects.join(' ');\n          }\n\n          var i = 1;\n          var args = arguments;\n          var len = args.length;\n          var str = String(f).replace(formatRegExp, function (x) {\n            if (x === '%%') return '%';\n            if (i >= len) return x;\n\n            switch (x) {\n              case '%s':\n                return String(args[i++]);\n\n              case '%d':\n                return Number(args[i++]);\n\n              case '%j':\n                try {\n                  return JSON.stringify(args[i++]);\n                } catch (_) {\n                  return '[Circular]';\n                }\n\n              default:\n                return x;\n            }\n          });\n\n          for (var x = args[i]; i < len; x = args[++i]) {\n            if (isNull(x) || !isObject(x)) {\n              str += ' ' + x;\n            } else {\n              str += ' ' + inspect(x);\n            }\n          }\n\n          return str;\n        }; // Mark that a method should not be used.\n        // Returns a modified function which warns once by default.\n        // If --no-deprecation is set, then it is a no-op.\n\n\n        exports.deprecate = function (fn, msg) {\n          // Allow for deprecating things in the process of starting up.\n          if (isUndefined(global.process)) {\n            return function () {\n              return exports.deprecate(fn, msg).apply(this, arguments);\n            };\n          }\n\n          if (process.noDeprecation === true) {\n            return fn;\n          }\n\n          var warned = false;\n\n          function deprecated() {\n            if (!warned) {\n              if (process.throwDeprecation) {\n                throw new Error(msg);\n              } else if (process.traceDeprecation) {\n                console.trace(msg);\n              } else {\n                console.error(msg);\n              }\n\n              warned = true;\n            }\n\n            return fn.apply(this, arguments);\n          }\n\n          return deprecated;\n        };\n\n        var debugs = {};\n        var debugEnviron;\n\n        exports.debuglog = function (set) {\n          if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';\n          set = set.toUpperCase();\n\n          if (!debugs[set]) {\n            if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n              var pid = process.pid;\n\n              debugs[set] = function () {\n                var msg = exports.format.apply(exports, arguments);\n                console.error('%s %d: %s', set, pid, msg);\n              };\n            } else {\n              debugs[set] = function () {};\n            }\n          }\n\n          return debugs[set];\n        };\n        /**\n         * Echos the value of a value. Trys to print the value out\n         * in the best way possible given the different types.\n         *\n         * @param {Object} obj The object to print out.\n         * @param {Object} opts Optional options object that alters the output.\n         */\n\n        /* legacy: obj, showHidden, depth, colors*/\n\n\n        function inspect(obj, opts) {\n          // default options\n          var ctx = {\n            seen: [],\n            stylize: stylizeNoColor\n          }; // legacy...\n\n          if (arguments.length >= 3) ctx.depth = arguments[2];\n          if (arguments.length >= 4) ctx.colors = arguments[3];\n\n          if (isBoolean(opts)) {\n            // legacy...\n            ctx.showHidden = opts;\n          } else if (opts) {\n            // got an \"options\" object\n            exports._extend(ctx, opts);\n          } // set default options\n\n\n          if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n          if (isUndefined(ctx.depth)) ctx.depth = 2;\n          if (isUndefined(ctx.colors)) ctx.colors = false;\n          if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n          if (ctx.colors) ctx.stylize = stylizeWithColor;\n          return formatValue(ctx, obj, ctx.depth);\n        }\n\n        exports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n\n        inspect.colors = {\n          'bold': [1, 22],\n          'italic': [3, 23],\n          'underline': [4, 24],\n          'inverse': [7, 27],\n          'white': [37, 39],\n          'grey': [90, 39],\n          'black': [30, 39],\n          'blue': [34, 39],\n          'cyan': [36, 39],\n          'green': [32, 39],\n          'magenta': [35, 39],\n          'red': [31, 39],\n          'yellow': [33, 39]\n        }; // Don't use 'blue' not visible on cmd.exe\n\n        inspect.styles = {\n          'special': 'cyan',\n          'number': 'yellow',\n          'boolean': 'yellow',\n          'undefined': 'grey',\n          'null': 'bold',\n          'string': 'green',\n          'date': 'magenta',\n          // \"name\": intentionally not styling\n          'regexp': 'red'\n        };\n\n        function stylizeWithColor(str, styleType) {\n          var style = inspect.styles[styleType];\n\n          if (style) {\n            return '\\u001b[' + inspect.colors[style][0] + 'm' + str + '\\u001b[' + inspect.colors[style][1] + 'm';\n          } else {\n            return str;\n          }\n        }\n\n        function stylizeNoColor(str, styleType) {\n          return str;\n        }\n\n        function arrayToHash(array) {\n          var hash = {};\n          array.forEach(function (val, idx) {\n            hash[val] = true;\n          });\n          return hash;\n        }\n\n        function formatValue(ctx, value, recurseTimes) {\n          // Provide a hook for user-specified inspect functions.\n          // Check that value is an object with an inspect function on it\n          if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special\n          value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.\n          !(value.constructor && value.constructor.prototype === value)) {\n            var ret = value.inspect(recurseTimes, ctx);\n\n            if (!isString(ret)) {\n              ret = formatValue(ctx, ret, recurseTimes);\n            }\n\n            return ret;\n          } // Primitive types cannot have properties\n\n\n          var primitive = formatPrimitive(ctx, value);\n\n          if (primitive) {\n            return primitive;\n          } // Look up the keys of the object.\n\n\n          var keys = Object.keys(value);\n          var visibleKeys = arrayToHash(keys);\n\n          if (ctx.showHidden) {\n            keys = Object.getOwnPropertyNames(value);\n          } // IE doesn't make error fields non-enumerable\n          // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n\n\n          if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n            return formatError(value);\n          } // Some type of object without properties can be shortcutted.\n\n\n          if (keys.length === 0) {\n            if (isFunction(value)) {\n              var name = value.name ? ': ' + value.name : '';\n              return ctx.stylize('[Function' + name + ']', 'special');\n            }\n\n            if (isRegExp(value)) {\n              return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n            }\n\n            if (isDate(value)) {\n              return ctx.stylize(Date.prototype.toString.call(value), 'date');\n            }\n\n            if (isError(value)) {\n              return formatError(value);\n            }\n          }\n\n          var base = '',\n              array = false,\n              braces = ['{', '}']; // Make Array say that they are Array\n\n          if (isArray(value)) {\n            array = true;\n            braces = ['[', ']'];\n          } // Make functions say that they are functions\n\n\n          if (isFunction(value)) {\n            var n = value.name ? ': ' + value.name : '';\n            base = ' [Function' + n + ']';\n          } // Make RegExps say that they are RegExps\n\n\n          if (isRegExp(value)) {\n            base = ' ' + RegExp.prototype.toString.call(value);\n          } // Make dates with properties first say the date\n\n\n          if (isDate(value)) {\n            base = ' ' + Date.prototype.toUTCString.call(value);\n          } // Make error with message first say the error\n\n\n          if (isError(value)) {\n            base = ' ' + formatError(value);\n          }\n\n          if (keys.length === 0 && (!array || value.length == 0)) {\n            return braces[0] + base + braces[1];\n          }\n\n          if (recurseTimes < 0) {\n            if (isRegExp(value)) {\n              return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n            } else {\n              return ctx.stylize('[Object]', 'special');\n            }\n          }\n\n          ctx.seen.push(value);\n          var output;\n\n          if (array) {\n            output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n          } else {\n            output = keys.map(function (key) {\n              return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n            });\n          }\n\n          ctx.seen.pop();\n          return reduceToSingleString(output, base, braces);\n        }\n\n        function formatPrimitive(ctx, value) {\n          if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');\n\n          if (isString(value)) {\n            var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '').replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + '\\'';\n            return ctx.stylize(simple, 'string');\n          }\n\n          if (isNumber(value)) return ctx.stylize('' + value, 'number');\n          if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is \"object\", so special case here.\n\n          if (isNull(value)) return ctx.stylize('null', 'null');\n        }\n\n        function formatError(value) {\n          return '[' + Error.prototype.toString.call(value) + ']';\n        }\n\n        function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n          var output = [];\n\n          for (var i = 0, l = value.length; i < l; ++i) {\n            if (hasOwnProperty(value, String(i))) {\n              output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));\n            } else {\n              output.push('');\n            }\n          }\n\n          keys.forEach(function (key) {\n            if (!key.match(/^\\d+$/)) {\n              output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));\n            }\n          });\n          return output;\n        }\n\n        function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n          var name, str, desc;\n          desc = Object.getOwnPropertyDescriptor(value, key) || {\n            value: value[key]\n          };\n\n          if (desc.get) {\n            if (desc.set) {\n              str = ctx.stylize('[Getter/Setter]', 'special');\n            } else {\n              str = ctx.stylize('[Getter]', 'special');\n            }\n          } else {\n            if (desc.set) {\n              str = ctx.stylize('[Setter]', 'special');\n            }\n          }\n\n          if (!hasOwnProperty(visibleKeys, key)) {\n            name = '[' + key + ']';\n          }\n\n          if (!str) {\n            if (ctx.seen.indexOf(desc.value) < 0) {\n              if (isNull(recurseTimes)) {\n                str = formatValue(ctx, desc.value, null);\n              } else {\n                str = formatValue(ctx, desc.value, recurseTimes - 1);\n              }\n\n              if (str.indexOf('\\n') > -1) {\n                if (array) {\n                  str = str.split('\\n').map(function (line) {\n                    return '  ' + line;\n                  }).join('\\n').substr(2);\n                } else {\n                  str = '\\n' + str.split('\\n').map(function (line) {\n                    return '   ' + line;\n                  }).join('\\n');\n                }\n              }\n            } else {\n              str = ctx.stylize('[Circular]', 'special');\n            }\n          }\n\n          if (isUndefined(name)) {\n            if (array && key.match(/^\\d+$/)) {\n              return str;\n            }\n\n            name = JSON.stringify('' + key);\n\n            if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n              name = name.substr(1, name.length - 2);\n              name = ctx.stylize(name, 'name');\n            } else {\n              name = name.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n              name = ctx.stylize(name, 'string');\n            }\n          }\n\n          return name + ': ' + str;\n        }\n\n        function reduceToSingleString(output, base, braces) {\n          var numLinesEst = 0;\n          var length = output.reduce(function (prev, cur) {\n            numLinesEst++;\n            if (cur.indexOf('\\n') >= 0) numLinesEst++;\n            return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n          }, 0);\n\n          if (length > 60) {\n            return braces[0] + (base === '' ? '' : base + '\\n ') + ' ' + output.join(',\\n  ') + ' ' + braces[1];\n          }\n\n          return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n        } // NOTE: These type checking functions intentionally don't use `instanceof`\n        // because it is fragile and can be easily faked with `Object.create()`.\n\n\n        function isArray(ar) {\n          return Array.isArray(ar);\n        }\n\n        exports.isArray = isArray;\n\n        function isBoolean(arg) {\n          return typeof arg === 'boolean';\n        }\n\n        exports.isBoolean = isBoolean;\n\n        function isNull(arg) {\n          return arg === null;\n        }\n\n        exports.isNull = isNull;\n\n        function isNullOrUndefined(arg) {\n          return arg == null;\n        }\n\n        exports.isNullOrUndefined = isNullOrUndefined;\n\n        function isNumber(arg) {\n          return typeof arg === 'number';\n        }\n\n        exports.isNumber = isNumber;\n\n        function isString(arg) {\n          return typeof arg === 'string';\n        }\n\n        exports.isString = isString;\n\n        function isSymbol(arg) {\n          return typeof arg === 'symbol';\n        }\n\n        exports.isSymbol = isSymbol;\n\n        function isUndefined(arg) {\n          return arg === void 0;\n        }\n\n        exports.isUndefined = isUndefined;\n\n        function isRegExp(re) {\n          return isObject(re) && objectToString(re) === '[object RegExp]';\n        }\n\n        exports.isRegExp = isRegExp;\n\n        function isObject(arg) {\n          return typeof arg === 'object' && arg !== null;\n        }\n\n        exports.isObject = isObject;\n\n        function isDate(d) {\n          return isObject(d) && objectToString(d) === '[object Date]';\n        }\n\n        exports.isDate = isDate;\n\n        function isError(e) {\n          return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);\n        }\n\n        exports.isError = isError;\n\n        function isFunction(arg) {\n          return typeof arg === 'function';\n        }\n\n        exports.isFunction = isFunction;\n\n        function isPrimitive(arg) {\n          return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol\n          typeof arg === 'undefined';\n        }\n\n        exports.isPrimitive = isPrimitive;\n        exports.isBuffer = require('./support/isBuffer');\n\n        function objectToString(o) {\n          return Object.prototype.toString.call(o);\n        }\n\n        function pad(n) {\n          return n < 10 ? '0' + n.toString(10) : n.toString(10);\n        }\n\n        var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34\n\n        function timestamp() {\n          var d = new Date();\n          var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');\n          return [d.getDate(), months[d.getMonth()], time].join(' ');\n        } // log is just a thin wrapper to console.log that prepends a timestamp\n\n\n        exports.log = function () {\n          console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n        };\n        /**\n         * Inherit the prototype methods from one constructor into another.\n         *\n         * The Function.prototype.inherits from lang.js rewritten as a standalone\n         * function (not on Function.prototype). NOTE: If this file is to be loaded\n         * during bootstrapping this function needs to be rewritten using some native\n         * functions as prototype setup using normal JavaScript does not work as\n         * expected during bootstrapping (see mirror.js in r114903).\n         *\n         * @param {function} ctor Constructor function which needs to inherit the\n         *     prototype.\n         * @param {function} superCtor Constructor function to inherit prototype from.\n         */\n\n\n        exports.inherits = require('inherits');\n\n        exports._extend = function (origin, add) {\n          // Don't do anything if add isn't an object\n          if (!add || !isObject(add)) return origin;\n          var keys = Object.keys(add);\n          var i = keys.length;\n\n          while (i--) {\n            origin[keys[i]] = add[keys[i]];\n          }\n\n          return origin;\n        };\n\n        function hasOwnProperty(obj, prop) {\n          return Object.prototype.hasOwnProperty.call(obj, prop);\n        }\n      }).call(this);\n    }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n  }, {\n    \"./support/isBuffer\": 96,\n    \"_process\": 86,\n    \"inherits\": 95\n  }],\n  98: [function (require, module, exports) {\n    var v1 = require('./v1');\n\n    var v4 = require('./v4');\n\n    var uuid = v4;\n    uuid.v1 = v1;\n    uuid.v4 = v4;\n    module.exports = uuid;\n  }, {\n    \"./v1\": 101,\n    \"./v4\": 102\n  }],\n  99: [function (require, module, exports) {\n    /**\n     * Convert array of 16 byte values to UUID string format of the form:\n     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n     */\n    var byteToHex = [];\n\n    for (var i = 0; i < 256; ++i) {\n      byteToHex[i] = (i + 0x100).toString(16).substr(1);\n    }\n\n    function bytesToUuid(buf, offset) {\n      var i = offset || 0;\n      var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\n      return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');\n    }\n\n    module.exports = bytesToUuid;\n  }, {}],\n  100: [function (require, module, exports) {\n    // Unique ID creation requires a high quality random # generator.  In the\n    // browser this is a little complicated due to unknown quality of Math.random()\n    // and inconsistent support for the `crypto` API.  We do the best we can via\n    // feature-detection\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n    // implementation. Also, find the complete implementation of crypto on IE11.\n    var getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (getRandomValues) {\n      // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n      var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n      module.exports = function whatwgRNG() {\n        getRandomValues(rnds8);\n        return rnds8;\n      };\n    } else {\n      // Math.random()-based (RNG)\n      //\n      // If all else fails, use Math.random().  It's fast, but is of unspecified\n      // quality.\n      var rnds = new Array(16);\n\n      module.exports = function mathRNG() {\n        for (var i = 0, r; i < 16; i++) {\n          if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n          rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n        }\n\n        return rnds;\n      };\n    }\n  }, {}],\n  101: [function (require, module, exports) {\n    var rng = require('./lib/rng');\n\n    var bytesToUuid = require('./lib/bytesToUuid'); // **`v1()` - Generate time-based UUID**\n    //\n    // Inspired by https://github.com/LiosK/UUID.js\n    // and http://docs.python.org/library/uuid.html\n\n\n    var _nodeId;\n\n    var _clockseq; // Previous uuid creation time\n\n\n    var _lastMSecs = 0;\n    var _lastNSecs = 0; // See https://github.com/broofa/node-uuid for API details\n\n    function v1(options, buf, offset) {\n      var i = buf && offset || 0;\n      var b = buf || [];\n      options = options || {};\n      var node = options.node || _nodeId;\n      var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n      // specified.  We do this lazily to minimize issues related to insufficient\n      // system entropy.  See #189\n\n      if (node == null || clockseq == null) {\n        var seedBytes = rng();\n\n        if (node == null) {\n          // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n          node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n        }\n\n        if (clockseq == null) {\n          // Per 4.2.2, randomize (14 bit) clockseq\n          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n        }\n      } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n      // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n      // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n      // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n      var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n      // cycle to simulate higher resolution clock\n\n      var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n      var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n      if (dt < 0 && options.clockseq === undefined) {\n        clockseq = clockseq + 1 & 0x3fff;\n      } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n      // time interval\n\n\n      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n        nsecs = 0;\n      } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n      if (nsecs >= 10000) {\n        throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n      }\n\n      _lastMSecs = msecs;\n      _lastNSecs = nsecs;\n      _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n      msecs += 12219292800000; // `time_low`\n\n      var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n      b[i++] = tl >>> 24 & 0xff;\n      b[i++] = tl >>> 16 & 0xff;\n      b[i++] = tl >>> 8 & 0xff;\n      b[i++] = tl & 0xff; // `time_mid`\n\n      var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n      b[i++] = tmh >>> 8 & 0xff;\n      b[i++] = tmh & 0xff; // `time_high_and_version`\n\n      b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n      b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n      b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n      b[i++] = clockseq & 0xff; // `node`\n\n      for (var n = 0; n < 6; ++n) {\n        b[i + n] = node[n];\n      }\n\n      return buf ? buf : bytesToUuid(b);\n    }\n\n    module.exports = v1;\n  }, {\n    \"./lib/bytesToUuid\": 99,\n    \"./lib/rng\": 100\n  }],\n  102: [function (require, module, exports) {\n    var rng = require('./lib/rng');\n\n    var bytesToUuid = require('./lib/bytesToUuid');\n\n    function v4(options, buf, offset) {\n      var i = buf && offset || 0;\n\n      if (typeof options == 'string') {\n        buf = options === 'binary' ? new Array(16) : null;\n        options = null;\n      }\n\n      options = options || {};\n      var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n      rnds[6] = rnds[6] & 0x0f | 0x40;\n      rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n      if (buf) {\n        for (var ii = 0; ii < 16; ++ii) {\n          buf[i + ii] = rnds[ii];\n        }\n      }\n\n      return buf || bytesToUuid(rnds);\n    }\n\n    module.exports = v4;\n  }, {\n    \"./lib/bytesToUuid\": 99,\n    \"./lib/rng\": 100\n  }],\n  103: [function (require, module, exports) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var LRU_1 = require(\"./utils/LRU\");\n\n    var CACHE_SIZE = 1000;\n    /**\n     * Inspired node-lru-cache[https://github.com/isaacs/node-lru-cache]\n     */\n\n    var EndpointCache = function () {\n      function EndpointCache(maxSize) {\n        if (maxSize === void 0) {\n          maxSize = CACHE_SIZE;\n        }\n\n        this.maxSize = maxSize;\n        this.cache = new LRU_1.LRUCache(maxSize);\n      }\n\n      ;\n      Object.defineProperty(EndpointCache.prototype, \"size\", {\n        get: function () {\n          return this.cache.length;\n        },\n        enumerable: true,\n        configurable: true\n      });\n\n      EndpointCache.prototype.put = function (key, value) {\n        var keyString = typeof key !== 'string' ? EndpointCache.getKeyString(key) : key;\n        var endpointRecord = this.populateValue(value);\n        this.cache.put(keyString, endpointRecord);\n      };\n\n      EndpointCache.prototype.get = function (key) {\n        var keyString = typeof key !== 'string' ? EndpointCache.getKeyString(key) : key;\n        var now = Date.now();\n        var records = this.cache.get(keyString);\n\n        if (records) {\n          for (var i = 0; i < records.length; i++) {\n            var record = records[i];\n\n            if (record.Expire < now) {\n              this.cache.remove(keyString);\n              return undefined;\n            }\n          }\n        }\n\n        return records;\n      };\n\n      EndpointCache.getKeyString = function (key) {\n        var identifiers = [];\n        var identifierNames = Object.keys(key).sort();\n\n        for (var i = 0; i < identifierNames.length; i++) {\n          var identifierName = identifierNames[i];\n          if (key[identifierName] === undefined) continue;\n          identifiers.push(key[identifierName]);\n        }\n\n        return identifiers.join(' ');\n      };\n\n      EndpointCache.prototype.populateValue = function (endpoints) {\n        var now = Date.now();\n        return endpoints.map(function (endpoint) {\n          return {\n            Address: endpoint.Address || '',\n            Expire: now + (endpoint.CachePeriodInMinutes || 1) * 60 * 1000\n          };\n        });\n      };\n\n      EndpointCache.prototype.empty = function () {\n        this.cache.empty();\n      };\n\n      EndpointCache.prototype.remove = function (key) {\n        var keyString = typeof key !== 'string' ? EndpointCache.getKeyString(key) : key;\n        this.cache.remove(keyString);\n      };\n\n      return EndpointCache;\n    }();\n\n    exports.EndpointCache = EndpointCache;\n  }, {\n    \"./utils/LRU\": 104\n  }],\n  104: [function (require, module, exports) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var LinkedListNode = function () {\n      function LinkedListNode(key, value) {\n        this.key = key;\n        this.value = value;\n      }\n\n      return LinkedListNode;\n    }();\n\n    var LRUCache = function () {\n      function LRUCache(size) {\n        this.nodeMap = {};\n        this.size = 0;\n\n        if (typeof size !== 'number' || size < 1) {\n          throw new Error('Cache size can only be positive number');\n        }\n\n        this.sizeLimit = size;\n      }\n\n      Object.defineProperty(LRUCache.prototype, \"length\", {\n        get: function () {\n          return this.size;\n        },\n        enumerable: true,\n        configurable: true\n      });\n\n      LRUCache.prototype.prependToList = function (node) {\n        if (!this.headerNode) {\n          this.tailNode = node;\n        } else {\n          this.headerNode.prev = node;\n          node.next = this.headerNode;\n        }\n\n        this.headerNode = node;\n        this.size++;\n      };\n\n      LRUCache.prototype.removeFromTail = function () {\n        if (!this.tailNode) {\n          return undefined;\n        }\n\n        var node = this.tailNode;\n        var prevNode = node.prev;\n\n        if (prevNode) {\n          prevNode.next = undefined;\n        }\n\n        node.prev = undefined;\n        this.tailNode = prevNode;\n        this.size--;\n        return node;\n      };\n\n      LRUCache.prototype.detachFromList = function (node) {\n        if (this.headerNode === node) {\n          this.headerNode = node.next;\n        }\n\n        if (this.tailNode === node) {\n          this.tailNode = node.prev;\n        }\n\n        if (node.prev) {\n          node.prev.next = node.next;\n        }\n\n        if (node.next) {\n          node.next.prev = node.prev;\n        }\n\n        node.next = undefined;\n        node.prev = undefined;\n        this.size--;\n      };\n\n      LRUCache.prototype.get = function (key) {\n        if (this.nodeMap[key]) {\n          var node = this.nodeMap[key];\n          this.detachFromList(node);\n          this.prependToList(node);\n          return node.value;\n        }\n      };\n\n      LRUCache.prototype.remove = function (key) {\n        if (this.nodeMap[key]) {\n          var node = this.nodeMap[key];\n          this.detachFromList(node);\n          delete this.nodeMap[key];\n        }\n      };\n\n      LRUCache.prototype.put = function (key, value) {\n        if (this.nodeMap[key]) {\n          this.remove(key);\n        } else if (this.size === this.sizeLimit) {\n          var tailNode = this.removeFromTail();\n          var key_1 = tailNode.key;\n          delete this.nodeMap[key_1];\n        }\n\n        var newNode = new LinkedListNode(key, value);\n        this.nodeMap[key] = newNode;\n        this.prependToList(newNode);\n      };\n\n      LRUCache.prototype.empty = function () {\n        var keys = Object.keys(this.nodeMap);\n\n        for (var i = 0; i < keys.length; i++) {\n          var key = keys[i];\n          var node = this.nodeMap[key];\n          this.detachFromList(node);\n          delete this.nodeMap[key];\n        }\n      };\n\n      return LRUCache;\n    }();\n\n    exports.LRUCache = LRUCache;\n  }, {}],\n  105: [function (require, module, exports) {\n    // AWS SDK for JavaScript v2.553.0\n    // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n    // License at https://sdk.amazonaws.com/js/BUNDLE_LICENSE.txt\n    require('./browser_loader');\n\n    var AWS = require('./core');\n\n    if (typeof window !== 'undefined') window.AWS = AWS;\n\n    if (typeof module !== 'undefined') {\n      /**\n       * @api private\n       */\n      module.exports = AWS;\n    }\n\n    if (typeof self !== 'undefined') self.AWS = AWS;\n    /**\n     * @private\n     * DO NOT REMOVE\n     * browser builder will strip out this line if services are supplied on the command line.\n     */\n\n    if (!Object.prototype.hasOwnProperty.call(AWS, 'Connect')) {\n      AWS.apiLoader.services['connect'] = {};\n      AWS.Connect = AWS.Service.defineService('connect', ['2017-02-15']);\n    }\n\n    AWS.apiLoader.services['connect']['2017-02-15'] = require('../apis/connect-2017-02-15.min');\n\n    if (!Object.prototype.hasOwnProperty.call(AWS, 'STS')) {\n      AWS.apiLoader.services['sts'] = {};\n      AWS.STS = AWS.Service.defineService('sts', ['2011-06-15']);\n\n      require('./services/sts');\n    }\n\n    AWS.apiLoader.services['sts']['2011-06-15'] = require('../apis/sts-2011-06-15.min');\n  }, {\n    \"../apis/connect-2017-02-15.min\": 3,\n    \"../apis/sts-2011-06-15.min\": 5,\n    \"./browser_loader\": 16,\n    \"./core\": 18,\n    \"./services/sts\": 61\n  }]\n}, {}, [105]);\n/*! @license sprintf.js | Copyright (c) 2007-2013 Alexandru Marasteanu <hello at alexei dot ro> | 3 clause BSD license */\n\n(function () {\n  var ctx = this;\n\n  var sprintf = function () {\n    if (!sprintf.cache.hasOwnProperty(arguments[0])) {\n      sprintf.cache[arguments[0]] = sprintf.parse(arguments[0]);\n    }\n\n    return sprintf.format.call(null, sprintf.cache[arguments[0]], arguments);\n  };\n\n  sprintf.format = function (parse_tree, argv) {\n    var cursor = 1,\n        tree_length = parse_tree.length,\n        node_type = '',\n        arg,\n        output = [],\n        i,\n        k,\n        match,\n        pad,\n        pad_character,\n        pad_length;\n\n    for (i = 0; i < tree_length; i++) {\n      node_type = get_type(parse_tree[i]);\n\n      if (node_type === 'string') {\n        output.push(parse_tree[i]);\n      } else if (node_type === 'array') {\n        match = parse_tree[i]; // convenience purposes only\n\n        if (match[2]) {\n          // keyword argument\n          arg = argv[cursor];\n\n          for (k = 0; k < match[2].length; k++) {\n            if (!arg.hasOwnProperty(match[2][k])) {\n              throw sprintf('[sprintf] property \"%s\" does not exist', match[2][k]);\n            }\n\n            arg = arg[match[2][k]];\n          }\n        } else if (match[1]) {\n          // positional argument (explicit)\n          arg = argv[match[1]];\n        } else {\n          // positional argument (implicit)\n          arg = argv[cursor++];\n        }\n\n        if (/[^s]/.test(match[8]) && get_type(arg) != 'number') {\n          throw sprintf('[sprintf] expecting number but found %s', get_type(arg));\n        }\n\n        switch (match[8]) {\n          case 'b':\n            arg = arg.toString(2);\n            break;\n\n          case 'c':\n            arg = String.fromCharCode(arg);\n            break;\n\n          case 'd':\n            arg = parseInt(arg, 10);\n            break;\n\n          case 'e':\n            arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential();\n            break;\n\n          case 'f':\n            arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);\n            break;\n\n          case 'o':\n            arg = arg.toString(8);\n            break;\n\n          case 's':\n            arg = (arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg;\n            break;\n\n          case 'u':\n            arg = arg >>> 0;\n            break;\n\n          case 'x':\n            arg = arg.toString(16);\n            break;\n\n          case 'X':\n            arg = arg.toString(16).toUpperCase();\n            break;\n        }\n\n        arg = /[def]/.test(match[8]) && match[3] && arg >= 0 ? '+' + arg : arg;\n        pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';\n        pad_length = match[6] - String(arg).length;\n        pad = match[6] ? str_repeat(pad_character, pad_length) : '';\n        output.push(match[5] ? arg + pad : pad + arg);\n      }\n    }\n\n    return output.join('');\n  };\n\n  sprintf.cache = {};\n\n  sprintf.parse = function (fmt) {\n    var _fmt = fmt,\n        match = [],\n        parse_tree = [],\n        arg_names = 0;\n\n    while (_fmt) {\n      if ((match = /^[^\\x25]+/.exec(_fmt)) !== null) {\n        parse_tree.push(match[0]);\n      } else if ((match = /^\\x25{2}/.exec(_fmt)) !== null) {\n        parse_tree.push('%');\n      } else if ((match = /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {\n        if (match[2]) {\n          arg_names |= 1;\n          var field_list = [],\n              replacement_field = match[2],\n              field_match = [];\n\n          if ((field_match = /^([a-z_][a-z_\\d]*)/i.exec(replacement_field)) !== null) {\n            field_list.push(field_match[1]);\n\n            while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\n              if ((field_match = /^\\.([a-z_][a-z_\\d]*)/i.exec(replacement_field)) !== null) {\n                field_list.push(field_match[1]);\n              } else if ((field_match = /^\\[(\\d+)\\]/.exec(replacement_field)) !== null) {\n                field_list.push(field_match[1]);\n              } else {\n                throw '[sprintf] huh?';\n              }\n            }\n          } else {\n            throw '[sprintf] huh?';\n          }\n\n          match[2] = field_list;\n        } else {\n          arg_names |= 2;\n        }\n\n        if (arg_names === 3) {\n          throw '[sprintf] mixing positional and named placeholders is not (yet) supported';\n        }\n\n        parse_tree.push(match);\n      } else {\n        throw '[sprintf] huh?';\n      }\n\n      _fmt = _fmt.substring(match[0].length);\n    }\n\n    return parse_tree;\n  };\n\n  var vsprintf = function (fmt, argv, _argv) {\n    _argv = argv.slice(0);\n\n    _argv.splice(0, 0, fmt);\n\n    return sprintf.apply(null, _argv);\n  };\n  /**\n   * helpers\n   */\n\n\n  function get_type(variable) {\n    return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();\n  }\n\n  function str_repeat(input, multiplier) {\n    for (var output = []; multiplier > 0; output[--multiplier] = input) {\n      /* do nothing */\n    }\n\n    return output.join('');\n  }\n  /**\n   * export to either browser or node.js\n   */\n\n\n  ctx.sprintf = sprintf;\n  ctx.vsprintf = vsprintf;\n})();\n/*\n * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\n(function () {\n  var global = this;\n  connect = global.connect || {};\n  global.connect = connect;\n  global.lily = connect; // How frequently softphone logs should be collected and reported to shared worker.\n\n  var SOFTPHONE_LOG_REPORT_INTERVAL_MILLIS = 5000; // How frequently logs should be collected and sent downstream\n\n  var LOGS_REPORT_INTERVAL_MILLIS = 5000; // The default log roll interval (30min)\n\n  var DEFAULT_LOG_ROLL_INTERVAL = 1800000;\n  /**\n   * An enumeration of common logging levels.\n   */\n\n  var LogLevel = {\n    TEST: \"TEST\",\n    TRACE: \"TRACE\",\n    DEBUG: \"DEBUG\",\n    INFO: \"INFO\",\n    LOG: \"LOG\",\n    WARN: \"WARN\",\n    ERROR: \"ERROR\",\n    CRITICAL: \"CRITICAL\"\n  };\n  /**\n   * An enumeration of common logging components.\n   */\n\n  var LogComponent = {\n    CCP: \"ccp\",\n    SOFTPHONE: \"softphone\",\n    CHAT: \"chat\",\n    TASK: \"task\"\n  };\n  /**\n   * The numeric order of the logging levels above.\n   * They are spaced to allow the addition of other log\n   * levels at a later time.\n   */\n\n  var LogLevelOrder = {\n    TEST: 0,\n    TRACE: 10,\n    DEBUG: 20,\n    INFO: 30,\n    LOG: 40,\n    WARN: 50,\n    ERROR: 100,\n    CRITICAL: 200\n  };\n  /**\n   * A map from log level to console logger function.\n   */\n\n  var CONSOLE_LOGGER_MAP = {\n    TRACE: function (text) {\n      console.info(text);\n    },\n    DEBUG: function (text) {\n      console.info(text);\n    },\n    INFO: function (text) {\n      console.info(text);\n    },\n    LOG: function (text) {\n      console.log(text);\n    },\n    TEST: function (text) {\n      console.log(text);\n    },\n    WARN: function (text) {\n      console.warn(text);\n    },\n    ERROR: function (text) {\n      console.error(text);\n    },\n    CRITICAL: function (text) {\n      console.error(text);\n    }\n  };\n  /**\n  * Checks if it is a valid log component enum\n  */\n\n  var isValidLogComponent = function (component) {\n    return Object.values(LogComponent).indexOf(component) !== -1;\n  };\n  /**\n  * Extract the custom arguments as required by the logger\n  */\n\n\n  var extractLoggerArgs = function (loggerArgs) {\n    var args = Array.prototype.slice.call(loggerArgs, 0);\n    var firstArg = args.shift();\n    var format;\n    var component;\n\n    if (isValidLogComponent(firstArg)) {\n      component = firstArg;\n      format = args.shift();\n    } else {\n      //default to CCP component\n      format = firstArg;\n      component = LogComponent.CCP;\n    }\n\n    return {\n      format: format,\n      component: component,\n      args: args\n    };\n  };\n  /**\n   * A log entry.\n   *\n   * @param component The logging component.\n   * @param level The log level of this log entry.\n   * @param text The text contained in the log entry.\n   * @param loggerId The root logger id.\n   *\n   * Log entries are aware of their timestamp, order,\n   * and can contain objects and exception stack traces.\n   */\n\n\n  var LogEntry = function (component, level, text, loggerId) {\n    this.component = component;\n    this.level = level;\n    this.text = text;\n    this.time = new Date();\n    this.exception = null;\n    this.objects = [];\n    this.line = 0;\n    this.agentResourceId = null;\n\n    try {\n      if (connect.agent.initialized) {\n        this.agentResourceId = new connect.Agent()._getResourceId();\n      }\n    } catch (e) {\n      console.log(\"Issue finding agentResourceId: \", e); //can't use our logger here as we might infinitely attempt to log this error.\n    }\n\n    this.loggerId = loggerId;\n  };\n\n  LogEntry.fromObject = function (obj) {\n    var entry = new LogEntry(LogComponent.CCP, obj.level, obj.text, obj.loggerId); // Required to check for Date objects sent across frame boundaries\n\n    if (Object.prototype.toString.call(obj.time) === '[object Date]') {\n      entry.time = new Date(obj.time.getTime());\n    } else if (typeof obj.time === 'number') {\n      entry.time = new Date(obj.time);\n    } else if (typeof obj.time === 'string') {\n      entry.time = Date.parse(obj.time);\n    } else {\n      entry.time = new Date();\n    }\n\n    entry.exception = obj.exception;\n    entry.objects = obj.objects;\n    return entry;\n  };\n  /**\n   * Private method to remove sensitive info from client log\n   */\n\n\n  var redactSensitiveInfo = function (data) {\n    var regex = /AuthToken.*\\=/g;\n\n    if (data && typeof data === 'object') {\n      Object.keys(data).forEach(function (key) {\n        if (typeof data[key] === 'object') {\n          redactSensitiveInfo(data[key]);\n        }\n\n        if (typeof data[key] === 'string' && (key === \"url\" || key === \"text\")) {\n          data[key] = data[key].replace(regex, \"[redacted]\");\n        }\n      });\n    }\n  };\n  /**\n   * Pulls the type, message, and stack trace\n   * out of the given exception for JSON serialization.\n   */\n\n\n  var LoggedException = function (e) {\n    this.type = e instanceof Error ? e.name : e.code || Object.prototype.toString.call(e);\n    this.message = e.message;\n    this.stack = e.stack ? e.stack.split('\\n') : [];\n  };\n  /**\n   * Minimally stringify this log entry for printing\n   * to the console.\n   */\n\n\n  LogEntry.prototype.toString = function () {\n    return connect.sprintf(\"[%s] [%s] [%s]: %s\", this.getTime() && this.getTime().toISOString ? this.getTime().toISOString() : \"???\", this.getLevel(), this.getAgentResourceId(), this.getText());\n  };\n  /**\n   * Get the log entry timestamp.\n   */\n\n\n  LogEntry.prototype.getTime = function () {\n    return this.time;\n  };\n\n  LogEntry.prototype.getAgentResourceId = function () {\n    return this.agentResourceId;\n  };\n  /**\n   * Get the level of the log entry.\n   */\n\n\n  LogEntry.prototype.getLevel = function () {\n    return this.level;\n  };\n  /**\n   * Get the log entry text.\n   */\n\n\n  LogEntry.prototype.getText = function () {\n    return this.text;\n  };\n  /**\n   * Get the log entry component.\n   */\n\n\n  LogEntry.prototype.getComponent = function () {\n    return this.component;\n  };\n  /**\n   * Add an exception stack trace to this log entry.\n   * A log entry may contain only one exception stack trace.\n   */\n\n\n  LogEntry.prototype.withException = function (e) {\n    this.exception = new LoggedException(e);\n    return this;\n  };\n  /**\n   * Add an arbitrary object to the log entry.  A log entry\n   * may contain any number of objects.\n   */\n\n\n  LogEntry.prototype.withObject = function (obj) {\n    var copiedObj = connect.deepcopy(obj);\n    redactSensitiveInfo(copiedObj);\n    this.objects.push(copiedObj);\n    return this;\n  };\n  /**\n   * Add a cross origin event object to the log entry.  A log entry\n   * may contain any number of objects.\n   */\n\n\n  LogEntry.prototype.withCrossOriginEventObject = function (obj) {\n    var copiedObj = connect.deepcopyCrossOriginEvent(obj);\n    redactSensitiveInfo(copiedObj);\n    this.objects.push(copiedObj);\n    return this;\n  };\n  /**\n   * Indicate that this log entry should be sent to the server\n   * NOTE: This should be used for internal logs only\n   */\n\n\n  LogEntry.prototype.sendInternalLogToServer = function () {\n    connect.getLog()._serverBoundInternalLogs.push(this);\n\n    return this;\n  };\n  /**\n   * The logger instance.\n   */\n\n\n  var Logger = function () {\n    this._logs = [];\n    this._rolledLogs = [];\n    this._logsToPush = [];\n    this._serverBoundInternalLogs = [];\n    this._echoLevel = LogLevelOrder.INFO;\n    this._logLevel = LogLevelOrder.INFO;\n    this._lineCount = 0;\n    this._logRollInterval = 0;\n    this._logRollTimer = null;\n    this._loggerId = new Date().getTime() + \"-\" + Math.random().toString(36).slice(2);\n    this.setLogRollInterval(DEFAULT_LOG_ROLL_INTERVAL);\n    this._startLogIndexToPush = 0;\n  };\n  /**\n   * Sets the interval in milliseconds that the logs will be rotated.\n   * Logs are rotated out completely at the end of the second roll\n   * and will eventually be garbage collected.\n   */\n\n\n  Logger.prototype.setLogRollInterval = function (interval) {\n    var self = this;\n\n    if (!this._logRollTimer || interval !== this._logRollInterval) {\n      if (this._logRollTimer) {\n        global.clearInterval(this._logRollTimer);\n      }\n\n      this._logRollInterval = interval;\n      this._logRollTimer = global.setInterval(function () {\n        this._rolledLogs = this._logs;\n        this._logs = [];\n        this._startLogIndexToPush = 0;\n        self.info(\"Log roll interval occurred.\");\n      }, this._logRollInterval);\n    } else {\n      this.warn(\"Logger is already set to the given interval: %d\", this._logRollInterval);\n    }\n  };\n  /**\n   * Set the log level.  This is the minimum level at which logs will\n   * be kept for later archiving.\n   */\n\n\n  Logger.prototype.setLogLevel = function (level) {\n    if (level in LogLevelOrder) {\n      this._logLevel = LogLevelOrder[level];\n    } else {\n      throw new Error(\"Unknown logging level: \" + level);\n    }\n  };\n  /**\n   * Set the echo level.  This is the minimum level at which logs will\n   * be printed to the javascript console.\n   */\n\n\n  Logger.prototype.setEchoLevel = function (level) {\n    if (level in LogLevelOrder) {\n      this._echoLevel = LogLevelOrder[level];\n    } else {\n      throw new Error(\"Unknown logging level: \" + level);\n    }\n  };\n  /**\n   * Write a particular log entry.\n   *\n   * @param level The logging level of the entry.\n   * @param text The text contents of the entry.\n   *\n   * @returns The new log entry.\n   */\n\n\n  Logger.prototype.write = function (component, level, text) {\n    var logEntry = new LogEntry(component, level, text, this.getLoggerId());\n    redactSensitiveInfo(logEntry);\n    this.addLogEntry(logEntry);\n    return logEntry;\n  };\n\n  Logger.prototype.addLogEntry = function (logEntry) {\n    // Call this second time as in some places this function is called directly\n    redactSensitiveInfo(logEntry);\n\n    this._logs.push(logEntry); //For now only send softphone logs only.\n    //TODO add CCP logs once we are sure that no sensitive data is being logged.\n\n\n    if (LogComponent.SOFTPHONE === logEntry.component) {\n      this._logsToPush.push(logEntry);\n    }\n\n    if (logEntry.level in LogLevelOrder && LogLevelOrder[logEntry.level] >= this._logLevel) {\n      if (LogLevelOrder[logEntry.level] >= this._echoLevel) {\n        CONSOLE_LOGGER_MAP[logEntry.getLevel()](logEntry.toString());\n      }\n\n      logEntry.line = this._lineCount++;\n    }\n  };\n\n  Logger.prototype.sendInternalLogEntryToServer = function (logEntry) {\n    this._serverBoundInternalLogs.push(logEntry);\n\n    if (logEntry.level in LogLevelOrder && LogLevelOrder[logEntry.level] >= this._logLevel) {\n      if (LogLevelOrder[logEntry.level] >= this._echoLevel) {\n        CONSOLE_LOGGER_MAP[logEntry.getLevel()](logEntry.toString());\n      }\n\n      logEntry.line = this._lineCount++;\n    }\n  };\n  /**\n   * Remove all objects from all log entries.\n   */\n\n\n  Logger.prototype.clearObjects = function () {\n    for (var x = 0; x < this._logs.length; x++) {\n      if (this._logs[x].objects) {\n        delete this._logs[x].objects;\n      }\n    }\n  };\n  /**\n   * Remove all exception stack traces from the log entries.\n   */\n\n\n  Logger.prototype.clearExceptions = function () {\n    for (var x = 0; x < this._logs.length; x++) {\n      if (this._logs[x].exception) {\n        delete this._logs[x].exception;\n      }\n    }\n  };\n\n  Logger.prototype.trace = function () {\n    var logArgs = extractLoggerArgs(arguments);\n    return this.write(logArgs.component, LogLevel.TRACE, connect.vsprintf(logArgs.format, logArgs.args));\n  };\n\n  Logger.prototype.debug = function () {\n    var logArgs = extractLoggerArgs(arguments);\n    return this.write(logArgs.component, LogLevel.DEBUG, connect.vsprintf(logArgs.format, logArgs.args));\n  };\n\n  Logger.prototype.info = function () {\n    var logArgs = extractLoggerArgs(arguments);\n    return this.write(logArgs.component, LogLevel.INFO, connect.vsprintf(logArgs.format, logArgs.args));\n  };\n\n  Logger.prototype.log = function () {\n    var logArgs = extractLoggerArgs(arguments);\n    return this.write(logArgs.component, LogLevel.LOG, connect.vsprintf(logArgs.format, logArgs.args));\n  };\n\n  Logger.prototype.test = function () {\n    var logArgs = extractLoggerArgs(arguments);\n    return this.write(logArgs.component, LogLevel.TEST, connect.vsprintf(logArgs.format, logArgs.args));\n  };\n\n  Logger.prototype.warn = function () {\n    var logArgs = extractLoggerArgs(arguments);\n    return this.write(logArgs.component, LogLevel.WARN, connect.vsprintf(logArgs.format, logArgs.args));\n  };\n\n  Logger.prototype.error = function () {\n    var logArgs = extractLoggerArgs(arguments);\n    return this.write(logArgs.component, LogLevel.ERROR, connect.vsprintf(logArgs.format, logArgs.args));\n  };\n\n  Logger.prototype.critical = function () {\n    var logArgs = extractLoggerArgs(arguments);\n    return this.write(logArgs.component, LogLevel.ERROR, connect.vsprintf(logArgs.format, logArgs.args));\n  };\n  /**\n   * Create a string representation of the logger contents.\n   */\n\n\n  Logger.prototype.toString = function () {\n    var lines = [];\n\n    for (var x = 0; x < this._logs.length; x++) {\n      lines.push(this._logs[x].toString());\n    }\n\n    return lines.join(\"\\n\");\n  };\n  /**\n   * Download/Archive logs to a file, \n   * By default, it returns all logs.\n   * To filter logs by the minimum log level set by setLogLevel or the default set in _logLevel, \n   * pass in filterByLogLevel to true in options\n   * \n   * @param options download options [Object|String]. \n   * - of type Object: \n   *   { logName: 'my-log-name',\n   *     filterByLogLevel: false, //download all logs\n   *   }\n   * - of type String (for backward compatibility), the file's name\n   */\n\n\n  Logger.prototype.download = function (options) {\n    var logName = 'agent-log';\n    var filterByLogLevel = false;\n\n    if (typeof options === 'object') {\n      logName = options.logName || logName;\n      filterByLogLevel = options.filterByLogLevel || filterByLogLevel;\n    } else if (typeof options === 'string') {\n      logName = options || logName;\n    }\n\n    var self = this;\n\n    var logs = this._rolledLogs.concat(this._logs);\n\n    if (filterByLogLevel) {\n      logs = logs.filter(function (entry) {\n        return LogLevelOrder[entry.level] >= self._logLevel;\n      });\n    }\n\n    var logBlob = new global.Blob([JSON.stringify(logs, undefined, 4)], ['text/plain']);\n    var downloadLink = document.createElement('a');\n    var logName = logName || 'agent-log';\n    downloadLink.href = global.URL.createObjectURL(logBlob);\n    downloadLink.download = logName + '.txt';\n    document.body.appendChild(downloadLink);\n    downloadLink.click();\n    document.body.removeChild(downloadLink);\n  };\n\n  Logger.prototype.scheduleUpstreamLogPush = function (conduit) {\n    if (!connect.upstreamLogPushScheduled) {\n      connect.upstreamLogPushScheduled = true;\n      /** Schedule pushing logs frequently to sharedworker upstream, sharedworker will report to LARS*/\n\n      global.setInterval(connect.hitch(this, this.reportMasterLogsUpStream, conduit), SOFTPHONE_LOG_REPORT_INTERVAL_MILLIS);\n    }\n  };\n\n  Logger.prototype.reportMasterLogsUpStream = function (conduit) {\n    var logsToPush = this._logsToPush.slice();\n\n    this._logsToPush = [];\n    connect.ifMaster(connect.MasterTopics.SEND_LOGS, function () {\n      if (logsToPush.length > 0) {\n        conduit.sendUpstream(connect.EventType.SEND_LOGS, logsToPush);\n      }\n    });\n  };\n\n  Logger.prototype.scheduleUpstreamOuterContextCCPserverBoundLogsPush = function (conduit) {\n    global.setInterval(connect.hitch(this, this.pushOuterContextCCPserverBoundLogsUpstream, conduit), 1000);\n  };\n\n  Logger.prototype.scheduleUpstreamOuterContextCCPLogsPush = function (conduit) {\n    global.setInterval(connect.hitch(this, this.pushOuterContextCCPLogsUpstream, conduit), 1000);\n  };\n\n  Logger.prototype.pushOuterContextCCPserverBoundLogsUpstream = function (conduit) {\n    if (this._serverBoundInternalLogs.length > 0) {\n      for (var i = 0; i < this._serverBoundInternalLogs.length; i++) {\n        this._serverBoundInternalLogs[i].text = this._serverBoundInternalLogs[i].text;\n      }\n\n      conduit.sendUpstream(connect.EventType.SERVER_BOUND_INTERNAL_LOG, this._serverBoundInternalLogs);\n      this._serverBoundInternalLogs = [];\n    }\n  };\n\n  Logger.prototype.pushOuterContextCCPLogsUpstream = function (conduit) {\n    for (var i = this._startLogIndexToPush; i < this._logs.length; i++) {\n      if (this._logs[i].loggerId !== this._loggerId) {\n        continue;\n      }\n\n      conduit.sendUpstream(connect.EventType.LOG, this._logs[i]);\n    }\n\n    this._startLogIndexToPush = this._logs.length;\n  };\n\n  Logger.prototype.getLoggerId = function () {\n    return this._loggerId;\n  };\n\n  Logger.prototype.scheduleDownstreamClientSideLogsPush = function () {\n    global.setInterval(connect.hitch(this, this.pushClientSideLogsDownstream), LOGS_REPORT_INTERVAL_MILLIS);\n  };\n\n  Logger.prototype.pushClientSideLogsDownstream = function () {\n    var logs = []; // We do not send a request if we have less than 50 records so that we minimize the number of\n    // requests per second. \n    // 500 is the max we accept on the server. \n    // We chose 500 because this is the limit imposed by Firehose for a put batch request\n\n    if (this._serverBoundInternalLogs.length < 50) {\n      return;\n    } else if (this._serverBoundInternalLogs.length > 500) {\n      logs = this._serverBoundInternalLogs.splice(0, 500);\n    } else {\n      logs = this._serverBoundInternalLogs;\n      this._serverBoundInternalLogs = [];\n    }\n\n    connect.publishClientSideLogs(logs);\n  };\n\n  var DownstreamConduitLogger = function (conduit) {\n    Logger.call(this);\n    this.conduit = conduit;\n    global.setInterval(connect.hitch(this, this._pushLogsDownstream), DownstreamConduitLogger.LOG_PUSH_INTERVAL); // Disable log rolling, we will purge our own logs once they have\n    // been pushed downstream.\n\n    global.clearInterval(this._logRollTimer);\n    this._logRollTimer = null;\n  }; // How frequently logs should be collected and delivered downstream.\n\n\n  DownstreamConduitLogger.LOG_PUSH_INTERVAL = 1000;\n  DownstreamConduitLogger.prototype = Object.create(Logger.prototype);\n  DownstreamConduitLogger.prototype.constructor = DownstreamConduitLogger;\n\n  DownstreamConduitLogger.prototype.pushLogsDownstream = function (logs) {\n    var self = this;\n    logs.forEach(function (log) {\n      self.conduit.sendDownstream(connect.EventType.LOG, log);\n    });\n  };\n\n  DownstreamConduitLogger.prototype._pushLogsDownstream = function () {\n    var self = this;\n\n    this._logs.forEach(function (log) {\n      self.conduit.sendDownstream(connect.EventType.LOG, log);\n    });\n\n    this._logs = [];\n\n    for (var i = 0; i < this._serverBoundInternalLogs.length; i++) {\n      this.conduit.sendDownstream(connect.EventType.SERVER_BOUND_INTERNAL_LOG, this._serverBoundInternalLogs[i]);\n    }\n\n    this._serverBoundInternalLogs = [];\n  };\n  /**\n   * Wrap a function with try catch block\n   */\n\n\n  var tryCatchWrapperMethod = function (fn) {\n    var wrappedfunction = function () {\n      try {\n        return fn.apply(this, arguments);\n      } catch (e) {\n        // Since this wraps Logger class, we can only print it in the console and eat it.\n        CONSOLE_LOGGER_MAP.ERROR(e);\n      }\n    };\n\n    return wrappedfunction;\n  };\n  /**\n   * This is a wrapper method to wrap each function\n   * in an object with try catch block.\n   */\n\n\n  var tryCatchWrapperObject = function (obj) {\n    for (var method in obj) {\n      if (typeof obj[method] === 'function') {\n        obj[method] = tryCatchWrapperMethod(obj[method]);\n      }\n    }\n  };\n  /** Create the singleton logger instance. */\n\n\n  connect.rootLogger = new Logger();\n  tryCatchWrapperObject(connect.rootLogger);\n  /** Fetch the singleton logger instance. */\n\n  var getLog = function () {\n    return connect.rootLogger;\n  };\n\n  connect = connect || {};\n  connect.getLog = getLog;\n  connect.LogEntry = LogEntry;\n  connect.Logger = Logger;\n  connect.LogLevel = LogLevel;\n  connect.LogComponent = LogComponent;\n  connect.DownstreamConduitLogger = DownstreamConduitLogger;\n})();\n/*\n * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\n(function () {\n  var global = this;\n  connect = global.connect || {};\n  global.connect = connect;\n  global.lily = connect;\n  var userAgent = navigator.userAgent;\n  var ONE_DAY_MILLIS = 24 * 60 * 60 * 1000;\n  var DEFAULT_POPUP_HEIGHT = 578;\n  var DEFAULT_POPUP_WIDTH = 433;\n  var COPYABLE_EVENT_FIELDS = [\"bubbles\", \"cancelBubble\", \"cancelable\", \"composed\", \"data\", \"defaultPrevented\", \"eventPhase\", \"isTrusted\", \"lastEventId\", \"origin\", \"returnValue\", \"timeStamp\", \"type\"];\n  /**\n   * Unpollute sprintf functions from the global namespace.\n   */\n\n  connect.sprintf = global.sprintf;\n  connect.vsprintf = global.vsprintf;\n  delete global.sprintf;\n  delete global.vsprintf;\n  connect.HTTP_STATUS_CODES = {\n    SUCCESS: 200,\n    TOO_MANY_REQUESTS: 429,\n    INTERNAL_SERVER_ERROR: 500\n  };\n  connect.TRANSPORT_TYPES = {\n    CHAT_TOKEN: \"chat_token\",\n    WEB_SOCKET: \"web_socket\"\n  };\n  /**\n   * Binds the given instance object as the context for\n   * the method provided.\n   *\n   * @param scope The instance object to be set as the scope\n   *    of the function.\n   * @param method The method to be encapsulated.\n   *\n   * All other arguments, if any, are bound to the method\n   * invocation inside the closure.\n   *\n   * @return A closure encapsulating the invocation of the\n   *    method provided in context of the given instance.\n   */\n\n  connect.hitch = function () {\n    var args = Array.prototype.slice.call(arguments);\n    var scope = args.shift();\n    var method = args.shift();\n    connect.assertNotNull(scope, 'scope');\n    connect.assertNotNull(method, 'method');\n    connect.assertTrue(connect.isFunction(method), 'method must be a function');\n    return function () {\n      var closureArgs = Array.prototype.slice.call(arguments);\n      return method.apply(scope, args.concat(closureArgs));\n    };\n  };\n  /**\n   * Determine if the given value is a callable function type.\n   * Borrowed from Underscore.js.\n   */\n\n\n  connect.isFunction = function (obj) {\n    return !!(obj && obj.constructor && obj.call && obj.apply);\n  };\n  /**\n   * Determine if the given value is an array.\n   */\n\n\n  connect.isArray = function (obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  };\n  /**\n   * Get a list of keys from a Javascript object used\n   * as a hash map.\n   */\n\n\n  connect.keys = function (map) {\n    var keys = [];\n    connect.assertNotNull(map, 'map');\n\n    for (var k in map) {\n      keys.push(k);\n    }\n\n    return keys;\n  };\n  /**\n   * Get a list of values from a Javascript object used\n   * as a hash map.\n   */\n\n\n  connect.values = function (map) {\n    var values = [];\n    connect.assertNotNull(map, 'map');\n\n    for (var k in map) {\n      values.push(map[k]);\n    }\n\n    return values;\n  };\n  /**\n   * Get a list of key/value pairs from the given map.\n   */\n\n\n  connect.entries = function (map) {\n    var entries = [];\n\n    for (var k in map) {\n      entries.push({\n        key: k,\n        value: map[k]\n      });\n    }\n\n    return entries;\n  };\n  /**\n   * Merge two or more maps together into a new map,\n   * or simply copy a single map.\n   */\n\n\n  connect.merge = function () {\n    var argMaps = Array.prototype.slice.call(arguments, 0);\n    var resultMap = {};\n    argMaps.forEach(function (map) {\n      connect.entries(map).forEach(function (kv) {\n        resultMap[kv.key] = kv.value;\n      });\n    });\n    return resultMap;\n  };\n\n  connect.now = function () {\n    return new Date().getTime();\n  };\n\n  connect.find = function (array, predicate) {\n    for (var x = 0; x < array.length; x++) {\n      if (predicate(array[x])) {\n        return array[x];\n      }\n    }\n\n    return null;\n  };\n\n  connect.contains = function (obj, value) {\n    if (obj instanceof Array) {\n      return connect.find(obj, function (v) {\n        return v === value;\n      }) != null;\n    } else {\n      return value in obj;\n    }\n  };\n\n  connect.containsValue = function (obj, value) {\n    if (obj instanceof Array) {\n      return connect.find(obj, function (v) {\n        return v === value;\n      }) != null;\n    } else {\n      return connect.find(connect.values(obj), function (v) {\n        return v === value;\n      }) != null;\n    }\n  };\n  /**\n   * Generate a random ID consisting of the current timestamp\n   * and a random base-36 number based on Math.random().\n   */\n\n\n  connect.randomId = function () {\n    return connect.sprintf(\"%s-%s\", connect.now(), Math.random().toString(36).slice(2));\n  };\n  /**\n   * Generate an enum from the given list of lower-case enum values,\n   * where the enum keys will be upper case.\n   *\n   * Conversion from pascal case based on code from here:\n   * http://stackoverflow.com/questions/30521224\n   */\n\n\n  connect.makeEnum = function (values) {\n    var enumObj = {};\n    values.forEach(function (value) {\n      var key = value.replace(/\\.?([a-z]+)_?/g, function (x, y) {\n        return y.toUpperCase() + \"_\";\n      }).replace(/_$/, \"\");\n      enumObj[key] = value;\n    });\n    return enumObj;\n  };\n\n  connect.makeNamespacedEnum = function (prefix, values) {\n    var enumObj = connect.makeEnum(values);\n    connect.keys(enumObj).forEach(function (key) {\n      enumObj[key] = connect.sprintf(\"%s::%s\", prefix, enumObj[key]);\n    });\n    return enumObj;\n  };\n\n  connect.makeGenericNamespacedEnum = function (prefix, values, delimiter) {\n    var enumObj = connect.makeEnum(values);\n    connect.keys(enumObj).forEach(function (key) {\n      enumObj[key] = connect.sprintf(\"%s\" + delimiter + \"%s\", prefix, enumObj[key]);\n    });\n    return enumObj;\n  };\n  /**\n  * Methods to determine browser type and versions, used for softphone initialization.\n  */\n\n\n  connect.isChromeBrowser = function () {\n    return userAgent.indexOf(\"Chrome\") !== -1;\n  };\n\n  connect.isFirefoxBrowser = function () {\n    return userAgent.indexOf(\"Firefox\") !== -1;\n  };\n\n  connect.isOperaBrowser = function () {\n    return userAgent.indexOf(\"Opera\") !== -1;\n  };\n\n  connect.getChromeBrowserVersion = function () {\n    var chromeVersion = userAgent.substring(userAgent.indexOf(\"Chrome\") + 7);\n\n    if (chromeVersion) {\n      return parseFloat(chromeVersion);\n    } else {\n      return -1;\n    }\n  };\n\n  connect.getFirefoxBrowserVersion = function () {\n    var firefoxVersion = userAgent.substring(userAgent.indexOf(\"Firefox\") + 8);\n\n    if (firefoxVersion) {\n      return parseFloat(firefoxVersion);\n    } else {\n      return -1;\n    }\n  };\n\n  connect.isValidLocale = function (locale) {\n    var languages = [{\n      id: 'en_US',\n      label: 'English'\n    }, {\n      id: 'de_DE',\n      label: 'Deutsch'\n    }, {\n      id: 'es_ES',\n      label: 'Espaol'\n    }, {\n      id: 'fr_FR',\n      label: 'Franais'\n    }, {\n      id: 'ja_JP',\n      label: ''\n    }, {\n      id: 'it_IT',\n      label: 'Italiano'\n    }, {\n      id: 'ko_KR',\n      label: ''\n    }, {\n      id: 'pt_BR',\n      label: 'Portugus'\n    }, {\n      id: 'zh_CN',\n      label: '()'\n    }, {\n      id: 'zh_TW',\n      label: '()'\n    }];\n    return languages.map(function (language) {\n      return language.id;\n    }).includes(locale);\n  };\n\n  connect.getOperaBrowserVersion = function () {\n    var versionOffset = userAgent.indexOf(\"Opera\");\n    var operaVersion = userAgent.indexOf(\"Version\") !== -1 ? userAgent.substring(versionOffset + 8) : userAgent.substring(versionOffset + 6);\n\n    if (operaVersion) {\n      return parseFloat(operaVersion);\n    } else {\n      return -1;\n    }\n  };\n  /**\n   * Return a map of items in the given list indexed by\n   * keys determined by the closure provided.\n   *\n   * @param iterable A list-like object.\n   * @param closure A closure to determine the index for the\n   *    items in the iterable.\n   * @return A map from index to item for each item in the iterable.\n   */\n\n\n  connect.index = function (iterable, closure) {\n    var map = {};\n    iterable.forEach(function (item) {\n      map[closure(item)] = item;\n    });\n    return map;\n  };\n  /**\n   * Converts the given array into a map as a set,\n   * where elements in the array are mapped to 1.\n   */\n\n\n  connect.set = function (arrayIn) {\n    var setMap = {};\n    arrayIn.forEach(function (key) {\n      setMap[key] = 1;\n    });\n    return setMap;\n  };\n  /**\n   * Returns a map for each key in mapB which\n   * is NOT in mapA.\n   */\n\n\n  connect.relativeComplement = function (mapA, mapB) {\n    var compMap = {};\n    connect.keys(mapB).forEach(function (key) {\n      if (!(key in mapA)) {\n        compMap[key] = mapB[key];\n      }\n    });\n    return compMap;\n  };\n  /**\n   * Asserts that a premise is true.\n   */\n\n\n  connect.assertTrue = function (premise, message) {\n    if (!premise) {\n      throw new connect.ValueError(message);\n    }\n  };\n  /**\n   * Asserts that a value is not null or undefined.\n   */\n\n\n  connect.assertNotNull = function (value, name) {\n    connect.assertTrue(value != null && typeof value !== undefined, connect.sprintf(\"%s must be provided\", name || 'A value'));\n    return value;\n  };\n\n  connect.deepcopy = function (src) {\n    return JSON.parse(JSON.stringify(src));\n  };\n\n  connect.deepcopyCrossOriginEvent = function (event) {\n    const obj = {};\n    const listOfAcceptableKeys = COPYABLE_EVENT_FIELDS;\n    listOfAcceptableKeys.forEach(key => {\n      try {\n        obj[key] = event[key];\n      } catch (e) {\n        connect.getLog().info(\"deepcopyCrossOriginEvent failed on key: \", key).sendInternalLogToServer();\n      }\n    });\n    return connect.deepcopy(obj);\n  };\n  /**\n   * Get the current base url of the open page, e.g. if the page is\n   * https://example.com:9494/oranges, this will be \"https://example.com:9494\".\n   */\n\n\n  connect.getBaseUrl = function () {\n    var location = global.location;\n    return connect.sprintf(\"%s//%s:%s\", location.protocol, location.hostname, location.port);\n  };\n\n  connect.getUrlWithProtocol = function (url) {\n    var protocol = global.location.protocol;\n\n    if (url.substr(0, protocol.length) !== protocol) {\n      return connect.sprintf(\"%s//%s\", protocol, url);\n    }\n\n    return url;\n  };\n  /**\n   * Determine if the current window is in an iframe.\n   * Courtesy: http://stackoverflow.com/questions/326069/\n   */\n\n\n  connect.isFramed = function () {\n    try {\n      return window.self !== window.top;\n    } catch (e) {\n      return true;\n    }\n  };\n\n  connect.hasOtherConnectedCCPs = function () {\n    return connect.numberOfConnectedCCPs > 1;\n  };\n\n  connect.fetch = function (endpoint, options, milliInterval, maxRetry) {\n    maxRetry = maxRetry || 5;\n    milliInterval = milliInterval || 1000;\n    options = options || {};\n    return new Promise(function (resolve, reject) {\n      function fetchData(maxRetry) {\n        fetch(endpoint, options).then(function (res) {\n          if (res.status === connect.HTTP_STATUS_CODES.SUCCESS) {\n            res.json().then(json => resolve(json)).catch(() => resolve({}));\n          } else if (maxRetry !== 1 && (res.status >= connect.HTTP_STATUS_CODES.INTERNAL_SERVER_ERROR || res.status === connect.HTTP_STATUS_CODES.TOO_MANY_REQUESTS)) {\n            setTimeout(function () {\n              fetchData(--maxRetry);\n            }, milliInterval);\n          } else {\n            reject(res);\n          }\n        }).catch(function (e) {\n          reject(e);\n        });\n      }\n\n      fetchData(maxRetry);\n    });\n  };\n  /**\n   * Calling a function with exponential backoff with full jitter retry strategy\n   * It will retry calling the function for maximum maxRetry times if it fails.\n   * Success callback will be called if the function succeeded.\n   * Failure callback will be called only if the last try failed.\n   */\n\n\n  connect.backoff = function (func, milliInterval, maxRetry, callbacks) {\n    connect.assertTrue(connect.isFunction(func), \"func must be a Function\");\n    var self = this;\n    var ratio = 2;\n    func({\n      success: function (data) {\n        if (callbacks && callbacks.success) {\n          callbacks.success(data);\n        }\n      },\n      failure: function (err, data) {\n        if (maxRetry > 0) {\n          var interval = milliInterval * 2 * Math.random();\n          global.setTimeout(function () {\n            self.backoff(func, interval * ratio, --maxRetry, callbacks);\n          }, interval);\n        } else {\n          if (callbacks && callbacks.failure) {\n            callbacks.failure(err, data);\n          }\n        }\n      }\n    });\n  };\n\n  connect.publishMetric = function (metricData) {\n    connect.core.getUpstream().sendUpstream(connect.EventType.BROADCAST, {\n      event: connect.EventType.CLIENT_METRIC,\n      data: metricData\n    });\n  };\n\n  connect.publishSoftphoneStats = function (stats) {\n    connect.core.getUpstream().sendUpstream(connect.EventType.BROADCAST, {\n      event: connect.EventType.SOFTPHONE_STATS,\n      data: stats\n    });\n  };\n\n  connect.publishSoftphoneReport = function (report) {\n    connect.core.getUpstream().sendUpstream(connect.EventType.BROADCAST, {\n      event: connect.EventType.SOFTPHONE_REPORT,\n      data: report\n    });\n  };\n\n  connect.publishClientSideLogs = function (logs) {\n    var bus = connect.core.getEventBus();\n    bus.trigger(connect.EventType.CLIENT_SIDE_LOGS, logs);\n  };\n  /**\n   * A wrapper around Window.open() for managing single instance popups.\n   */\n\n\n  connect.PopupManager = function () {};\n\n  connect.PopupManager.prototype.open = function (url, name, options) {\n    var then = this._getLastOpenedTimestamp(name);\n\n    var now = new Date().getTime();\n    var win = null;\n\n    if (now - then > ONE_DAY_MILLIS) {\n      if (options) {\n        // default values are chosen to provide a minimum height without scrolling\n        // and a uniform margin based on the css of the ccp login page\n        var height = options.height || DEFAULT_POPUP_HEIGHT;\n        var width = options.width || DEFAULT_POPUP_WIDTH;\n        var top = options.top || 0;\n        var left = options.left || 0;\n        win = window.open('', name, \"width=\" + width + \", height=\" + height + \", top=\" + top + \", left=\" + left);\n\n        if (win.location !== url) {\n          win = window.open(url, name, \"width=\" + width + \", height=\" + height + \", top=\" + top + \", left=\" + left);\n        }\n      } else {\n        win = window.open('', name);\n\n        if (win.location !== url) {\n          win = window.open(url, name);\n        }\n      }\n\n      this._setLastOpenedTimestamp(name, now);\n    }\n\n    return win;\n  };\n\n  connect.PopupManager.prototype.clear = function (name) {\n    var key = this._getLocalStorageKey(name);\n\n    global.localStorage.removeItem(key);\n  };\n\n  connect.PopupManager.prototype._getLastOpenedTimestamp = function (name) {\n    var key = this._getLocalStorageKey(name);\n\n    var value = global.localStorage.getItem(key);\n\n    if (value) {\n      return parseInt(value, 10);\n    } else {\n      return 0;\n    }\n  };\n\n  connect.PopupManager.prototype._setLastOpenedTimestamp = function (name, ts) {\n    var key = this._getLocalStorageKey(name);\n\n    global.localStorage.setItem(key, '' + ts);\n  };\n\n  connect.PopupManager.prototype._getLocalStorageKey = function (name) {\n    return \"connectPopupManager::\" + name;\n  };\n  /**\n   * An enumeration of the HTML5 notification permission values.\n   */\n\n\n  var NotificationPermission = connect.makeEnum(['granted', 'denied', 'default']);\n  /**\n   * A simple engine for showing notification popups.\n   */\n\n  connect.NotificationManager = function () {\n    this.queue = [];\n    this.permission = NotificationPermission.DEFAULT;\n  };\n\n  connect.NotificationManager.prototype.requestPermission = function () {\n    var self = this;\n\n    if (!(\"Notification\" in global)) {\n      connect.getLog().warn(\"This browser doesn't support notifications.\").sendInternalLogToServer();\n      this.permission = NotificationPermission.DENIED;\n    } else if (global.Notification.permission === NotificationPermission.DENIED) {\n      connect.getLog().warn(\"The user has requested to not receive notifications.\").sendInternalLogToServer();\n      this.permission = NotificationPermission.DENIED;\n    } else if (this.permission !== NotificationPermission.GRANTED) {\n      global.Notification.requestPermission().then(function (permission) {\n        self.permission = permission;\n\n        if (permission === NotificationPermission.GRANTED) {\n          self._showQueued();\n        } else {\n          self.queue = [];\n        }\n      });\n    }\n  };\n\n  connect.NotificationManager.prototype.show = function (title, options) {\n    if (this.permission === NotificationPermission.GRANTED) {\n      return this._showImpl({\n        title: title,\n        options: options\n      });\n    } else if (this.permission === NotificationPermission.DENIED) {\n      connect.getLog().warn(\"Unable to show notification.\").sendInternalLogToServer().withObject({\n        title: title,\n        options: options\n      });\n    } else {\n      var params = {\n        title: title,\n        options: options\n      };\n      connect.getLog().warn(\"Deferring notification until user decides to allow or deny.\").withObject(params).sendInternalLogToServer();\n      this.queue.push(params);\n    }\n  };\n\n  connect.NotificationManager.prototype._showQueued = function () {\n    var self = this;\n    var notifications = this.queue.map(function (params) {\n      return self._showImpl(params);\n    });\n    this.queue = [];\n    return notifications;\n  };\n\n  connect.NotificationManager.prototype._showImpl = function (params) {\n    var notification = new global.Notification(params.title, params.options);\n\n    if (params.options.clicked) {\n      notification.onclick = function () {\n        params.options.clicked.call(notification);\n      };\n    }\n\n    return notification;\n  };\n\n  connect.BaseError = function (format, args) {\n    global.Error.call(this, connect.vsprintf(format, args));\n  };\n\n  connect.BaseError.prototype = Object.create(Error.prototype);\n  connect.BaseError.prototype.constructor = connect.BaseError;\n\n  connect.ValueError = function () {\n    var args = Array.prototype.slice.call(arguments, 0);\n    var format = args.shift();\n    connect.BaseError.call(this, format, args);\n  };\n\n  connect.ValueError.prototype = Object.create(connect.BaseError.prototype);\n  connect.ValueError.prototype.constructor = connect.ValueError;\n\n  connect.NotImplementedError = function () {\n    var args = Array.prototype.slice.call(arguments, 0);\n    var format = args.shift();\n    connect.BaseError.call(this, format, args);\n  };\n\n  connect.NotImplementedError.prototype = Object.create(connect.BaseError.prototype);\n  connect.NotImplementedError.prototype.constructor = connect.NotImplementedError;\n\n  connect.StateError = function () {\n    var args = Array.prototype.slice.call(arguments, 0);\n    var format = args.shift();\n    connect.BaseError.call(this, format, args);\n  };\n\n  connect.StateError.prototype = Object.create(connect.BaseError.prototype);\n  connect.StateError.prototype.constructor = connect.StateError;\n\n  connect.VoiceIdError = function (type, message, err) {\n    var error = {};\n    error.type = type;\n    error.message = message;\n    error.stack = Error(message).stack;\n    error.err = err;\n    return error;\n  }; // internal use only\n\n\n  connect.isCCP = function () {\n    var conduit = connect.core.getUpstream();\n    return conduit.name === 'ConnectSharedWorkerConduit';\n  };\n})();\n/*\n * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\n(function () {\n  var global = this;\n  connect = global.connect || {};\n  global.connect = connect;\n  var ALL_EVENTS = '<<all>>';\n  /**---------------------------------------------------------------\n   * enum EventType\n   */\n\n  var EventType = connect.makeEnum(['acknowledge', 'ack_timeout', 'init', 'api_request', 'api_response', 'auth_fail', 'access_denied', 'close', 'configure', 'log', 'master_request', 'master_response', 'synchronize', 'terminate', 'terminated', 'send_logs', 'reload_agent_configuration', 'broadcast', 'api_metric', 'client_metric', 'softphone_stats', 'softphone_report', 'client_side_logs', 'server_bound_internal_log', 'mute', \"iframe_style\", \"update_connected_ccps\", \"outer_context_info\", \"media_device_request\", \"media_device_response\"]);\n  /**---------------------------------------------------------------\n   * enum MasterTopics\n   */\n\n  var MasterTopics = connect.makeNamespacedEnum('connect', ['loginPopup', 'sendLogs', 'softphone', 'ringtone', 'metrics']);\n  /**---------------------------------------------------------------\n   * enum AgentEvents\n   */\n\n  var AgentEvents = connect.makeNamespacedEnum('agent', ['init', 'update', 'refresh', 'routable', 'not_routable', 'pending', 'contact_pending', 'offline', 'error', 'softphone_error', 'websocket_connection_lost', 'websocket_connection_gained', 'state_change', 'acw', 'mute_toggle', 'local_media_stream_created', 'enqueued_next_state']);\n  /**---------------------------------------------------------------\n  * enum WebSocketEvents\n  */\n\n  var WebSocketEvents = connect.makeNamespacedEnum('webSocket', ['init_failure', 'connection_open', 'connection_close', 'connection_error', 'connection_gain', 'connection_lost', 'subscription_update', 'subscription_failure', 'all_message', 'send', 'subscribe']);\n  /**---------------------------------------------------------------\n    * enum ContactEvents\n    */\n\n  var ContactEvents = connect.makeNamespacedEnum('contact', ['init', 'refresh', 'destroyed', 'incoming', 'pending', 'connecting', 'connected', 'missed', 'acw', 'view', 'ended', 'error', 'accepted']);\n  var ChannelViewEvents = connect.makeNamespacedEnum('taskList', ['activate_channel_with_view_type']);\n  var TaskEvents = connect.makeNamespacedEnum('task', ['created']);\n  /**---------------------------------------------------------------\n  * enum ConnectionEvents\n  */\n\n  var ConnectionEvents = connect.makeNamespacedEnum('connection', ['session_init', 'ready_to_start_session']);\n  /**---------------------------------------------------------------\n   * enum Configuration Events\n   */\n\n  var ConfigurationEvents = connect.makeNamespacedEnum('configuration', ['configure', 'set_speaker_device', 'set_microphone_device', 'set_ringer_device', 'speaker_device_changed', 'microphone_device_changed', 'ringer_device_changed']);\n  /**---------------------------------------------------------------\n   * enum VoiceId Events\n   */\n\n  var VoiceIdEvents = connect.makeNamespacedEnum('voiceId', ['update_domain_id']);\n  /**---------------------------------------------------------------\n   * class EventFactory\n   */\n\n  var EventFactory = function () {};\n\n  EventFactory.createRequest = function (type, method, params) {\n    return {\n      event: type,\n      requestId: connect.randomId(),\n      method: method,\n      params: params\n    };\n  };\n\n  EventFactory.createResponse = function (type, request, data, err) {\n    return {\n      event: type,\n      requestId: request.requestId,\n      data: data,\n      err: err || null\n    };\n  };\n  /**\n   * An object representing an event subscription in an EventBus.\n   */\n\n\n  var Subscription = function (subMap, eventName, f) {\n    this.subMap = subMap;\n    this.id = connect.randomId();\n    this.eventName = eventName;\n    this.f = f;\n  };\n  /**\n   * Unsubscribe the handler of this subscription from the EventBus\n   * from which it was created.\n   */\n\n\n  Subscription.prototype.unsubscribe = function () {\n    this.subMap.unsubscribe(this.eventName, this.id);\n  };\n  /**\n   * A map of event subscriptions, used by the EventBus.\n   */\n\n\n  var SubscriptionMap = function () {\n    this.subIdMap = {};\n    this.subEventNameMap = {};\n  };\n  /**\n   * Add a subscription for the named event.  Creates a new Subscription\n   * object and returns it.  This object can be used to unsubscribe.\n   */\n\n\n  SubscriptionMap.prototype.subscribe = function (eventName, f) {\n    var sub = new Subscription(this, eventName, f);\n    this.subIdMap[sub.id] = sub;\n    var subList = this.subEventNameMap[eventName] || [];\n    subList.push(sub);\n    this.subEventNameMap[eventName] = subList;\n    return sub;\n  };\n  /**\n   * Unsubscribe a subscription matching the given event name and id.\n   */\n\n\n  SubscriptionMap.prototype.unsubscribe = function (eventName, subId) {\n    if (connect.contains(this.subEventNameMap, eventName)) {\n      this.subEventNameMap[eventName] = this.subEventNameMap[eventName].filter(function (s) {\n        return s.id !== subId;\n      });\n\n      if (this.subEventNameMap[eventName].length < 1) {\n        delete this.subEventNameMap[eventName];\n      }\n    }\n\n    if (connect.contains(this.subIdMap, subId)) {\n      delete this.subIdMap[subId];\n    }\n  };\n  /**\n   * Get a list of all subscriptions in the subscription map.\n   */\n\n\n  SubscriptionMap.prototype.getAllSubscriptions = function () {\n    return connect.values(this.subEventNameMap).reduce(function (a, b) {\n      return a.concat(b);\n    }, []);\n  };\n  /**\n   * Get a list of subscriptions for the given event name, or an empty\n   * list if there are no subscriptions.\n   */\n\n\n  SubscriptionMap.prototype.getSubscriptions = function (eventName) {\n    return this.subEventNameMap[eventName] || [];\n  };\n  /**\n   * An object which maintains a map of subscriptions and serves as the\n   * mechanism for triggering events to be handled by subscribers.\n   */\n\n\n  var EventBus = function (paramsIn) {\n    var params = paramsIn || {};\n    this.subMap = new SubscriptionMap();\n    this.logEvents = params.logEvents || false;\n  };\n  /**\n   * Subscribe to the named event.  Returns a new Subscription object\n   * which can be used to unsubscribe.\n   */\n\n\n  EventBus.prototype.subscribe = function (eventName, f) {\n    connect.assertNotNull(eventName, 'eventName');\n    connect.assertNotNull(f, 'f');\n    connect.assertTrue(connect.isFunction(f), 'f must be a function');\n    return this.subMap.subscribe(eventName, f);\n  };\n  /**\n   * Subscribe a function to be called on all events.\n   */\n\n\n  EventBus.prototype.subscribeAll = function (f) {\n    connect.assertNotNull(f, 'f');\n    connect.assertTrue(connect.isFunction(f), 'f must be a function');\n    return this.subMap.subscribe(ALL_EVENTS, f);\n  };\n  /**\n   * Get a list of subscriptions for the given event name, or an empty\n   * list if there are no subscriptions.\n   */\n\n\n  EventBus.prototype.getSubscriptions = function (eventName) {\n    return this.subMap.getSubscriptions(eventName);\n  };\n  /**\n   * Trigger the given event with the given data.  All methods subscribed\n   * to this event will be called and are provided with the given arbitrary\n   * data object and the name of the event, in that order.\n   */\n\n\n  EventBus.prototype.trigger = function (eventName, data) {\n    connect.assertNotNull(eventName, 'eventName');\n    var self = this;\n    var allEventSubs = this.subMap.getSubscriptions(ALL_EVENTS);\n    var eventSubs = this.subMap.getSubscriptions(eventName);\n\n    if (this.logEvents && eventName !== connect.EventType.LOG && eventName !== connect.EventType.MASTER_RESPONSE && eventName !== connect.EventType.API_METRIC && eventName !== connect.EventType.SERVER_BOUND_INTERNAL_LOG) {\n      connect.getLog().trace(\"Publishing event: %s\", eventName).sendInternalLogToServer();\n    }\n\n    if (eventName.startsWith(connect.ContactEvents.ACCEPTED) && data && data.contactId && !(data instanceof connect.Contact)) {\n      data = new connect.Contact(data.contactId);\n    }\n\n    allEventSubs.concat(eventSubs).forEach(function (sub) {\n      try {\n        sub.f(data || null, eventName, self);\n      } catch (e) {\n        connect.getLog().error(\"'%s' event handler failed.\", eventName).withException(e).sendInternalLogToServer();\n      }\n    });\n  };\n  /**\n   * Returns a closure which bridges an event from another EventBus to this bus.\n   *\n   * Usage:\n   * conduit.onUpstream(\"MyEvent\", bus.bridge());\n   */\n\n\n  EventBus.prototype.bridge = function () {\n    var self = this;\n    return function (data, event) {\n      self.trigger(event, data);\n    };\n  };\n  /**\n   * Unsubscribe all events in the event bus.\n   */\n\n\n  EventBus.prototype.unsubscribeAll = function () {\n    this.subMap.getAllSubscriptions().forEach(function (sub) {\n      sub.unsubscribe();\n    });\n  };\n\n  connect.EventBus = EventBus;\n  connect.EventFactory = EventFactory;\n  connect.EventType = EventType;\n  connect.AgentEvents = AgentEvents;\n  connect.ConfigurationEvents = ConfigurationEvents;\n  connect.ConnectionEvents = ConnectionEvents;\n  connect.ConnnectionEvents = ConnectionEvents; //deprecate on next major version release.\n\n  connect.ContactEvents = ContactEvents;\n  connect.ChannelViewEvents = ChannelViewEvents;\n  connect.TaskEvents = TaskEvents;\n  connect.VoiceIdEvents = VoiceIdEvents;\n  connect.WebSocketEvents = WebSocketEvents;\n  connect.MasterTopics = MasterTopics;\n})();\n/*\n * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\n(function () {\n  var global = this;\n  connect = global.connect || {};\n  global.connect = connect;\n  global.lily = connect;\n  /**---------------------------------------------------------------\n   * class Stream\n   *\n   * Represents an object from which messages can be read and to which\n   * messages can be sent.\n   */\n\n  var Stream = function () {};\n  /**\n   * Send a message to the stream.  This method must be implemented by subclasses.\n   */\n\n\n  Stream.prototype.send = function (message) {\n    throw new connect.NotImplementedError();\n  };\n  /**\n   * Provide a method to be called when messages are received from this stream.\n   * This method must be implemented by subclasses.\n   */\n\n\n  Stream.prototype.onMessage = function (f) {\n    throw new connect.NotImplementedError();\n  };\n  /**---------------------------------------------------------------\n   * class NullStream extends Stream\n   *\n   * A null stream which provides no message sending or receiving facilities.\n   */\n\n\n  var NullStream = function () {\n    Stream.call(this);\n  };\n\n  NullStream.prototype = Object.create(Stream.prototype);\n  NullStream.prototype.constructor = NullStream;\n\n  NullStream.prototype.onMessage = function (f) {};\n\n  NullStream.prototype.send = function (message) {};\n  /**---------------------------------------------------------------\n   * class WindowStream extends Stream\n   *\n   * A stream for communicating with a window object.  The domain provided\n   * must match the allowed message domains of the downstream receiver\n   * or messages will be rejected, see https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage\n   * for more info.\n   */\n\n\n  var WindowStream = function (win, domain) {\n    Stream.call(this);\n    this.window = win;\n    this.domain = domain || '*';\n  };\n\n  WindowStream.prototype = Object.create(Stream.prototype);\n  WindowStream.prototype.constructor = WindowStream;\n\n  WindowStream.prototype.send = function (message) {\n    this.window.postMessage(message, this.domain);\n  };\n\n  WindowStream.prototype.onMessage = function (f) {\n    this.window.addEventListener(\"message\", f);\n  };\n  /**---------------------------------------------------------------\n   * class WindowIOStream extends Stream\n   *\n   * A stream used by IFrame/popup windows to communicate with their parents\n   * and vise versa.\n   *\n   * This object encapsulates the fact that incoming and outgoing messages\n   * arrive on different windows and allows this to be managed as a single\n   * Stream object.\n   */\n\n\n  var WindowIOStream = function (inputwin, outputwin, domain) {\n    Stream.call(this);\n    this.input = inputwin;\n    this.output = outputwin;\n    this.domain = domain || '*';\n  };\n\n  WindowIOStream.prototype = Object.create(Stream.prototype);\n  WindowIOStream.prototype.constructor = WindowIOStream;\n\n  WindowIOStream.prototype.send = function (message) {\n    this.output.postMessage(message, this.domain);\n  };\n\n  WindowIOStream.prototype.onMessage = function (f) {\n    this.input.addEventListener(\"message\", message => {\n      if (message.source === this.output) {\n        f(message);\n      } else {\n        connect.getLog().warn(\"[Window IO Stream] message event came from somewhere other than the CCP iFrame\").withCrossOriginEventObject(message).sendInternalLogToServer();\n      }\n    });\n  };\n  /**---------------------------------------------------------------\n   * class PortStream extends Stream\n   *\n   * A stream wrapping an HTML5 Worker port.  This could be the port\n   * used to connect to a Worker or one of the multitude of ports\n   * made available to a SharedWorker for communication back to\n   * its connected clients.\n   */\n\n\n  var PortStream = function (port) {\n    Stream.call(this);\n    this.port = port;\n    this.id = connect.randomId();\n  };\n\n  PortStream.prototype = Object.create(Stream.prototype);\n  PortStream.prototype.constructor = PortStream;\n\n  PortStream.prototype.send = function (message) {\n    this.port.postMessage(message);\n  };\n\n  PortStream.prototype.onMessage = function (f) {\n    this.port.addEventListener(\"message\", f);\n  };\n\n  PortStream.prototype.getId = function () {\n    return this.id;\n  };\n  /**---------------------------------------------------------------\n   * class StreamMultiplexer extends Stream\n   *\n   * A wrapper for multiplexed downstream communication with\n   * multiple streams at once.  Mainly useful for the SharedWorker to\n   * broadcast events to many PortStream objects at once.\n   */\n\n\n  var StreamMultiplexer = function (streams) {\n    Stream.call(this);\n    this.streamMap = streams ? connect.index(streams, function (s) {\n      return s.getId();\n    }) : {};\n    this.messageListeners = [];\n  };\n\n  StreamMultiplexer.prototype = Object.create(Stream.prototype);\n  StreamMultiplexer.prototype.constructor = StreamMultiplexer;\n  /**\n   * Send a message to all ports in the multiplexer.\n   */\n\n  StreamMultiplexer.prototype.send = function (message) {\n    this.getStreams().forEach(function (stream) {\n      try {\n        stream.send(message);\n      } catch (e) {// Couldn't send message to one of the downstreams for some reason...\n        // No reliable logging possible without further failures,\n        // no recovery, just eat it.\n      }\n    });\n  };\n  /**\n   * Register a method which will be called when a message is received from\n   * any of the downstreams.\n   */\n\n\n  StreamMultiplexer.prototype.onMessage = function (f) {\n    this.messageListeners.push(f); // Update existing streams with the new listener.\n\n    this.getStreams().forEach(function (stream) {\n      stream.onMessage(f);\n    });\n  };\n  /**\n   * Add a stream to the multiplexer.\n   */\n\n\n  StreamMultiplexer.prototype.addStream = function (stream) {\n    var self = this;\n    this.streamMap[stream.getId()] = stream; // Update stream with existing listeners.\n\n    this.messageListeners.forEach(function (messageListener) {\n      stream.onMessage(messageListener);\n    });\n  };\n  /**\n   * Remove the given downstream.  This is typically used in response\n   * to the SharedWorker's onclose event, indicating that a consumer\n   * tab has been closed.\n   */\n\n\n  StreamMultiplexer.prototype.removeStream = function (stream) {\n    delete this.streamMap[stream.getId()];\n  };\n  /**\n   * Get a list of streams in the multiplexer.\n   */\n\n\n  StreamMultiplexer.prototype.getStreams = function (stream) {\n    return connect.values(this.streamMap);\n  };\n  /**\n   * Get the stream matching the given port.\n   */\n\n\n  StreamMultiplexer.prototype.getStreamForPort = function (port) {\n    return connect.find(this.getStreams(), function (s) {\n      return s.port === port;\n    });\n  };\n  /**---------------------------------------------------------------\n   * class Conduit\n   *\n   * An object which bridges an upstream and a downstream, allowing messages\n   * to be passed to and from each and providing an event bus for event\n   * subscriptions to be made upstream and downstream.\n   */\n\n\n  var Conduit = function (name, upstream, downstream) {\n    this.name = name;\n    this.upstream = upstream || new NullStream();\n    this.downstream = downstream || new NullStream();\n    this.downstreamBus = new connect.EventBus();\n    this.upstreamBus = new connect.EventBus();\n    this.upstream.onMessage(connect.hitch(this, this._dispatchEvent, this.upstreamBus));\n    this.downstream.onMessage(connect.hitch(this, this._dispatchEvent, this.downstreamBus));\n  };\n\n  Conduit.prototype.onUpstream = function (eventName, f) {\n    connect.assertNotNull(eventName, 'eventName');\n    connect.assertNotNull(f, 'f');\n    connect.assertTrue(connect.isFunction(f), 'f must be a function');\n    return this.upstreamBus.subscribe(eventName, f);\n  };\n\n  Conduit.prototype.onAllUpstream = function (f) {\n    connect.assertNotNull(f, 'f');\n    connect.assertTrue(connect.isFunction(f), 'f must be a function');\n    return this.upstreamBus.subscribeAll(f);\n  };\n\n  Conduit.prototype.onDownstream = function (eventName, f) {\n    connect.assertNotNull(eventName, 'eventName');\n    connect.assertNotNull(f, 'f');\n    connect.assertTrue(connect.isFunction(f), 'f must be a function');\n    return this.downstreamBus.subscribe(eventName, f);\n  };\n\n  Conduit.prototype.onAllDownstream = function (f) {\n    connect.assertNotNull(f, 'f');\n    connect.assertTrue(connect.isFunction(f), 'f must be a function');\n    return this.downstreamBus.subscribeAll(f);\n  };\n\n  Conduit.prototype.sendUpstream = function (eventName, data) {\n    connect.assertNotNull(eventName, 'eventName');\n    this.upstream.send({\n      event: eventName,\n      data: data\n    });\n  };\n\n  Conduit.prototype.sendDownstream = function (eventName, data) {\n    connect.assertNotNull(eventName, 'eventName');\n    this.downstream.send({\n      event: eventName,\n      data: data\n    });\n  };\n\n  Conduit.prototype._dispatchEvent = function (bus, messageEvent) {\n    var message = messageEvent.data;\n\n    if (message.event) {\n      bus.trigger(message.event, message.data);\n    }\n  };\n  /**\n   * Returns a closure which passes events upstream.\n   *\n   * Usage:\n   * conduit.onDownstream(\"MyEvent\", conduit.passUpstream());\n   */\n\n\n  Conduit.prototype.passUpstream = function () {\n    var self = this;\n    return function (data, eventName) {\n      self.upstream.send({\n        event: eventName,\n        data: data\n      });\n    };\n  };\n  /**\n   * Returns a closure which passes events downstream.\n   *\n   * Usage:\n   * conduit.onUpstream(\"MyEvent\", conduit.passDownstream());\n   */\n\n\n  Conduit.prototype.passDownstream = function () {\n    var self = this;\n    return function (data, eventName) {\n      self.downstream.send({\n        event: eventName,\n        data: data\n      });\n    };\n  };\n  /**\n   * Shutdown the conduit's event busses and remove all subscriptions.\n   */\n\n\n  Conduit.prototype.shutdown = function () {\n    this.upstreamBus.unsubscribeAll();\n    this.downstreamBus.unsubscribeAll();\n  };\n  /**---------------------------------------------------------------\n   * class IFrameConduit extends Conduit\n   *\n   * Creates a conduit for the given IFrame element.\n   */\n\n\n  var IFrameConduit = function (name, window, iframe, domain) {\n    Conduit.call(this, name, new WindowIOStream(window, iframe.contentWindow, domain || '*'), null);\n  };\n\n  IFrameConduit.prototype = Object.create(Conduit.prototype);\n  IFrameConduit.prototype.constructor = IFrameConduit;\n  connect.Stream = Stream;\n  connect.NullStream = NullStream;\n  connect.WindowStream = WindowStream;\n  connect.WindowIOStream = WindowIOStream;\n  connect.PortStream = PortStream;\n  connect.StreamMultiplexer = StreamMultiplexer;\n  connect.Conduit = Conduit;\n  connect.IFrameConduit = IFrameConduit;\n})();\n/*\n * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\n(function () {\n  var global = this;\n  connect = global.connect || {};\n  global.connect = connect;\n  global.lily = connect;\n  /**---------------------------------------------------------------\n   * enum ClientMethods\n   */\n\n  connect.ClientMethods = connect.makeEnum(['getAgentSnapshot', 'putAgentState', 'getAgentStates', 'getDialableCountryCodes', 'getRoutingProfileQueues', 'getAgentPermissions', 'getAgentConfiguration', 'updateAgentConfiguration', 'acceptContact', 'createOutboundContact', 'createTaskContact', 'clearContact', 'completeContact', 'destroyContact', 'rejectContact', 'notifyContactIssue', 'updateContactAttributes', 'createAdditionalConnection', 'destroyConnection', 'holdConnection', 'resumeConnection', 'toggleActiveConnections', 'conferenceConnections', 'sendClientLogs', 'sendDigits', 'sendSoftphoneCallReport', 'sendSoftphoneCallMetrics', 'getEndpoints', 'getNewAuthToken', 'createTransport']);\n  /**---------------------------------------------------------------\n   * enum AgentAppClientMethods\n   */\n\n  connect.AgentAppClientMethods = {\n    GET_CONTACT: \"AgentAppService.Lcms.getContact\",\n    DELETE_SPEAKER: \"AgentAppService.VoiceId.deleteSpeaker\",\n    ENROLL_BY_SESSION: \"AgentAppService.VoiceId.enrollBySession\",\n    EVALUATE_SESSION: \"AgentAppService.VoiceId.evaluateSession\",\n    DESCRIBE_SPEAKER: \"AgentAppService.VoiceId.describeSpeaker\",\n    OPT_OUT_SPEAKER: \"AgentAppService.VoiceId.optOutSpeaker\",\n    UPDATE_VOICE_ID_DATA: \"AgentAppService.Lcms.updateVoiceIdData\",\n    DESCRIBE_SESSION: \"AgentAppService.VoiceId.describeSession\",\n    UPDATE_SESSION: \"AgentAppService.VoiceId.updateSession\",\n    START_VOICE_ID_SESSION: \"AgentAppService.Nasa.startVoiceIdSession\",\n    LIST_INTEGRATION_ASSOCIATIONS: \"AgentAppService.Acs.listIntegrationAssociations\"\n  };\n  /**---------------------------------------------------------------\n   * enum MasterMethods\n   */\n\n  connect.MasterMethods = connect.makeEnum(['becomeMaster', 'checkMaster']);\n  /**---------------------------------------------------------------\n   * abstract class ClientBase\n   */\n\n  var ClientBase = function () {};\n\n  ClientBase.EMPTY_CALLBACKS = {\n    success: function () {},\n    failure: function () {}\n  };\n\n  ClientBase.prototype.call = function (method, paramsIn, callbacksIn) {\n    connect.assertNotNull(method, 'method');\n    var params = paramsIn || {};\n    var callbacks = callbacksIn || ClientBase.EMPTY_CALLBACKS;\n\n    this._callImpl(method, params, callbacks);\n  };\n\n  ClientBase.prototype._callImpl = function (method, params, callbacks) {\n    throw new connect.NotImplementedError();\n  };\n  /**---------------------------------------------------------------\n   * class NullClient extends ClientBase\n   */\n\n\n  var NullClient = function () {\n    ClientBase.call(this);\n  };\n\n  NullClient.prototype = Object.create(ClientBase.prototype);\n  NullClient.prototype.constructor = NullClient;\n\n  NullClient.prototype._callImpl = function (method, params, callbacks) {\n    if (callbacks && callbacks.failure) {\n      var message = connect.sprintf('No such method exists on NULL client: %s', method);\n      callbacks.failure(new connect.ValueError(message), {\n        message: message\n      });\n    }\n  };\n  /**---------------------------------------------------------------\n   * abstract class UpstreamConduitClientBase extends ClientBase\n   */\n\n\n  var UpstreamConduitClientBase = function (conduit, requestEvent, responseEvent) {\n    ClientBase.call(this);\n    this.conduit = conduit;\n    this.requestEvent = requestEvent;\n    this.responseEvent = responseEvent;\n    this._requestIdCallbacksMap = {};\n    this.conduit.onUpstream(responseEvent, connect.hitch(this, this._handleResponse));\n  };\n\n  UpstreamConduitClientBase.prototype = Object.create(ClientBase.prototype);\n  UpstreamConduitClientBase.prototype.constructor = UpstreamConduitClientBase;\n\n  UpstreamConduitClientBase.prototype._callImpl = function (method, params, callbacks) {\n    var request = connect.EventFactory.createRequest(this.requestEvent, method, params);\n    this._requestIdCallbacksMap[request.requestId] = callbacks;\n    this.conduit.sendUpstream(request.event, request);\n  };\n\n  UpstreamConduitClientBase.prototype._getCallbacksForRequest = function (requestId) {\n    var callbacks = this._requestIdCallbacksMap[requestId] || null;\n\n    if (callbacks != null) {\n      delete this._requestIdCallbacksMap[requestId];\n    }\n\n    return callbacks;\n  };\n\n  UpstreamConduitClientBase.prototype._handleResponse = function (data) {\n    var callbacks = this._getCallbacksForRequest(data.requestId);\n\n    if (callbacks == null) {\n      return;\n    }\n\n    if (data.err && callbacks.failure) {\n      callbacks.failure(data.err, data.data);\n    } else if (callbacks.success) {\n      callbacks.success(data.data);\n    }\n  };\n  /**---------------------------------------------------------------\n   * class UpstreamConduitClient extends ClientBase\n   */\n\n\n  var UpstreamConduitClient = function (conduit) {\n    UpstreamConduitClientBase.call(this, conduit, connect.EventType.API_REQUEST, connect.EventType.API_RESPONSE);\n  };\n\n  UpstreamConduitClient.prototype = Object.create(UpstreamConduitClientBase.prototype);\n  UpstreamConduitClient.prototype.constructor = UpstreamConduitClient;\n  /**---------------------------------------------------------------\n   * class UpstreamConduitMasterClient extends ClientBase\n   */\n\n  var UpstreamConduitMasterClient = function (conduit) {\n    UpstreamConduitClientBase.call(this, conduit, connect.EventType.MASTER_REQUEST, connect.EventType.MASTER_RESPONSE);\n  };\n\n  UpstreamConduitMasterClient.prototype = Object.create(UpstreamConduitClientBase.prototype);\n  UpstreamConduitMasterClient.prototype.constructor = UpstreamConduitMasterClient;\n  /**---------------------------------------------------------------\n  * class AgentAppClient extends ClientBase\n  */\n\n  var AgentAppClient = function (authCookieName, authToken, endpoint) {\n    connect.assertNotNull(authCookieName, 'authCookieName');\n    connect.assertNotNull(authToken, 'authToken');\n    connect.assertNotNull(endpoint, 'endpoint');\n    ClientBase.call(this);\n    this.endpointUrl = connect.getUrlWithProtocol(endpoint);\n    this.authToken = authToken;\n    this.authCookieName = authCookieName;\n  };\n\n  AgentAppClient.prototype = Object.create(ClientBase.prototype);\n  AgentAppClient.prototype.constructor = AgentAppClient;\n\n  AgentAppClient.prototype._callImpl = function (method, params, callbacks) {\n    var self = this;\n    var bear = {};\n    bear[self.authCookieName] = self.authToken;\n    var options = {\n      method: 'post',\n      body: JSON.stringify(params || {}),\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json',\n        'X-Amz-target': method,\n        'X-Amz-Bearer': JSON.stringify(bear)\n      }\n    };\n    connect.fetch(self.endpointUrl, options).then(function (res) {\n      callbacks.success(res);\n    }).catch(function (err) {\n      const reader = err.body.getReader();\n      let body = '';\n      const decoder = new TextDecoder();\n      reader.read().then(function processText({\n        done,\n        value\n      }) {\n        if (done) {\n          var error = JSON.parse(body);\n          error.status = err.status;\n          callbacks.failure(error);\n          return;\n        }\n\n        body += decoder.decode(value);\n        return reader.read().then(processText);\n      });\n    });\n  };\n  /**---------------------------------------------------------------\n   * class AWSClient extends ClientBase\n   */\n\n\n  var AWSClient = function (authToken, region, endpointIn) {\n    connect.assertNotNull(authToken, 'authToken');\n    connect.assertNotNull(region, 'region');\n    ClientBase.call(this);\n    AWS.config.credentials = new AWS.Credentials({});\n    AWS.config.region = region;\n    this.authToken = authToken;\n    var baseUrl = connect.getBaseUrl();\n    var endpointUrl = endpointIn || (baseUrl.includes(\".awsapps.com\") ? baseUrl + '/connect/api' : baseUrl + '/api');\n    var endpoint = new AWS.Endpoint(endpointUrl);\n    this.client = new AWS.Connect({\n      endpoint: endpoint\n    });\n  };\n\n  AWSClient.prototype = Object.create(ClientBase.prototype);\n  AWSClient.prototype.constructor = AWSClient;\n\n  AWSClient.prototype._callImpl = function (method, params, callbacks) {\n    var self = this;\n    var log = connect.getLog();\n\n    if (!connect.contains(this.client, method)) {\n      var message = connect.sprintf('No such method exists on AWS client: %s', method);\n      callbacks.failure(new connect.ValueError(message), {\n        message: message\n      });\n    } else {\n      params = this._translateParams(method, params);\n      log.trace(\"AWSClient: --> Calling operation '%s'\", method).sendInternalLogToServer();\n      this.client[method](params).on('build', function (request) {\n        request.httpRequest.headers['X-Amz-Bearer'] = self.authToken;\n      }).send(function (err, data) {\n        try {\n          if (err) {\n            if (err.code === connect.CTIExceptions.UNAUTHORIZED_EXCEPTION) {\n              callbacks.authFailure();\n            } else if (callbacks.accessDenied && (err.code === connect.CTIExceptions.ACCESS_DENIED_EXCEPTION || err.statusCode === 403)) {\n              callbacks.accessDenied();\n            } else {\n              // Can't pass err directly to postMessage\n              // postMessage() tries to clone the err object and failed.\n              // Refer to https://github.com/goatslacker/alt-devtool/issues/5\n              var error = {};\n              error.type = err.code;\n              error.message = err.message;\n              error.stack = err.stack ? err.stack.split('\\n') : [];\n              callbacks.failure(error, data);\n            }\n\n            log.trace(\"AWSClient: <-- Operation '%s' failed: %s\", method, JSON.stringify(err)).sendInternalLogToServer();\n          } else {\n            log.trace(\"AWSClient: <-- Operation '%s' succeeded.\", method).withObject(data).sendInternalLogToServer();\n            callbacks.success(data);\n          }\n        } catch (e) {\n          connect.getLog().error(\"Failed to handle AWS API request for method %s\", method).withException(e).sendInternalLogToServer();\n        }\n      });\n    }\n  };\n\n  AWSClient.prototype._requiresAuthenticationParam = function (method) {\n    return method !== connect.ClientMethods.COMPLETE_CONTACT && method !== connect.ClientMethods.CLEAR_CONTACT && method !== connect.ClientMethods.REJECT_CONTACT && method !== connect.ClientMethods.CREATE_TASK_CONTACT;\n  };\n\n  AWSClient.prototype._translateParams = function (method, params) {\n    switch (method) {\n      case connect.ClientMethods.UPDATE_AGENT_CONFIGURATION:\n        params.configuration = this._translateAgentConfiguration(params.configuration);\n        break;\n\n      case connect.ClientMethods.SEND_SOFTPHONE_CALL_METRICS:\n        params.softphoneStreamStatistics = this._translateSoftphoneStreamStatistics(params.softphoneStreamStatistics);\n        break;\n\n      case connect.ClientMethods.SEND_SOFTPHONE_CALL_REPORT:\n        params.report = this._translateSoftphoneCallReport(params.report);\n        break;\n\n      default:\n        break;\n    }\n\n    if (this._requiresAuthenticationParam(method)) {\n      params.authentication = {\n        authToken: this.authToken\n      };\n    }\n\n    return params;\n  };\n\n  AWSClient.prototype._translateAgentConfiguration = function (config) {\n    return {\n      name: config.name,\n      softphoneEnabled: config.softphoneEnabled,\n      softphoneAutoAccept: config.softphoneAutoAccept,\n      extension: config.extension,\n      routingProfile: this._translateRoutingProfile(config.routingProfile),\n      agentPreferences: config.agentPreferences\n    };\n  };\n\n  AWSClient.prototype._translateRoutingProfile = function (profile) {\n    return {\n      name: profile.name,\n      routingProfileARN: profile.routingProfileARN,\n      defaultOutboundQueue: this._translateQueue(profile.defaultOutboundQueue)\n    };\n  };\n\n  AWSClient.prototype._translateQueue = function (queue) {\n    return {\n      queueARN: queue.queueARN,\n      name: queue.name\n    };\n  };\n\n  AWSClient.prototype._translateSoftphoneStreamStatistics = function (stats) {\n    stats.forEach(function (stat) {\n      if ('packetsCount' in stat) {\n        stat.packetCount = stat.packetsCount;\n        delete stat.packetsCount;\n      }\n    });\n    return stats;\n  };\n\n  AWSClient.prototype._translateSoftphoneCallReport = function (report) {\n    if ('handshakingTimeMillis' in report) {\n      report.handshakeTimeMillis = report.handshakingTimeMillis;\n      delete report.handshakingTimeMillis;\n    }\n\n    if ('preTalkingTimeMillis' in report) {\n      report.preTalkTimeMillis = report.preTalkingTimeMillis;\n      delete report.preTalkingTimeMillis;\n    }\n\n    if ('handshakingFailure' in report) {\n      report.handshakeFailure = report.handshakingFailure;\n      delete report.handshakingFailure;\n    }\n\n    if ('talkingTimeMillis' in report) {\n      report.talkTimeMillis = report.talkingTimeMillis;\n      delete report.talkingTimeMillis;\n    }\n\n    report.softphoneStreamStatistics = this._translateSoftphoneStreamStatistics(report.softphoneStreamStatistics);\n    return report;\n  };\n\n  connect.ClientBase = ClientBase;\n  connect.NullClient = NullClient;\n  connect.UpstreamConduitClient = UpstreamConduitClient;\n  connect.UpstreamConduitMasterClient = UpstreamConduitMasterClient;\n  connect.AWSClient = AWSClient;\n  connect.AgentAppClient = AgentAppClient;\n})();\n/*\n * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\n(function () {\n  var global = this;\n  connect = global.connect || {};\n  global.connect = connect;\n  global.lily = connect;\n  /**-------------------------------------------------------------------------\n   * GraphLink <<abstract class>>\n   *\n   * Represents the association of one or more attributes to a state transition.\n   */\n\n  var GraphLink = function (fromState, toState) {\n    connect.assertNotNull(fromState, 'fromState');\n    connect.assertNotNull(toState, 'toState');\n    this.fromState = fromState;\n    this.toState = toState;\n  };\n\n  GraphLink.prototype.getAssociations = function (context) {\n    throw connect.NotImplementedError();\n  };\n\n  GraphLink.prototype.getFromState = function () {\n    return this.fromState;\n  };\n\n  GraphLink.prototype.getToState = function () {\n    return this.toState;\n  };\n  /**-------------------------------------------------------------------------\n   * DirectGraphLink <<concrete class>> extends GraphLink\n   *\n   * Represents the by-value representation of one or more attributes to a\n   * state transition.\n   */\n\n\n  var DirectGraphLink = function (fromState, toState, associations) {\n    connect.assertNotNull(fromState, 'fromState');\n    connect.assertNotNull(toState, 'toState');\n    connect.assertNotNull(associations, 'associations');\n    GraphLink.call(this, fromState, toState);\n    this.associations = associations;\n  };\n\n  DirectGraphLink.prototype = Object.create(GraphLink.prototype);\n  DirectGraphLink.prototype.constructor = DirectGraphLink;\n\n  DirectGraphLink.prototype.getAssociations = function (context) {\n    return this.associations;\n  };\n  /**\n   * FunctionalGraphLink <<concrete class>> extends GraphLink\n   *\n   * Represents a functional association of one or more attributes to a\n   * state transition.\n   */\n\n\n  var FunctionalGraphLink = function (fromState, toState, closure) {\n    connect.assertNotNull(fromState, 'fromState');\n    connect.assertNotNull(toState, 'toState');\n    connect.assertNotNull(closure, 'closure');\n    connect.assertTrue(connect.isFunction(closure), 'closure must be a function');\n    GraphLink.call(this, fromState, toState);\n    this.closure = closure;\n  };\n\n  FunctionalGraphLink.prototype = Object.create(GraphLink.prototype);\n  FunctionalGraphLink.prototype.constructor = FunctionalGraphLink;\n\n  FunctionalGraphLink.prototype.getAssociations = function (context) {\n    return this.closure(context, this.getFromState(), this.getToState());\n  };\n  /**-------------------------------------------------------------------------\n   * EventGraph <<class>>\n   *\n   * Builds a map of associations from one state to another in context of a\n   * particular object.  The associations can be direct (one or more values)\n   * or functional (a method returning one or more values), and are used to\n   * provide additional contextual event hooks for the UI to consume.\n   */\n\n\n  var EventGraph = function () {\n    this.fromMap = {};\n  };\n\n  EventGraph.ANY = \"<<any>>\";\n\n  EventGraph.prototype.assoc = function (fromStateObj, toStateObj, assocObj) {\n    var self = this;\n\n    if (!fromStateObj) {\n      throw new Error(\"fromStateObj is not defined.\");\n    }\n\n    if (!toStateObj) {\n      throw new Error(\"toStateObj is not defined.\");\n    }\n\n    if (!assocObj) {\n      throw new Error(\"assocObj is not defined.\");\n    }\n\n    if (fromStateObj instanceof Array) {\n      fromStateObj.forEach(function (fromState) {\n        self.assoc(fromState, toStateObj, assocObj);\n      });\n    } else if (toStateObj instanceof Array) {\n      toStateObj.forEach(function (toState) {\n        self.assoc(fromStateObj, toState, assocObj);\n      });\n    } else {\n      if (typeof assocObj === \"function\") {\n        this._addAssociation(new FunctionalGraphLink(fromStateObj, toStateObj, assocObj));\n      } else if (assocObj instanceof Array) {\n        this._addAssociation(new DirectGraphLink(fromStateObj, toStateObj, assocObj));\n      } else {\n        this._addAssociation(new DirectGraphLink(fromStateObj, toStateObj, [assocObj]));\n      }\n    }\n\n    return this;\n  };\n\n  EventGraph.prototype.getAssociations = function (context, fromState, toState) {\n    connect.assertNotNull(fromState, 'fromState');\n    connect.assertNotNull(toState, 'toState');\n    var associations = [];\n    var toMapFromAny = this.fromMap[EventGraph.ANY] || {};\n    var toMap = this.fromMap[fromState] || {};\n    associations = associations.concat(this._getAssociationsFromMap(toMapFromAny, context, fromState, toState));\n    associations = associations.concat(this._getAssociationsFromMap(toMap, context, fromState, toState));\n    return associations;\n  };\n\n  EventGraph.prototype._addAssociation = function (assoc) {\n    var toMap = this.fromMap[assoc.getFromState()];\n\n    if (!toMap) {\n      toMap = this.fromMap[assoc.getFromState()] = {};\n    }\n\n    var assocList = toMap[assoc.getToState()];\n\n    if (!assocList) {\n      assocList = toMap[assoc.getToState()] = [];\n    }\n\n    assocList.push(assoc);\n  };\n\n  EventGraph.prototype._getAssociationsFromMap = function (map, context, fromState, toState) {\n    var assocList = (map[EventGraph.ANY] || []).concat(map[toState] || []);\n    return assocList.reduce(function (prev, assoc) {\n      return prev.concat(assoc.getAssociations(context));\n    }, []);\n  };\n\n  connect.EventGraph = EventGraph;\n})();\n/*\n * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\n(function () {\n  var global = this;\n  connect = global.connect || {};\n  global.connect = connect;\n  global.lily = connect;\n  /*----------------------------------------------------------------\n   * enum AgentStateType\n   */\n\n  connect.AgentStateType = connect.makeEnum(['init', 'routable', 'not_routable', 'offline']);\n  connect.AgentStatusType = connect.AgentStateType;\n  /**\n   * enum AgentAvailStates\n   */\n\n  connect.AgentAvailStates = connect.makeEnum(['Init', 'Busy', 'AfterCallWork', 'CallingCustomer', 'Dialing', 'Joining', 'PendingAvailable', 'PendingBusy']);\n  /**\n   * enum AgentErrorStates\n   */\n\n  connect.AgentErrorStates = connect.makeEnum(['Error', 'AgentHungUp', 'BadAddressAgent', 'BadAddressCustomer', 'Default', 'FailedConnectAgent', 'FailedConnectCustomer', 'InvalidLocale', 'LineEngagedAgent', 'LineEngagedCustomer', 'MissedCallAgent', 'MissedCallCustomer', 'MultipleCcpWindows', 'RealtimeCommunicationError']);\n  /*----------------------------------------------------------------\n   * enum AddressType\n   */\n\n  connect.EndpointType = connect.makeEnum(['phone_number', 'agent', 'queue']);\n  connect.AddressType = connect.EndpointType;\n  /*----------------------------------------------------------------\n   * enum ConnectionType\n   */\n\n  connect.ConnectionType = connect.makeEnum(['agent', 'inbound', 'outbound', 'monitoring']);\n  /*----------------------------------------------------------------\n   * enum ConnectionStateType\n   */\n\n  connect.ConnectionStateType = connect.makeEnum(['init', 'connecting', 'connected', 'hold', 'disconnected']);\n  connect.ConnectionStatusType = connect.ConnectionStateType;\n  connect.CONNECTION_ACTIVE_STATES = connect.set([connect.ConnectionStateType.CONNECTING, connect.ConnectionStateType.CONNECTED, connect.ConnectionStateType.HOLD]);\n  /*----------------------------------------------------------------\n   * enum ContactStateType\n   */\n\n  connect.ContactStateType = connect.makeEnum(['init', 'incoming', 'pending', 'connecting', 'connected', 'missed', 'error', 'ended']);\n  connect.ContactStatusType = connect.ContactStateType;\n  connect.CONTACT_ACTIVE_STATES = connect.makeEnum(['incoming', 'pending', 'connecting', 'connected']);\n  /*----------------------------------------------------------------\n   * enum ContactType\n   */\n\n  connect.ContactType = connect.makeEnum(['voice', 'queue_callback', 'chat', 'task']);\n  /*----------------------------------------------------------------\n   * enum ContactInitiationMethod\n   */\n\n  connect.ContactInitiationMethod = connect.makeEnum(['inbound', 'outbound', 'transfer', 'queue_transfer', 'callback', 'api', 'disconnect']);\n  /*----------------------------------------------------------------\n  * enum ChannelType\n  */\n\n  connect.ChannelType = connect.makeEnum(['VOICE', 'CHAT', 'TASK']);\n  /*----------------------------------------------------------------\n  * enum MediaType\n  */\n\n  connect.MediaType = connect.makeEnum(['softphone', 'chat', 'task']);\n  /*----------------------------------------------------------------\n   * enum SoftphoneCallType\n   */\n\n  connect.SoftphoneCallType = connect.makeEnum(['audio_video', 'video_only', 'audio_only', 'none']);\n  /*----------------------------------------------------------------\n   * enum for SoftphoneErrorTypes\n   */\n\n  connect.SoftphoneErrorTypes = connect.makeEnum(['unsupported_browser', 'microphone_not_shared', 'signalling_handshake_failure', 'signalling_connection_failure', 'ice_collection_timeout', 'user_busy_error', 'webrtc_error', 'realtime_communication_error', 'other']);\n  /*----------------------------------------------------------------\n   * enum for VoiceIdErrorTypes\n   */\n\n  connect.VoiceIdErrorTypes = connect.makeEnum(['no_speaker_id_found', 'speaker_id_not_enrolled', 'get_speaker_id_failed', 'get_speaker_status_failed', 'opt_out_speaker_failed', 'opt_out_speaker_in_lcms_failed', 'delete_speaker_failed', 'start_session_failed', 'evaluate_speaker_failed', 'session_not_exists', 'describe_session_failed', 'enroll_speaker_failed', 'update_speaker_id_failed', 'update_speaker_id_in_lcms_failed', 'not_supported_on_conference_calls', 'enroll_speaker_timeout', 'evaluate_speaker_timeout', 'get_domain_id_failed', 'no_domain_id_found']);\n  /*----------------------------------------------------------------\n   * enum for CTI exceptions\n   */\n\n  connect.CTIExceptions = connect.makeEnum([\"AccessDeniedException\", \"InvalidStateException\", \"BadEndpointException\", \"InvalidAgentARNException\", \"InvalidConfigurationException\", \"InvalidContactTypeException\", \"PaginationException\", \"RefreshTokenExpiredException\", \"SendDataFailedException\", \"UnauthorizedException\", \"QuotaExceededException\"]);\n  /*----------------------------------------------------------------\n   * enum for VoiceId streaming status\n   */\n\n  connect.VoiceIdStreamingStatus = connect.makeEnum([\"ONGOING\", \"ENDED\", \"PENDING_CONFIGURATION\"]);\n  /*----------------------------------------------------------------\n   * enum for VoiceId authentication decision\n   */\n\n  connect.VoiceIdAuthenticationDecision = connect.makeEnum([\"ACCEPT\", \"REJECT\", \"NOT_ENOUGH_SPEECH\", \"SPEAKER_NOT_ENROLLED\", \"SPEAKER_OPTED_OUT\", \"SPEAKER_ID_NOT_PROVIDED\", \"SPEAKER_EXPIRED\"]);\n  /*----------------------------------------------------------------\n   * enum for VoiceId fraud detection decision\n   */\n\n  connect.VoiceIdFraudDetectionDecision = connect.makeEnum([\"NOT_ENOUGH_SPEECH\", \"HIGH_RISK\", \"LOW_RISK\"]);\n  /*----------------------------------------------------------------\n   * enum for contact flow authentication decision \n   */\n\n  connect.ContactFlowAuthenticationDecision = connect.makeEnum([\"Authenticated\", \"NotAuthenticated\", \"Inconclusive\", \"NotEnrolled\", \"OptedOut\", \"NotEnabled\", \"Error\"]);\n  /*----------------------------------------------------------------\n   * enum for contact flow  fraud detection decision\n   */\n\n  connect.ContactFlowFraudDetectionDecision = connect.makeEnum([\"HighRisk\", \"LowRisk\", \"Inconclusive\", \"NotEnabled\", \"Error\"]);\n  /*----------------------------------------------------------------\n   * enum for VoiceId EnrollmentRequest Status \n   */\n\n  connect.VoiceIdEnrollmentRequestStatus = connect.makeEnum([\"NOT_ENOUGH_SPEECH\", \"IN_PROGRESS\", \"COMPLETED\", \"FAILED\"]);\n  /*----------------------------------------------------------------\n   * enum for VoiceId Speaker status\n   */\n\n  connect.VoiceIdSpeakerStatus = connect.makeEnum([\"OPTED_OUT\", \"ENROLLED\"]);\n  connect.VoiceIdConstants = {\n    EVALUATE_SESSION_DELAY: 10000,\n    EVALUATION_MAX_POLL_TIMES: 24,\n    // EvaluateSpeaker is Polling for maximum 2 mins.\n    EVALUATION_POLLING_INTERVAL: 5000,\n    ENROLLMENT_MAX_POLL_TIMES: 120,\n    // EnrollmentSpeaker is Polling for maximum 10 mins.\n    ENROLLMENT_POLLING_INTERVAL: 5000,\n    START_SESSION_DELAY: 8000\n  };\n  /*----------------------------------------------------------------\n   * constants for AgentPermissions\n   */\n\n  connect.AgentPermissions = {\n    OUTBOUND_CALL: 'outboundCall',\n    VOICE_ID: 'voiceId'\n  };\n  /*----------------------------------------------------------------\n   * class Agent\n   */\n\n  var Agent = function () {\n    if (!connect.agent.initialized) {\n      throw new connect.StateError(\"The agent is not yet initialized!\");\n    }\n  };\n\n  Agent.prototype._getData = function () {\n    return connect.core.getAgentDataProvider().getAgentData();\n  };\n\n  Agent.prototype._createContactAPI = function (contactData) {\n    return new connect.Contact(contactData.contactId);\n  };\n  /**\n   * @deprecated\n   * Use `contact.onPending` for any particular contact instead.\n   */\n\n\n  Agent.prototype.onContactPending = function (f) {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(connect.AgentEvents.CONTACT_PENDING, f);\n  };\n\n  Agent.prototype.onRefresh = function (f) {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(connect.AgentEvents.REFRESH, f);\n  };\n\n  Agent.prototype.onRoutable = function (f) {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(connect.AgentEvents.ROUTABLE, f);\n  };\n\n  Agent.prototype.onNotRoutable = function (f) {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(connect.AgentEvents.NOT_ROUTABLE, f);\n  };\n\n  Agent.prototype.onOffline = function (f) {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(connect.AgentEvents.OFFLINE, f);\n  };\n\n  Agent.prototype.onError = function (f) {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(connect.AgentEvents.ERROR, f);\n  };\n\n  Agent.prototype.onSoftphoneError = function (f) {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(connect.AgentEvents.SOFTPHONE_ERROR, f);\n  };\n\n  Agent.prototype.onWebSocketConnectionLost = function (f) {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(connect.AgentEvents.WEBSOCKET_CONNECTION_LOST, f);\n  };\n\n  Agent.prototype.onWebSocketConnectionGained = function (f) {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(connect.AgentEvents.WEBSOCKET_CONNECTION_GAINED, f);\n  };\n\n  Agent.prototype.onAfterCallWork = function (f) {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(connect.AgentEvents.ACW, f);\n  };\n\n  Agent.prototype.onStateChange = function (f) {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(connect.AgentEvents.STATE_CHANGE, f);\n  };\n\n  Agent.prototype.onMuteToggle = function (f) {\n    connect.core.getUpstream().onUpstream(connect.AgentEvents.MUTE_TOGGLE, f);\n  };\n\n  Agent.prototype.onLocalMediaStreamCreated = function (f) {\n    connect.core.getUpstream().onUpstream(connect.AgentEvents.LOCAL_MEDIA_STREAM_CREATED, f);\n  };\n\n  Agent.prototype.onSpeakerDeviceChanged = function (f) {\n    connect.core.getUpstream().onUpstream(connect.ConfigurationEvents.SPEAKER_DEVICE_CHANGED, f);\n  };\n\n  Agent.prototype.onMicrophoneDeviceChanged = function (f) {\n    connect.core.getUpstream().onUpstream(connect.ConfigurationEvents.MICROPHONE_DEVICE_CHANGED, f);\n  };\n\n  Agent.prototype.onRingerDeviceChanged = function (f) {\n    connect.core.getUpstream().onUpstream(connect.ConfigurationEvents.RINGER_DEVICE_CHANGED, f);\n  };\n\n  Agent.prototype.mute = function () {\n    connect.core.getUpstream().sendUpstream(connect.EventType.BROADCAST, {\n      event: connect.EventType.MUTE,\n      data: {\n        mute: true\n      }\n    });\n  };\n\n  Agent.prototype.unmute = function () {\n    connect.core.getUpstream().sendUpstream(connect.EventType.BROADCAST, {\n      event: connect.EventType.MUTE,\n      data: {\n        mute: false\n      }\n    });\n  };\n\n  Agent.prototype.setSpeakerDevice = function (deviceId) {\n    connect.core.getUpstream().sendUpstream(connect.EventType.BROADCAST, {\n      event: connect.ConfigurationEvents.SET_SPEAKER_DEVICE,\n      data: {\n        deviceId: deviceId\n      }\n    });\n  };\n\n  Agent.prototype.setMicrophoneDevice = function (deviceId) {\n    connect.core.getUpstream().sendUpstream(connect.EventType.BROADCAST, {\n      event: connect.ConfigurationEvents.SET_MICROPHONE_DEVICE,\n      data: {\n        deviceId: deviceId\n      }\n    });\n  };\n\n  Agent.prototype.setRingerDevice = function (deviceId) {\n    connect.core.getUpstream().sendUpstream(connect.EventType.BROADCAST, {\n      event: connect.ConfigurationEvents.SET_RINGER_DEVICE,\n      data: {\n        deviceId: deviceId\n      }\n    });\n  };\n\n  Agent.prototype.getState = function () {\n    return this._getData().snapshot.state;\n  };\n\n  Agent.prototype.getNextState = function () {\n    return this._getData().snapshot.nextState;\n  };\n\n  Agent.prototype.getAvailabilityState = function () {\n    return this._getData().snapshot.agentAvailabilityState;\n  };\n\n  Agent.prototype.getStatus = Agent.prototype.getState;\n\n  Agent.prototype.getStateDuration = function () {\n    return connect.now() - this._getData().snapshot.state.startTimestamp.getTime() + connect.core.getSkew();\n  };\n\n  Agent.prototype.getStatusDuration = Agent.prototype.getStateDuration;\n\n  Agent.prototype.getPermissions = function () {\n    return this.getConfiguration().permissions;\n  };\n\n  Agent.prototype.getContacts = function (contactTypeFilter) {\n    var self = this;\n    return this._getData().snapshot.contacts.map(function (contactData) {\n      return self._createContactAPI(contactData);\n    }).filter(function (contact) {\n      return !contactTypeFilter || contact.getType() === contactTypeFilter;\n    });\n  };\n\n  Agent.prototype.getConfiguration = function () {\n    return this._getData().configuration;\n  };\n\n  Agent.prototype.getAgentStates = function () {\n    return this.getConfiguration().agentStates;\n  };\n\n  Agent.prototype.getRoutingProfile = function () {\n    return this.getConfiguration().routingProfile;\n  };\n\n  Agent.prototype.getChannelConcurrency = function (channel) {\n    var channelConcurrencyMap = this.getRoutingProfile().channelConcurrencyMap;\n\n    if (!channelConcurrencyMap) {\n      channelConcurrencyMap = Object.keys(connect.ChannelType).reduce(function (acc, key) {\n        // Exclude TASK from default concurrency.\n        if (key !== 'TASK') {\n          acc[connect.ChannelType[key]] = 1;\n        }\n\n        return acc;\n      }, {});\n    }\n\n    return channel ? channelConcurrencyMap[channel] || 0 : channelConcurrencyMap;\n  };\n\n  Agent.prototype.getName = function () {\n    return this.getConfiguration().name;\n  };\n\n  Agent.prototype.getExtension = function () {\n    return this.getConfiguration().extension;\n  };\n\n  Agent.prototype.getDialableCountries = function () {\n    return this.getConfiguration().dialableCountries;\n  };\n\n  Agent.prototype.isSoftphoneEnabled = function () {\n    return this.getConfiguration().softphoneEnabled;\n  };\n\n  Agent.prototype.setConfiguration = function (configuration, callbacks) {\n    var client = connect.core.getClient();\n\n    if (configuration && configuration.agentPreferences && !connect.isValidLocale(configuration.agentPreferences.locale)) {\n      if (callbacks && callbacks.failure) {\n        callbacks.failure(connect.AgentErrorStates.INVALID_LOCALE);\n      }\n    } else {\n      client.call(connect.ClientMethods.UPDATE_AGENT_CONFIGURATION, {\n        configuration: connect.assertNotNull(configuration, 'configuration')\n      }, {\n        success: function (data) {\n          // We need to ask the shared worker to reload agent config\n          // once we change it so every tab has accurate config.\n          var conduit = connect.core.getUpstream();\n          conduit.sendUpstream(connect.EventType.RELOAD_AGENT_CONFIGURATION);\n\n          if (callbacks.success) {\n            callbacks.success(data);\n          }\n        },\n        failure: callbacks && callbacks.failure\n      });\n    }\n  };\n\n  Agent.prototype.setState = function (state, callbacks, options) {\n    var client = connect.core.getClient();\n    client.call(connect.ClientMethods.PUT_AGENT_STATE, {\n      state: connect.assertNotNull(state, 'state'),\n      enqueueNextState: options && !!options.enqueueNextState\n    }, callbacks);\n  };\n\n  Agent.prototype.onEnqueuedNextState = function (f) {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(connect.AgentEvents.ENQUEUED_NEXT_STATE, f);\n  };\n\n  Agent.prototype.setStatus = Agent.prototype.setState;\n\n  Agent.prototype.connect = function (endpointIn, params) {\n    var client = connect.core.getClient();\n    var endpoint = new connect.Endpoint(endpointIn); // Have to remove the endpointId field or AWS JS SDK gets mad.\n\n    delete endpoint.endpointId;\n    client.call(connect.ClientMethods.CREATE_OUTBOUND_CONTACT, {\n      endpoint: connect.assertNotNull(endpoint, 'endpoint'),\n      queueARN: params && (params.queueARN || params.queueId) || this.getRoutingProfile().defaultOutboundQueue.queueARN\n    }, params && {\n      success: params.success,\n      failure: params.failure\n    });\n  };\n\n  Agent.prototype.getAllQueueARNs = function () {\n    return this.getConfiguration().routingProfile.queues.map(function (queue) {\n      return queue.queueARN;\n    });\n  };\n\n  Agent.prototype.getEndpoints = function (queueARNs, callbacks, pageInfoIn) {\n    var self = this;\n    var client = connect.core.getClient();\n    connect.assertNotNull(callbacks, \"callbacks\");\n    connect.assertNotNull(callbacks.success, \"callbacks.success\");\n    var pageInfo = pageInfoIn || {};\n    pageInfo.endpoints = pageInfo.endpoints || [];\n    pageInfo.maxResults = pageInfo.maxResults || connect.DEFAULT_BATCH_SIZE; // Backwards compatibility allowing a single queueARN to be specified\n    // instead of an array.\n\n    if (!connect.isArray(queueARNs)) {\n      queueARNs = [queueARNs];\n    }\n\n    client.call(connect.ClientMethods.GET_ENDPOINTS, {\n      queueARNs: queueARNs,\n      nextToken: pageInfo.nextToken || null,\n      maxResults: pageInfo.maxResults\n    }, {\n      success: function (data) {\n        if (data.nextToken) {\n          self.getEndpoints(queueARNs, callbacks, {\n            nextToken: data.nextToken,\n            maxResults: pageInfo.maxResults,\n            endpoints: pageInfo.endpoints.concat(data.endpoints)\n          });\n        } else {\n          pageInfo.endpoints = pageInfo.endpoints.concat(data.endpoints);\n          var endpoints = pageInfo.endpoints.map(function (endpoint) {\n            return new connect.Endpoint(endpoint);\n          });\n          callbacks.success({\n            endpoints: endpoints,\n            addresses: endpoints\n          });\n        }\n      },\n      failure: callbacks.failure\n    });\n  };\n\n  Agent.prototype.getAddresses = Agent.prototype.getEndpoints; //Internal identifier.\n\n  Agent.prototype._getResourceId = function () {\n    queueArns = this.getAllQueueARNs();\n\n    for (let queueArn of queueArns) {\n      const agentIdMatch = queueArn.match(/\\/agent\\/([^/]+)/);\n\n      if (agentIdMatch) {\n        return agentIdMatch[1];\n      }\n    }\n\n    return new Error(\"Agent.prototype._getResourceId: queueArns did not contain agentResourceId: \", queueArns);\n  };\n\n  Agent.prototype.toSnapshot = function () {\n    return new connect.AgentSnapshot(this._getData());\n  };\n  /*----------------------------------------------------------------\n   * class AgentSnapshot\n   */\n\n\n  var AgentSnapshot = function (agentData) {\n    connect.Agent.call(this);\n    this.agentData = agentData;\n  };\n\n  AgentSnapshot.prototype = Object.create(Agent.prototype);\n  AgentSnapshot.prototype.constructor = AgentSnapshot;\n\n  AgentSnapshot.prototype._getData = function () {\n    return this.agentData;\n  };\n\n  AgentSnapshot.prototype._createContactAPI = function (contactData) {\n    return new connect.ContactSnapshot(contactData);\n  };\n  /*----------------------------------------------------------------\n   * class Contact\n   */\n\n\n  var Contact = function (contactId) {\n    this.contactId = contactId;\n  };\n\n  Contact.prototype._getData = function () {\n    return connect.core.getAgentDataProvider().getContactData(this.getContactId());\n  };\n\n  Contact.prototype._createConnectionAPI = function (connectionData) {\n    if (this.getType() === connect.ContactType.CHAT) {\n      return new connect.ChatConnection(this.contactId, connectionData.connectionId);\n    } else if (this.getType() === connect.ContactType.TASK) {\n      return new connect.TaskConnection(this.contactId, connectionData.connectionId);\n    } else {\n      return new connect.VoiceConnection(this.contactId, connectionData.connectionId);\n    }\n  };\n\n  Contact.prototype.getEventName = function (eventName) {\n    return connect.core.getContactEventName(eventName, this.getContactId());\n  };\n\n  Contact.prototype.onRefresh = function (f) {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(this.getEventName(connect.ContactEvents.REFRESH), f);\n  };\n\n  Contact.prototype.onIncoming = function (f) {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(this.getEventName(connect.ContactEvents.INCOMING), f);\n  };\n\n  Contact.prototype.onConnecting = function (f) {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(this.getEventName(connect.ContactEvents.CONNECTING), f);\n  };\n\n  Contact.prototype.onPending = function (f) {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(this.getEventName(connect.ContactEvents.PENDING), f);\n  };\n\n  Contact.prototype.onAccepted = function (f) {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(this.getEventName(connect.ContactEvents.ACCEPTED), f);\n  };\n\n  Contact.prototype.onMissed = function (f) {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(this.getEventName(connect.ContactEvents.MISSED), f);\n  };\n\n  Contact.prototype.onEnded = function (f) {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(this.getEventName(connect.ContactEvents.ENDED), f);\n    bus.subscribe(this.getEventName(connect.ContactEvents.DESTROYED), f);\n  };\n\n  Contact.prototype.onDestroy = function (f) {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(this.getEventName(connect.ContactEvents.DESTROYED), f);\n  };\n\n  Contact.prototype.onACW = function (f) {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(this.getEventName(connect.ContactEvents.ACW), f);\n  };\n\n  Contact.prototype.onConnected = function (f) {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(this.getEventName(connect.ContactEvents.CONNECTED), f);\n  };\n\n  Contact.prototype.onError = function (f) {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(this.getEventName(connect.ContactEvents.ERROR), f);\n  };\n\n  Contact.prototype.getContactId = function () {\n    return this.contactId;\n  };\n\n  Contact.prototype.getOriginalContactId = function () {\n    return this._getData().initialContactId;\n  };\n\n  Contact.prototype.getInitialContactId = Contact.prototype.getOriginalContactId;\n\n  Contact.prototype.getType = function () {\n    return this._getData().type;\n  };\n\n  Contact.prototype.getContactDuration = function () {\n    return this._getData().contactDuration;\n  };\n\n  Contact.prototype.getState = function () {\n    return this._getData().state;\n  };\n\n  Contact.prototype.getStatus = Contact.prototype.getState;\n\n  Contact.prototype.getStateDuration = function () {\n    return connect.now() - this._getData().state.timestamp.getTime() + connect.core.getSkew();\n  };\n\n  Contact.prototype.getStatusDuration = Contact.prototype.getStateDuration;\n\n  Contact.prototype.getQueue = function () {\n    return this._getData().queue;\n  };\n\n  Contact.prototype.getQueueTimestamp = function () {\n    return this._getData().queueTimestamp;\n  };\n\n  Contact.prototype.getConnections = function () {\n    var self = this;\n    return this._getData().connections.map(function (connData) {\n      if (self.getType() === connect.ContactType.CHAT) {\n        return new connect.ChatConnection(self.contactId, connData.connectionId);\n      } else if (self.getType() === connect.ContactType.TASK) {\n        return new connect.TaskConnection(self.contactId, connData.connectionId);\n      } else {\n        return new connect.VoiceConnection(self.contactId, connData.connectionId);\n      }\n    });\n  };\n\n  Contact.prototype.getInitialConnection = function () {\n    return connect.find(this.getConnections(), function (conn) {\n      return conn.isInitialConnection();\n    }) || null;\n  };\n\n  Contact.prototype.getActiveInitialConnection = function () {\n    var initialConn = this.getInitialConnection();\n\n    if (initialConn != null && initialConn.isActive()) {\n      return initialConn;\n    } else {\n      return null;\n    }\n  };\n\n  Contact.prototype.getThirdPartyConnections = function () {\n    return this.getConnections().filter(function (conn) {\n      return !conn.isInitialConnection() && conn.getType() !== connect.ConnectionType.AGENT;\n    });\n  };\n\n  Contact.prototype.getSingleActiveThirdPartyConnection = function () {\n    return this.getThirdPartyConnections().filter(function (conn) {\n      return conn.isActive();\n    })[0] || null;\n  };\n\n  Contact.prototype.getAgentConnection = function () {\n    return connect.find(this.getConnections(), function (conn) {\n      var connType = conn.getType();\n      return connType === connect.ConnectionType.AGENT || connType === connect.ConnectionType.MONITORING;\n    });\n  };\n\n  Contact.prototype.getName = function () {\n    return this._getData().name;\n  };\n\n  Contact.prototype.getContactMetadata = function () {\n    return this._getData().contactMetadata;\n  };\n\n  Contact.prototype.getDescription = function () {\n    return this._getData().description;\n  };\n\n  Contact.prototype.getReferences = function () {\n    return this._getData().references;\n  };\n\n  Contact.prototype.getAttributes = function () {\n    return this._getData().attributes;\n  };\n\n  Contact.prototype.getContactFeatures = function () {\n    return this._getData().contactFeatures;\n  };\n\n  Contact.prototype.isSoftphoneCall = function () {\n    return connect.find(this.getConnections(), function (conn) {\n      return conn.getSoftphoneMediaInfo() != null;\n    }) != null;\n  };\n\n  Contact.prototype._isInbound = function () {\n    var initiationMethod = this._getData().initiationMethod;\n\n    return initiationMethod === connect.ContactInitiationMethod.OUTBOUND ? false : true;\n  };\n\n  Contact.prototype.isInbound = function () {\n    var conn = this.getInitialConnection(); // We will gradually change checking inbound by relying on contact initiationMethod\n\n    if (conn.getMediaType() === connect.MediaType.TASK) {\n      return this._isInbound();\n    }\n\n    return conn ? conn.getType() === connect.ConnectionType.INBOUND : false;\n  };\n\n  Contact.prototype.isConnected = function () {\n    return this.getStatus().type === connect.ContactStateType.CONNECTED;\n  };\n\n  Contact.prototype.accept = function (callbacks) {\n    var client = connect.core.getClient();\n    var self = this;\n    var contactId = this.getContactId();\n    client.call(connect.ClientMethods.ACCEPT_CONTACT, {\n      contactId: contactId\n    }, {\n      success: function (data) {\n        var conduit = connect.core.getUpstream();\n        conduit.sendUpstream(connect.EventType.BROADCAST, {\n          event: connect.ContactEvents.ACCEPTED,\n          data: new connect.Contact(contactId)\n        });\n        conduit.sendUpstream(connect.EventType.BROADCAST, {\n          event: connect.core.getContactEventName(connect.ContactEvents.ACCEPTED, self.getContactId()),\n          data: new connect.Contact(contactId)\n        }); // In Firefox, there's a browser restriction that an unfocused browser tab is not allowed to access the user's microphone.\n        // The problem is that the restriction could cause a webrtc session creation timeout error when you get an incoming call while you are not on the primary tab.\n        // It was hard to workaround the issue especially when you have multiple tabs open because you needed to find the right tab and accept the contact before the timeout.\n        // To avoid the error, when multiple tabs are open in Firefox, a webrtc session is not immediately created as an incoming softphone contact is detected.\n        // Instead, it waits until contact.accept() is called on a tab and lets the tab become the new primary tab and start the web rtc session there\n        // because the tab should be focused at the moment and have access to the user's microphone.\n\n        var contact = new connect.Contact(contactId);\n\n        if (connect.isFirefoxBrowser() && contact.isSoftphoneCall()) {\n          connect.core.triggerReadyToStartSessionEvent();\n        }\n\n        if (callbacks && callbacks.success) {\n          callbacks.success(data);\n        }\n      },\n      failure: callbacks ? callbacks.failure : null\n    });\n  };\n\n  Contact.prototype.destroy = function () {\n    connect.getLog().warn(\"contact.destroy() has been deprecated.\");\n  };\n\n  Contact.prototype.reject = function (callbacks) {\n    var client = connect.core.getClient();\n    client.call(connect.ClientMethods.REJECT_CONTACT, {\n      contactId: this.getContactId()\n    }, callbacks);\n  };\n\n  Contact.prototype.complete = function (callbacks) {\n    var client = connect.core.getClient();\n    client.call(connect.ClientMethods.COMPLETE_CONTACT, {\n      contactId: this.getContactId()\n    }, callbacks);\n  };\n\n  Contact.prototype.clear = function (callbacks) {\n    var client = connect.core.getClient();\n    client.call(connect.ClientMethods.CLEAR_CONTACT, {\n      contactId: this.getContactId()\n    }, callbacks);\n  };\n\n  Contact.prototype.notifyIssue = function (issueCode, description, callbacks) {\n    var client = connect.core.getClient();\n    client.call(connect.ClientMethods.NOTIFY_CONTACT_ISSUE, {\n      contactId: this.getContactId(),\n      issueCode: issueCode,\n      description: description\n    }, callbacks);\n  };\n\n  Contact.prototype.addConnection = function (endpointIn, callbacks) {\n    var client = connect.core.getClient();\n    var endpoint = new connect.Endpoint(endpointIn); // Have to remove the endpointId field or AWS JS SDK gets mad.\n\n    delete endpoint.endpointId;\n    client.call(connect.ClientMethods.CREATE_ADDITIONAL_CONNECTION, {\n      contactId: this.getContactId(),\n      endpoint: endpoint\n    }, callbacks);\n  };\n\n  Contact.prototype.toggleActiveConnections = function (callbacks) {\n    var client = connect.core.getClient();\n    var connectionId = null;\n    var holdingConn = connect.find(this.getConnections(), function (conn) {\n      return conn.getStatus().type === connect.ConnectionStateType.HOLD;\n    });\n\n    if (holdingConn != null) {\n      connectionId = holdingConn.getConnectionId();\n    } else {\n      var activeConns = this.getConnections().filter(function (conn) {\n        return conn.isActive();\n      });\n\n      if (activeConns.length > 0) {\n        connectionId = activeConns[0].getConnectionId();\n      }\n    }\n\n    client.call(connect.ClientMethods.TOGGLE_ACTIVE_CONNECTIONS, {\n      contactId: this.getContactId(),\n      connectionId: connectionId\n    }, callbacks);\n  };\n\n  Contact.prototype.sendSoftphoneMetrics = function (softphoneStreamStatistics, callbacks) {\n    var client = connect.core.getClient();\n    client.call(connect.ClientMethods.SEND_SOFTPHONE_CALL_METRICS, {\n      contactId: this.getContactId(),\n      ccpVersion: global.ccpVersion,\n      softphoneStreamStatistics: softphoneStreamStatistics\n    }, callbacks);\n    connect.publishSoftphoneStats({\n      contactId: this.getContactId(),\n      ccpVersion: global.ccpVersion,\n      stats: softphoneStreamStatistics\n    });\n  };\n\n  Contact.prototype.sendSoftphoneReport = function (report, callbacks) {\n    var client = connect.core.getClient();\n    client.call(connect.ClientMethods.SEND_SOFTPHONE_CALL_REPORT, {\n      contactId: this.getContactId(),\n      ccpVersion: global.ccpVersion,\n      report: report\n    }, callbacks);\n    connect.publishSoftphoneReport({\n      contactId: this.getContactId(),\n      ccpVersion: global.ccpVersion,\n      report: report\n    });\n  };\n\n  Contact.prototype.conferenceConnections = function (callbacks) {\n    var client = connect.core.getClient();\n    client.call(connect.ClientMethods.CONFERENCE_CONNECTIONS, {\n      contactId: this.getContactId()\n    }, callbacks);\n  };\n\n  Contact.prototype.toSnapshot = function () {\n    return new connect.ContactSnapshot(this._getData());\n  };\n  /*----------------------------------------------------------------\n   * class ContactSnapshot\n   */\n\n\n  var ContactSnapshot = function (contactData) {\n    connect.Contact.call(this, contactData.contactId);\n    this.contactData = contactData;\n  };\n\n  ContactSnapshot.prototype = Object.create(Contact.prototype);\n  ContactSnapshot.prototype.constructor = ContactSnapshot;\n\n  ContactSnapshot.prototype._getData = function () {\n    return this.contactData;\n  };\n\n  ContactSnapshot.prototype._createConnectionAPI = function (connectionData) {\n    return new connect.ConnectionSnapshot(connectionData);\n  };\n  /*----------------------------------------------------------------\n   * class Connection\n   */\n\n\n  var Connection = function (contactId, connectionId) {\n    this.contactId = contactId;\n    this.connectionId = connectionId;\n\n    this._initMediaController();\n  };\n\n  Connection.prototype._getData = function () {\n    return connect.core.getAgentDataProvider().getConnectionData(this.getContactId(), this.getConnectionId());\n  };\n\n  Connection.prototype.getContactId = function () {\n    return this.contactId;\n  };\n\n  Connection.prototype.getConnectionId = function () {\n    return this.connectionId;\n  };\n\n  Connection.prototype.getEndpoint = function () {\n    return new connect.Endpoint(this._getData().endpoint);\n  };\n\n  Connection.prototype.getAddress = Connection.prototype.getEndpoint;\n\n  Connection.prototype.getState = function () {\n    return this._getData().state;\n  };\n\n  Connection.prototype.getStatus = Connection.prototype.getState;\n\n  Connection.prototype.getStateDuration = function () {\n    return connect.now() - this._getData().state.timestamp.getTime() + connect.core.getSkew();\n  };\n\n  Connection.prototype.getStatusDuration = Connection.prototype.getStateDuration;\n\n  Connection.prototype.getType = function () {\n    return this._getData().type;\n  };\n\n  Connection.prototype.isInitialConnection = function () {\n    return this._getData().initial;\n  };\n\n  Connection.prototype.isActive = function () {\n    return connect.contains(connect.CONNECTION_ACTIVE_STATES, this.getStatus().type);\n  };\n\n  Connection.prototype.isConnected = function () {\n    return this.getStatus().type === connect.ConnectionStateType.CONNECTED;\n  };\n\n  Connection.prototype.isConnecting = function () {\n    return this.getStatus().type === connect.ConnectionStateType.CONNECTING;\n  };\n\n  Connection.prototype.isOnHold = function () {\n    return this.getStatus().type === connect.ConnectionStateType.HOLD;\n  };\n\n  Connection.prototype.getSoftphoneMediaInfo = function () {\n    return this._getData().softphoneMediaInfo;\n  };\n  /**\n   * Gets the currently monitored contact info, Returns null if does not exists.\n   * @return {{agentName:string, customerName:string, joinTime:Date}}\n   */\n\n\n  Connection.prototype.getMonitorInfo = function () {\n    return this._getData().monitoringInfo;\n  };\n\n  Connection.prototype.destroy = function (callbacks) {\n    var client = connect.core.getClient();\n    client.call(connect.ClientMethods.DESTROY_CONNECTION, {\n      contactId: this.getContactId(),\n      connectionId: this.getConnectionId()\n    }, callbacks);\n  };\n\n  Connection.prototype.sendDigits = function (digits, callbacks) {\n    var client = connect.core.getClient();\n    client.call(connect.ClientMethods.SEND_DIGITS, {\n      contactId: this.getContactId(),\n      connectionId: this.getConnectionId(),\n      digits: digits\n    }, callbacks);\n  };\n\n  Connection.prototype.hold = function (callbacks) {\n    var client = connect.core.getClient();\n    client.call(connect.ClientMethods.HOLD_CONNECTION, {\n      contactId: this.getContactId(),\n      connectionId: this.getConnectionId()\n    }, callbacks);\n  };\n\n  Connection.prototype.resume = function (callbacks) {\n    var client = connect.core.getClient();\n    client.call(connect.ClientMethods.RESUME_CONNECTION, {\n      contactId: this.getContactId(),\n      connectionId: this.getConnectionId()\n    }, callbacks);\n  };\n\n  Connection.prototype.toSnapshot = function () {\n    return new connect.ConnectionSnapshot(this._getData());\n  };\n\n  Connection.prototype._initMediaController = function () {\n    if (this.getMediaInfo()) {\n      connect.core.mediaFactory.get(this).catch(function () {});\n    }\n  }; // Method for checking whether this connection is an agent-side connection \n  // (type AGENT or MONITORING)\n\n\n  Connection.prototype._isAgentConnectionType = function () {\n    var connectionType = this.getType();\n    return connectionType === connect.ConnectionType.AGENT || connectionType === connect.ConnectionType.MONITORING;\n  };\n  /**\n   * Utility method for checking whether this connection is an agent-side connection \n   * (type AGENT or MONITORING)\n   * @return {boolean} True if this connection is an agent-side connection. False otherwise.\n   */\n\n\n  Connection.prototype._isAgentConnectionType = function () {\n    var connectionType = this.getType();\n    return connectionType === connect.ConnectionType.AGENT || connectionType === connect.ConnectionType.MONITORING;\n  };\n  /*----------------------------------------------------------------\n  * Voice authenticator VoiceId\n  */\n\n\n  var VoiceId = function (contactId) {\n    this.contactId = contactId;\n  };\n\n  VoiceId.prototype.getSpeakerId = function () {\n    var self = this;\n    self.checkConferenceCall();\n    var client = connect.core.getClient();\n    return new Promise(function (resolve, reject) {\n      client.call(connect.AgentAppClientMethods.GET_CONTACT, {\n        \"contactId\": self.contactId,\n        \"instanceId\": connect.core.getAgentDataProvider().getInstanceId(),\n        \"awsAccountId\": connect.core.getAgentDataProvider().getAWSAccountId()\n      }, {\n        success: function (data) {\n          if (data.contactData.customerId) {\n            var obj = {\n              speakerId: data.contactData.customerId\n            };\n            connect.getLog().info(\"getSpeakerId succeeded\").withObject(data).sendInternalLogToServer();\n            resolve(obj);\n          } else {\n            var error = connect.VoiceIdError(connect.VoiceIdErrorTypes.NO_SPEAKER_ID_FOUND, \"No speakerId assotiated with this call\");\n            reject(error);\n          }\n        },\n        failure: function (err) {\n          connect.getLog().error(\"Get SpeakerId failed\").withObject({\n            err: err\n          }).sendInternalLogToServer();\n          var error = connect.VoiceIdError(connect.VoiceIdErrorTypes.GET_SPEAKER_ID_FAILED, \"Get SpeakerId failed\", err);\n          reject(error);\n        }\n      });\n    });\n  };\n\n  VoiceId.prototype.getSpeakerStatus = function () {\n    var self = this;\n    self.checkConferenceCall();\n    var client = connect.core.getClient();\n    return new Promise(function (resolve, reject) {\n      self.getSpeakerId().then(function (data) {\n        self.getDomainId().then(function (domainId) {\n          client.call(connect.AgentAppClientMethods.DESCRIBE_SPEAKER, {\n            \"SpeakerId\": connect.assertNotNull(data.speakerId, 'speakerId'),\n            \"DomainId\": domainId\n          }, {\n            success: function (data) {\n              connect.getLog().info(\"getSpeakerStatus succeeded\").withObject(data).sendInternalLogToServer();\n              resolve(data);\n            },\n            failure: function (err) {\n              var error;\n              var parsedErr = JSON.parse(err);\n\n              switch (parsedErr.status) {\n                case 400:\n                case 404:\n                  var data = parsedErr;\n                  data.type = data.type ? data.type : connect.VoiceIdErrorTypes.SPEAKER_ID_NOT_ENROLLED;\n                  connect.getLog().info(\"Speaker is not enrolled.\").sendInternalLogToServer();\n                  resolve(data);\n                  break;\n\n                default:\n                  connect.getLog().error(\"getSpeakerStatus failed\").withObject({\n                    err: err\n                  }).sendInternalLogToServer();\n                  var error = connect.VoiceIdError(connect.VoiceIdErrorTypes.GET_SPEAKER_STATUS_FAILED, \"Get SpeakerStatus failed\", err);\n                  reject(error);\n              }\n            }\n          });\n        }).catch(function (err) {\n          reject(err);\n        });\n      }).catch(function (err) {\n        reject(err);\n      });\n    });\n  }; // internal only\n\n\n  VoiceId.prototype._optOutSpeakerInLcms = function (speakerId) {\n    var self = this;\n    var client = connect.core.getClient();\n    return new Promise(function (resolve, reject) {\n      client.call(connect.AgentAppClientMethods.UPDATE_VOICE_ID_DATA, {\n        \"ContactId\": self.contactId,\n        \"InstanceId\": connect.core.getAgentDataProvider().getInstanceId(),\n        \"AWSAccountId\": connect.core.getAgentDataProvider().getAWSAccountId(),\n        \"CustomerId\": connect.assertNotNull(speakerId, 'speakerId'),\n        \"VoiceIdResult\": {\n          \"SpeakerOptedOut\": true\n        }\n      }, {\n        success: function (data) {\n          connect.getLog().info(\"optOutSpeakerInLcms succeeded\").withObject(data).sendInternalLogToServer();\n          resolve(data);\n        },\n        failure: function (err) {\n          connect.getLog().error(\"optOutSpeakerInLcms failed\").withObject({\n            err: err\n          }).sendInternalLogToServer();\n          var error = connect.VoiceIdError(connect.VoiceIdErrorTypes.OPT_OUT_SPEAKER_IN_LCMS_FAILED, \"optOutSpeakerInLcms failed\", err);\n          reject(error);\n        }\n      });\n    });\n  };\n\n  VoiceId.prototype.optOutSpeaker = function () {\n    var self = this;\n    self.checkConferenceCall();\n    var client = connect.core.getClient();\n    return new Promise(function (resolve, reject) {\n      self.getSpeakerId().then(function (data) {\n        self.getDomainId().then(function (domainId) {\n          var speakerId = data.speakerId;\n          client.call(connect.AgentAppClientMethods.OPT_OUT_SPEAKER, {\n            \"SpeakerId\": connect.assertNotNull(speakerId, 'speakerId'),\n            \"DomainId\": domainId\n          }, {\n            success: function (data) {\n              self._optOutSpeakerInLcms(speakerId).catch(function () {});\n\n              connect.getLog().info(\"optOutSpeaker succeeded\").withObject(data).sendInternalLogToServer();\n              resolve(data);\n            },\n            failure: function (err) {\n              connect.getLog().error(\"optOutSpeaker failed\").withObject({\n                err: err\n              }).sendInternalLogToServer();\n              var error = connect.VoiceIdError(connect.VoiceIdErrorTypes.OPT_OUT_SPEAKER_FAILED, \"optOutSpeaker failed.\", err);\n              reject(error);\n            }\n          });\n        }).catch(function (err) {\n          reject(err);\n        });\n      }).catch(function (err) {\n        reject(err);\n      });\n    });\n  };\n\n  VoiceId.prototype.deleteSpeaker = function () {\n    var self = this;\n    self.checkConferenceCall();\n    var client = connect.core.getClient();\n    return new Promise(function (resolve, reject) {\n      self.getSpeakerId().then(function (data) {\n        self.getDomainId().then(function (domainId) {\n          client.call(connect.AgentAppClientMethods.DELETE_SPEAKER, {\n            \"SpeakerId\": connect.assertNotNull(data.speakerId, 'speakerId'),\n            \"DomainId\": domainId\n          }, {\n            success: function (data) {\n              connect.getLog().info(\"deleteSpeaker succeeded\").withObject(data).sendInternalLogToServer();\n              resolve(data);\n            },\n            failure: function (err) {\n              connect.getLog().error(\"deleteSpeaker failed\").withObject({\n                err: err\n              }).sendInternalLogToServer();\n              var error = connect.VoiceIdError(connect.VoiceIdErrorTypes.DELETE_SPEAKER_FAILED, \"deleteSpeaker failed.\", err);\n              reject(error);\n            }\n          });\n        }).catch(function (err) {\n          reject(err);\n        });\n      }).catch(function (err) {\n        reject(err);\n      });\n    });\n  };\n\n  VoiceId.prototype.startSession = function () {\n    var self = this;\n    self.checkConferenceCall();\n    var client = connect.core.getClient();\n    return new Promise(function (resolve, reject) {\n      self.getDomainId().then(function (domainId) {\n        client.call(connect.AgentAppClientMethods.START_VOICE_ID_SESSION, {\n          \"contactId\": self.contactId,\n          \"instanceId\": connect.core.getAgentDataProvider().getInstanceId(),\n          \"customerAccountId\": connect.core.getAgentDataProvider().getAWSAccountId(),\n          \"clientToken\": AWS.util.uuid.v4(),\n          \"domainId\": domainId\n        }, {\n          success: function (data) {\n            if (data.sessionId) {\n              resolve(data);\n            } else {\n              connect.getLog().error(\"startVoiceIdSession failed, no session id returned\").withObject({\n                data: data\n              }).sendInternalLogToServer();\n              var error = connect.VoiceIdError(connect.VoiceIdErrorTypes.START_SESSION_FAILED, \"No session id returned from start session api\");\n              reject(error);\n            }\n          },\n          failure: function (err) {\n            connect.getLog().error(\"startVoiceIdSession failed\").withObject({\n              err: err\n            }).sendInternalLogToServer();\n            var error = connect.VoiceIdError(connect.VoiceIdErrorTypes.START_SESSION_FAILED, \"startVoiceIdSession failed\", err);\n            reject(error);\n          }\n        });\n      }).catch(function (err) {\n        reject(err);\n      });\n    });\n  };\n\n  VoiceId.prototype.evaluateSpeaker = function (startNew) {\n    var self = this;\n    self.checkConferenceCall();\n    var client = connect.core.getClient();\n    var contactData = connect.core.getAgentDataProvider().getContactData(this.contactId);\n    var pollTimes = 0;\n    return new Promise(function (resolve, reject) {\n      function evaluate() {\n        self.getDomainId().then(function (domainId) {\n          client.call(connect.AgentAppClientMethods.EVALUATE_SESSION, {\n            \"SessionNameOrId\": contactData.initialContactId || this.contactId,\n            \"DomainId\": domainId\n          }, {\n            success: function (data) {\n              if (++pollTimes < connect.VoiceIdConstants.EVALUATION_MAX_POLL_TIMES) {\n                if (data.StreamingStatus === connect.VoiceIdStreamingStatus.PENDING_CONFIGURATION) {\n                  setTimeout(evaluate, connect.VoiceIdConstants.EVALUATION_POLLING_INTERVAL);\n                } else {\n                  if (!data.AuthenticationResult) {\n                    data.AuthenticationResult = {};\n                    data.AuthenticationResult.Decision = connect.ContactFlowAuthenticationDecision.NOT_ENABLED;\n                  }\n\n                  if (!data.FraudDetectionResult) {\n                    data.FraudDetectionResult = {};\n                    data.FraudDetectionResult.Decision = connect.ContactFlowFraudDetectionDecision.NOT_ENABLED;\n                  } // Resolve if both authentication and fraud detection are not enabled.\n\n\n                  if (!self.isAuthEnabled(data.AuthenticationResult.Decision) && !self.isFraudEnabled(data.FraudDetectionResult.Decision)) {\n                    connect.getLog().info(\"evaluateSpeaker succeeded\").withObject(data).sendInternalLogToServer();\n                    resolve(data);\n                    return;\n                  }\n\n                  if (data.StreamingStatus === connect.VoiceIdStreamingStatus.ENDED) {\n                    if (self.isAuthResultNotEnoughSpeech(data.AuthenticationResult.Decision)) {\n                      data.AuthenticationResult.Decision = connect.ContactFlowAuthenticationDecision.INCONCLUSIVE;\n                    }\n\n                    if (self.isFraudResultNotEnoughSpeech(data.FraudDetectionResult.Decision)) {\n                      data.FraudDetectionResult.Decision = connect.ContactFlowFraudDetectionDecision.INCONCLUSIVE;\n                    }\n                  } // Voice print is not long enough for both authentication and fraud detection\n\n\n                  if (self.isAuthResultInconclusive(data.AuthenticationResult.Decision) && self.isFraudResultInconclusive(data.FraudDetectionResult.Decision)) {\n                    connect.getLog().info(\"evaluateSpeaker succeeded\").withObject(data).sendInternalLogToServer();\n                    resolve(data);\n                    return;\n                  }\n\n                  if (!self.isAuthResultNotEnoughSpeech(data.AuthenticationResult.Decision) && self.isAuthEnabled(data.AuthenticationResult.Decision)) {\n                    switch (data.AuthenticationResult.Decision) {\n                      case connect.VoiceIdAuthenticationDecision.ACCEPT:\n                        data.AuthenticationResult.Decision = connect.ContactFlowAuthenticationDecision.AUTHENTICATED;\n                        break;\n\n                      case connect.VoiceIdAuthenticationDecision.REJECT:\n                        data.AuthenticationResult.Decision = connect.ContactFlowAuthenticationDecision.NOT_AUTHENTICATED;\n                        break;\n\n                      case connect.VoiceIdAuthenticationDecision.SPEAKER_OPTED_OUT:\n                        data.AuthenticationResult.Decision = connect.ContactFlowAuthenticationDecision.OPTED_OUT;\n                        break;\n\n                      case connect.VoiceIdAuthenticationDecision.SPEAKER_NOT_ENROLLED:\n                        data.AuthenticationResult.Decision = connect.ContactFlowAuthenticationDecision.NOT_ENROLLED;\n                        break;\n\n                      default:\n                        data.AuthenticationResult.Decision = connect.ContactFlowAuthenticationDecision.ERROR;\n                    }\n                  }\n\n                  if (!self.isFraudResultNotEnoughSpeech(data.FraudDetectionResult.Decision) && self.isFraudEnabled(data.FraudDetectionResult.Decision)) {\n                    switch (data.FraudDetectionResult.Decision) {\n                      case connect.VoiceIdFraudDetectionDecision.HIGH_RISK:\n                        data.FraudDetectionResult.Decision = connect.ContactFlowFraudDetectionDecision.HIGH_RISK;\n                        break;\n\n                      case connect.VoiceIdFraudDetectionDecision.LOW_RISK:\n                        data.FraudDetectionResult.Decision = connect.ContactFlowFraudDetectionDecision.LOW_RISK;\n                        break;\n\n                      default:\n                        data.FraudDetectionResult.Decision = connect.ContactFlowFraudDetectionDecision.ERROR;\n                    }\n                  }\n\n                  if (!self.isAuthResultNotEnoughSpeech(data.AuthenticationResult.Decision) && !self.isFraudResultNotEnoughSpeech(data.FraudDetectionResult.Decision)) {\n                    // Resolve only when both authentication and fraud detection have results. Otherwise, keep polling.\n                    connect.getLog().info(\"evaluateSpeaker succeeded\").withObject(data).sendInternalLogToServer();\n                    resolve(data);\n                    return;\n                  } else {\n                    setTimeout(evaluate, connect.VoiceIdConstants.EVALUATION_POLLING_INTERVAL);\n                  }\n                }\n              } else {\n                connect.getLog().error(\"evaluateSpeaker timeout\").sendInternalLogToServer();\n                var error = connect.VoiceIdError(connect.VoiceIdErrorTypes.EVALUATE_SPEAKER_TIMEOUT, \"evaluateSpeaker timeout\");\n                reject(error);\n              }\n            },\n            failure: function (err) {\n              var error;\n              var parsedErr = JSON.parse(err);\n\n              switch (parsedErr.status) {\n                case 400:\n                case 404:\n                  error = connect.VoiceIdError(connect.VoiceIdErrorTypes.SESSION_NOT_EXISTS, \"evaluateSpeaker failed, session not exists\", err);\n                  connect.getLog().error(\"evaluateSpeaker failed, session not exists\").withObject({\n                    err: err\n                  }).sendInternalLogToServer();\n                  break;\n\n                default:\n                  error = connect.VoiceIdError(connect.VoiceIdErrorTypes.EVALUATE_SPEAKER_FAILED, \"evaluateSpeaker failed\", err);\n                  connect.getLog().error(\"evaluateSpeaker failed\").withObject({\n                    err: err\n                  }).sendInternalLogToServer();\n              }\n\n              reject(error);\n            }\n          });\n        }).catch(function (err) {\n          reject(err);\n        });\n      }\n\n      if (!startNew) {\n        self.syncSpeakerId().then(function () {\n          evaluate();\n        }).catch(function (err) {\n          connect.getLog().error(\"syncSpeakerId failed when session startNew=false\").withObject({\n            err: err\n          }).sendInternalLogToServer();\n          reject(err);\n        });\n      } else {\n        self.startSession().then(function (data) {\n          self.syncSpeakerId().then(function (data) {\n            setTimeout(evaluate, connect.VoiceIdConstants.EVALUATE_SESSION_DELAY);\n          }).catch(function (err) {\n            connect.getLog().error(\"syncSpeakerId failed when session startNew=true\").withObject({\n              err: err\n            }).sendInternalLogToServer();\n            reject(err);\n          });\n        }).catch(function (err) {\n          connect.getLog().error(\"startSession failed when session startNew=true\").withObject({\n            err: err\n          }).sendInternalLogToServer();\n          reject(err);\n        });\n      }\n    });\n  };\n\n  VoiceId.prototype.describeSession = function () {\n    var self = this;\n    var client = connect.core.getClient();\n    var contactData = connect.core.getAgentDataProvider().getContactData(this.contactId);\n    return new Promise(function (resolve, reject) {\n      self.getDomainId().then(function (domainId) {\n        client.call(connect.AgentAppClientMethods.DESCRIBE_SESSION, {\n          \"SessionNameOrId\": contactData.initialContactId || this.contactId,\n          \"DomainId\": domainId\n        }, {\n          success: function (data) {\n            resolve(data);\n          },\n          failure: function (err) {\n            connect.getLog().error(\"describeSession failed\").withObject({\n              err: err\n            }).sendInternalLogToServer();\n            var error = connect.VoiceIdError(connect.VoiceIdErrorTypes.DESCRIBE_SESSION_FAILED, \"describeSession failed\", err);\n            reject(error);\n          }\n        });\n      }).catch(function (err) {\n        reject(err);\n      });\n    });\n  };\n\n  VoiceId.prototype.checkEnrollmentStatus = function () {\n    var self = this;\n    var pollingTimes = 0;\n    return new Promise(function (resolve, reject) {\n      function describe() {\n        if (++pollingTimes < connect.VoiceIdConstants.ENROLLMENT_MAX_POLL_TIMES) {\n          self.describeSession().then(function (data) {\n            switch (data.Session.EnrollmentRequestDetails.Status) {\n              case connect.VoiceIdEnrollmentRequestStatus.COMPLETED:\n                resolve(data);\n                break;\n\n              case connect.VoiceIdEnrollmentRequestStatus.IN_PROGRESS:\n                setTimeout(describe, connect.VoiceIdConstants.ENROLLMENT_POLLING_INTERVAL);\n                break;\n\n              case connect.VoiceIdEnrollmentRequestStatus.NOT_ENOUGH_SPEECH:\n                if (data.Session.StreamingStatus !== connect.VoiceIdStreamingStatus.ENDED) {\n                  setTimeout(describe, connect.VoiceIdConstants.ENROLLMENT_POLLING_INTERVAL);\n                } else {\n                  setTimeout(function () {\n                    self.startSession().then(function (data) {\n                      describe();\n                    }).catch(function (err, data) {\n                      reject(err);\n                    });\n                  }, connect.VoiceIdConstants.START_SESSION_DELAY);\n                }\n\n                break;\n\n              default:\n                var message = data.Session.EnrollmentRequestDetails.Message ? data.Session.EnrollmentRequestDetails.Message : \"enrollSpeaker failed. Unknown enrollment status has been received\";\n                connect.getLog().error(message).sendInternalLogToServer();\n                var error = connect.VoiceIdError(connect.VoiceIdErrorTypes.ENROLL_SPEAKER_FAILED, message, data.Session.EnrollmentRequestDetails.Status);\n                reject(error);\n            }\n          });\n        } else {\n          connect.getLog().error(\"enrollSpeaker timeout\").sendInternalLogToServer();\n          var error = connect.VoiceIdError(connect.VoiceIdErrorTypes.ENROLL_SPEAKER_TIMEOUT, \"enrollSpeaker timeout\");\n          reject(error);\n        }\n      }\n\n      describe();\n    });\n  };\n\n  VoiceId.prototype.enrollSpeaker = function () {\n    var self = this;\n    self.checkConferenceCall();\n    return new Promise(function (resolve, reject) {\n      self.syncSpeakerId().then(function () {\n        self.getSpeakerStatus().then(function (data) {\n          if (data.Speaker && data.Speaker.Status == connect.VoiceIdSpeakerStatus.OPTED_OUT) {\n            self.deleteSpeaker().then(function () {\n              self.enrollSpeakerHelper(resolve, reject);\n            }).catch(function (err) {\n              reject(err);\n            });\n          } else {\n            self.enrollSpeakerHelper(resolve, reject);\n          }\n        }).catch(function (err) {\n          reject(err);\n        });\n      }).catch(function (err) {\n        reject(err);\n      });\n    });\n  };\n\n  VoiceId.prototype.enrollSpeakerHelper = function (resolve, reject) {\n    var self = this;\n    var client = connect.core.getClient();\n    var contactData = connect.core.getAgentDataProvider().getContactData(this.contactId);\n    self.getDomainId().then(function (domainId) {\n      client.call(connect.AgentAppClientMethods.ENROLL_BY_SESSION, {\n        \"SessionNameOrId\": contactData.initialContactId || this.contactId,\n        \"DomainId\": domainId\n      }, {\n        success: function (data) {\n          if (data.Status === connect.VoiceIdEnrollmentRequestStatus.COMPLETED) {\n            connect.getLog().info(\"enrollSpeaker succeeded\").withObject(data).sendInternalLogToServer();\n            resolve(data);\n          } else {\n            self.checkEnrollmentStatus().then(function (data) {\n              connect.getLog().info(\"enrollSpeaker succeeded\").withObject(data).sendInternalLogToServer();\n              resolve(data);\n            }).catch(function (err) {\n              reject(err);\n            });\n          }\n        },\n        failure: function (err) {\n          connect.getLog().error(\"enrollSpeaker failed\").withObject({\n            err: err\n          }).sendInternalLogToServer();\n          var error = connect.VoiceIdError(connect.VoiceIdErrorTypes.ENROLL_SPEAKER_FAILED, \"enrollSpeaker failed\", err);\n          reject(error);\n        }\n      });\n    }).catch(function (err) {\n      reject(err);\n    });\n  }; // internal only\n\n\n  VoiceId.prototype._updateSpeakerIdInLcms = function (speakerId) {\n    var self = this;\n    var client = connect.core.getClient();\n    return new Promise(function (resolve, reject) {\n      client.call(connect.AgentAppClientMethods.UPDATE_VOICE_ID_DATA, {\n        \"ContactId\": self.contactId,\n        \"InstanceId\": connect.core.getAgentDataProvider().getInstanceId(),\n        \"AWSAccountId\": connect.core.getAgentDataProvider().getAWSAccountId(),\n        \"CustomerId\": connect.assertNotNull(speakerId, 'speakerId'),\n        \"VoiceIdResult\": {\n          \"generatedSpeakerId\": speakerId\n        }\n      }, {\n        success: function (data) {\n          connect.getLog().info(\"updateSpeakerIdInLcms succeeded\").withObject(data).sendInternalLogToServer();\n          resolve(data);\n        },\n        failure: function (err) {\n          connect.getLog().error(\"updateSpeakerIdInLcms failed\").withObject({\n            err: err\n          }).sendInternalLogToServer();\n          var error = connect.VoiceIdError(connect.VoiceIdErrorTypes.UPDATE_SPEAKER_ID_IN_LCMS_FAILED, \"updateSpeakerIdInLcms failed\", err);\n          reject(error);\n        }\n      });\n    });\n  };\n\n  VoiceId.prototype.updateSpeakerIdInVoiceId = function (speakerId) {\n    var self = this;\n    self.checkConferenceCall();\n    var client = connect.core.getClient();\n    var contactData = connect.core.getAgentDataProvider().getContactData(this.contactId);\n    return new Promise(function (resolve, reject) {\n      self.getDomainId().then(function (domainId) {\n        client.call(connect.AgentAppClientMethods.UPDATE_SESSION, {\n          \"SessionNameOrId\": contactData.initialContactId || this.contactId,\n          \"SpeakerId\": connect.assertNotNull(speakerId, 'speakerId'),\n          \"DomainId\": domainId\n        }, {\n          success: function (data) {\n            connect.getLog().info(\"updateSpeakerIdInVoiceId succeeded\").withObject(data).sendInternalLogToServer();\n\n            self._updateSpeakerIdInLcms(speakerId).then(function () {\n              resolve(data);\n            }).catch(function (err) {\n              reject(err);\n            });\n          },\n          failure: function (err) {\n            var error;\n            var parsedErr = JSON.parse(err);\n\n            switch (parsedErr.status) {\n              case 400:\n              case 404:\n                error = connect.VoiceIdError(connect.VoiceIdErrorTypes.SESSION_NOT_EXISTS, \"updateSpeakerIdInVoiceId failed, session not exists\", err);\n                connect.getLog().error(\"updateSpeakerIdInVoiceId failed, session not exists\").withObject({\n                  err: err\n                }).sendInternalLogToServer();\n                break;\n\n              default:\n                error = connect.VoiceIdError(connect.VoiceIdErrorTypes.UPDATE_SPEAKER_ID_FAILED, \"updateSpeakerIdInVoiceId failed\", err);\n                connect.getLog().error(\"updateSpeakerIdInVoiceId failed\").withObject({\n                  err: err\n                }).sendInternalLogToServer();\n            }\n\n            reject(error);\n          }\n        });\n      }).catch(function (err) {\n        reject(err);\n      });\n    });\n  };\n\n  VoiceId.prototype.syncSpeakerId = function () {\n    var self = this;\n    return new Promise(function (resolve, reject) {\n      self.getSpeakerId().then(function (data) {\n        self.updateSpeakerIdInVoiceId(data.speakerId).then(function (data) {\n          resolve(data);\n        }).catch(function (err) {\n          reject(err);\n        });\n      }).catch(function (err) {\n        reject(err);\n      });\n    });\n  };\n\n  VoiceId.prototype.getDomainId = function () {\n    return new Promise(function (resolve, reject) {\n      const agent = new connect.Agent();\n\n      if (!agent.getPermissions().includes(connect.AgentPermissions.VOICE_ID)) {\n        reject(new Error(\"Agent doesn't have the permission for Voice ID\"));\n      } else if (connect.core.voiceIdDomainId) {\n        resolve(connect.core.voiceIdDomainId);\n      } else {\n        var client = connect.core.getClient();\n        client.call(connect.AgentAppClientMethods.LIST_INTEGRATION_ASSOCIATIONS, {\n          \"InstanceId\": connect.core.getAgentDataProvider().getInstanceId(),\n          \"IntegrationType\": \"VOICE_ID\"\n        }, {\n          success: function (data) {\n            try {\n              var domainId;\n\n              if (data.IntegrationAssociationSummaryList.length >= 1) {\n                var integrationArn = data.IntegrationAssociationSummaryList[0].IntegrationArn;\n                domainId = integrationArn.replace(/^.*domain\\//i, '');\n              }\n\n              if (!domainId) {\n                connect.getLog().info(\"getDomainId: no domainId found\").sendInternalLogToServer();\n                var error = connect.VoiceIdError(connect.VoiceIdErrorTypes.NO_DOMAIN_ID_FOUND);\n                reject(error);\n                return;\n              }\n\n              connect.getLog().info(\"getDomainId succeeded\").withObject(data).sendInternalLogToServer();\n              connect.core.getUpstream().sendUpstream(connect.EventType.BROADCAST, {\n                event: connect.VoiceIdEvents.UPDATE_DOMAIN_ID,\n                data: {\n                  domainId: domainId\n                }\n              });\n              resolve(domainId);\n            } catch (err) {\n              connect.getLog().error(\"getDomainId failed\").withObject({\n                err: err\n              }).sendInternalLogToServer();\n              var error = connect.VoiceIdError(connect.VoiceIdErrorTypes.GET_DOMAIN_ID_FAILED, \"getDomainId failed\", err);\n              reject(error);\n            }\n          },\n          failure: function (err) {\n            connect.getLog().error(\"getDomainId failed\").withObject({\n              err: err\n            }).sendInternalLogToServer();\n            var error = connect.VoiceIdError(connect.VoiceIdErrorTypes.GET_DOMAIN_ID_FAILED, \"getDomainId failed\", err);\n            reject(error);\n          }\n        });\n      }\n    });\n  };\n\n  VoiceId.prototype.checkConferenceCall = function () {\n    var self = this;\n    var isConferenceCall = connect.core.getAgentDataProvider().getContactData(self.contactId).connections.filter(function (conn) {\n      return connect.contains(connect.CONNECTION_ACTIVE_STATES, conn.state.type);\n    }).length > 2;\n\n    if (isConferenceCall) {\n      throw new connect.NotImplementedError(\"VoiceId is not supported for conference calls\");\n    }\n  };\n\n  VoiceId.prototype.isAuthEnabled = function (authResult) {\n    return authResult !== connect.ContactFlowAuthenticationDecision.NOT_ENABLED;\n  };\n\n  VoiceId.prototype.isAuthResultNotEnoughSpeech = function (authResult) {\n    return authResult === connect.VoiceIdAuthenticationDecision.NOT_ENOUGH_SPEECH;\n  };\n\n  VoiceId.prototype.isAuthResultInconclusive = function (authResult) {\n    return authResult === connect.ContactFlowAuthenticationDecision.INCONCLUSIVE;\n  };\n\n  VoiceId.prototype.isFraudEnabled = function (fraudResult) {\n    return fraudResult !== connect.ContactFlowFraudDetectionDecision.NOT_ENABLED;\n  };\n\n  VoiceId.prototype.isFraudResultNotEnoughSpeech = function (fraudResult) {\n    return fraudResult === connect.VoiceIdFraudDetectionDecision.NOT_ENOUGH_SPEECH;\n  };\n\n  VoiceId.prototype.isFraudResultInconclusive = function (fraudResult) {\n    return fraudResult === connect.ContactFlowFraudDetectionDecision.INCONCLUSIVE;\n  };\n  /**\n   * @class VoiceConnection\n   * @param {number} contactId \n   * @param {number} connectionId \n   * @description - Provides voice media specific operations\n   */\n\n\n  var VoiceConnection = function (contactId, connectionId) {\n    this._speakerAuthenticator = new VoiceId(contactId);\n    Connection.call(this, contactId, connectionId);\n  };\n\n  VoiceConnection.prototype = Object.create(Connection.prototype);\n  VoiceConnection.prototype.constructor = VoiceConnection;\n  /**\n  * @deprecated\n  * Please use getMediaInfo \n  */\n\n  VoiceConnection.prototype.getSoftphoneMediaInfo = function () {\n    return this._getData().softphoneMediaInfo;\n  };\n\n  VoiceConnection.prototype.getMediaInfo = function () {\n    return this._getData().softphoneMediaInfo;\n  };\n\n  VoiceConnection.prototype.getMediaType = function () {\n    return connect.MediaType.SOFTPHONE;\n  };\n\n  VoiceConnection.prototype.getMediaController = function () {\n    return connect.core.mediaFactory.get(this);\n  };\n\n  VoiceConnection.prototype.getVoiceIdSpeakerId = function () {\n    return this._speakerAuthenticator.getSpeakerId();\n  };\n\n  VoiceConnection.prototype.getVoiceIdSpeakerStatus = function () {\n    return this._speakerAuthenticator.getSpeakerStatus();\n  };\n\n  VoiceConnection.prototype.optOutVoiceIdSpeaker = function () {\n    return this._speakerAuthenticator.optOutSpeaker();\n  };\n\n  VoiceConnection.prototype.deleteVoiceIdSpeaker = function () {\n    return this._speakerAuthenticator.deleteSpeaker();\n  };\n\n  VoiceConnection.prototype.evaluateSpeakerWithVoiceId = function (startNew) {\n    return this._speakerAuthenticator.evaluateSpeaker(startNew);\n  };\n\n  VoiceConnection.prototype.enrollSpeakerInVoiceId = function () {\n    return this._speakerAuthenticator.enrollSpeaker();\n  };\n\n  VoiceConnection.prototype.updateVoiceIdSpeakerId = function (speakerId) {\n    return this._speakerAuthenticator.updateSpeakerIdInVoiceId(speakerId);\n  };\n  /**\n   * @class ChatConnection\n   * @param {*} contactId \n   * @param {*} connectionId \n   * @description adds the chat media specific functionality\n   */\n\n\n  var ChatConnection = function (contactId, connectionId) {\n    Connection.call(this, contactId, connectionId);\n  };\n\n  ChatConnection.prototype = Object.create(Connection.prototype);\n  ChatConnection.prototype.constructor = ChatConnection;\n\n  ChatConnection.prototype.getMediaInfo = function () {\n    var data = this._getData().chatMediaInfo;\n\n    if (!data) {\n      return null;\n    } else {\n      var contactData = connect.core.getAgentDataProvider().getContactData(this.contactId);\n      var mediaObject = {\n        contactId: this.contactId,\n        initialContactId: contactData.initialContactId || this.contactId,\n        participantId: this.connectionId,\n        getConnectionToken: connect.hitch(this, this.getConnectionToken)\n      };\n\n      if (data.connectionData) {\n        try {\n          mediaObject.participantToken = JSON.parse(data.connectionData).ConnectionAuthenticationToken;\n        } catch (e) {\n          connect.getLog().error(connect.LogComponent.CHAT, \"Connection data is invalid\").withObject(data).withException(e).sendInternalLogToServer();\n          mediaObject.participantToken = null;\n        }\n      }\n\n      mediaObject.participantToken = mediaObject.participantToken || null;\n      /** Just to keep the data accessible */\n\n      mediaObject.originalInfo = this._getData().chatMediaInfo;\n      return mediaObject;\n    }\n  };\n  /**\n  * Provides the chat connectionToken through the create_transport API for a specific contact and participant Id. \n  * @returns a promise which, upon success, returns the response from the createTransport API.\n  * Usage:\n  * connection.getConnectionToken()\n  *  .then(response => {})\n  *  .catch(error => {})\n  */\n\n\n  ChatConnection.prototype.getConnectionToken = function () {\n    client = connect.core.getClient();\n    var contactData = connect.core.getAgentDataProvider().getContactData(this.contactId);\n    var transportDetails = {\n      transportType: connect.TRANSPORT_TYPES.CHAT_TOKEN,\n      participantId: this.connectionId,\n      contactId: contactData.initialContactId || this.contactId\n    };\n    return new Promise(function (resolve, reject) {\n      client.call(connect.ClientMethods.CREATE_TRANSPORT, transportDetails, {\n        success: function (data) {\n          connect.getLog().info(\"getConnectionToken succeeded\").sendInternalLogToServer();\n          resolve(data);\n        },\n        failure: function (err, data) {\n          connect.getLog().error(\"getConnectionToken failed\").sendInternalLogToServer().withObject({\n            err: err,\n            data: data\n          });\n          reject(Error(\"getConnectionToken failed\"));\n        }\n      });\n    });\n  };\n\n  ChatConnection.prototype.getMediaType = function () {\n    return connect.MediaType.CHAT;\n  };\n\n  ChatConnection.prototype.getMediaController = function () {\n    return connect.core.mediaFactory.get(this);\n  };\n\n  ChatConnection.prototype._initMediaController = function () {\n    // Note that a chat media controller only needs to be produced for agent type connections.\n    if (this._isAgentConnectionType()) {\n      connect.core.mediaFactory.get(this).catch(function () {});\n    }\n  };\n  /**\n   * @class TaskConnection\n   * @param {*} contactId \n   * @param {*} connectionId \n   * @description adds the task media specific functionality\n   */\n\n\n  var TaskConnection = function (contactId, connectionId) {\n    Connection.call(this, contactId, connectionId);\n  };\n\n  TaskConnection.prototype = Object.create(Connection.prototype);\n  TaskConnection.prototype.constructor = TaskConnection;\n\n  TaskConnection.prototype.getMediaType = function () {\n    return connect.MediaType.TASK;\n  };\n\n  TaskConnection.prototype.getMediaInfo = function () {\n    var contactData = connect.core.getAgentDataProvider().getContactData(this.contactId);\n    var mediaObject = {\n      contactId: this.contactId,\n      initialContactId: contactData.initialContactId || this.contactId\n    };\n    return mediaObject;\n  };\n\n  TaskConnection.prototype.getMediaController = function () {\n    return connect.core.mediaFactory.get(this);\n  };\n  /*----------------------------------------------------------------\n   * class ConnectionSnapshot\n   */\n\n\n  var ConnectionSnapshot = function (connectionData) {\n    connect.Connection.call(this, connectionData.contactId, connectionData.connectionId);\n    this.connectionData = connectionData;\n  };\n\n  ConnectionSnapshot.prototype = Object.create(Connection.prototype);\n  ConnectionSnapshot.prototype.constructor = ConnectionSnapshot;\n\n  ConnectionSnapshot.prototype._getData = function () {\n    return this.connectionData;\n  };\n\n  ConnectionSnapshot.prototype._initMediaController = function () {};\n\n  var Endpoint = function (paramsIn) {\n    var params = paramsIn || {};\n    this.endpointARN = params.endpointId || params.endpointARN || null;\n    this.endpointId = this.endpointARN;\n    this.type = params.type || null;\n    this.name = params.name || null;\n    this.phoneNumber = params.phoneNumber || null;\n    this.agentLogin = params.agentLogin || null;\n    this.queue = params.queue || null;\n  };\n  /**\n   * Strip the SIP endpoint components from the phoneNumber field.\n   */\n\n\n  Endpoint.prototype.stripPhoneNumber = function () {\n    return this.phoneNumber ? this.phoneNumber.replace(/sip:([^@]*)@.*/, \"$1\") : \"\";\n  };\n  /**\n   * Create an Endpoint object from the given phone number and name.\n   */\n\n\n  Endpoint.byPhoneNumber = function (number, name) {\n    return new Endpoint({\n      type: connect.EndpointType.PHONE_NUMBER,\n      phoneNumber: number,\n      name: name || null\n    });\n  };\n  /*----------------------------------------------------------------\n   * class SoftphoneError\n   */\n\n\n  var SoftphoneError = function (errorType, errorMessage, endPointUrl) {\n    this.errorType = errorType;\n    this.errorMessage = errorMessage;\n    this.endPointUrl = endPointUrl;\n  };\n\n  SoftphoneError.prototype.getErrorType = function () {\n    return this.errorType;\n  };\n\n  SoftphoneError.prototype.getErrorMessage = function () {\n    return this.errorMessage;\n  };\n\n  SoftphoneError.prototype.getEndPointUrl = function () {\n    return this.endPointUrl;\n  };\n  /*----------------------------------------------------------------\n   * Root Subscription APIs.\n   */\n\n\n  connect.agent = function (f) {\n    var bus = connect.core.getEventBus();\n    var sub = bus.subscribe(connect.AgentEvents.INIT, f);\n\n    if (connect.agent.initialized) {\n      f(new connect.Agent());\n    }\n\n    return sub;\n  };\n\n  connect.agent.initialized = false;\n\n  connect.contact = function (f) {\n    var bus = connect.core.getEventBus();\n    return bus.subscribe(connect.ContactEvents.INIT, f);\n  };\n\n  connect.onWebsocketInitFailure = function (f) {\n    var bus = connect.core.getEventBus();\n    var sub = bus.subscribe(connect.WebSocketEvents.INIT_FAILURE, f);\n\n    if (connect.webSocketInitFailed) {\n      f();\n    }\n\n    return sub;\n  };\n  /**\n   * Starts the given function asynchronously only if the shared worker\n   * says we are the master for the given topic.  If there is no master for\n   * the given topic, we become the master and start the function unless\n   * shouldNotBecomeMasterIfNone is true.\n   *\n   * @param topic The master topic we are concerned about.\n   * @param f_true The callback to be invoked if we are the master.\n   * @param f_else [optional] A callback to be invoked if we are not the master.\n   * @param shouldNotBecomeMasterIfNone [optional] if true, this tab won't become master.\n   */\n\n\n  connect.ifMaster = function (topic, f_true, f_else, shouldNotBecomeMasterIfNone) {\n    connect.assertNotNull(topic, \"A topic must be provided.\");\n    connect.assertNotNull(f_true, \"A true callback must be provided.\");\n\n    if (!connect.core.masterClient) {\n      // We can't be the master because there is no master client!\n      connect.getLog().warn(\"We can't be the master for topic '%s' because there is no master client!\", topic).sendInternalLogToServer();\n\n      if (f_else) {\n        f_else();\n      }\n\n      return;\n    }\n\n    var masterClient = connect.core.getMasterClient();\n    masterClient.call(connect.MasterMethods.CHECK_MASTER, {\n      topic: topic,\n      shouldNotBecomeMasterIfNone: shouldNotBecomeMasterIfNone\n    }, {\n      success: function (data) {\n        if (data.isMaster) {\n          f_true();\n        } else if (f_else) {\n          f_else();\n        }\n      }\n    });\n  };\n  /**\n   * Notify the shared worker and other CCP tabs that we are now the master for the given topic.\n   */\n\n\n  connect.becomeMaster = function (topic, successCallback, failureCallback) {\n    connect.assertNotNull(topic, \"A topic must be provided.\");\n\n    if (!connect.core.masterClient) {\n      // We can't be the master because there is no master client!\n      connect.getLog().warn(\"We can't be the master for topic '%s' because there is no master client!\", topic);\n\n      if (failureCallback) {\n        failureCallback();\n      }\n    } else {\n      var masterClient = connect.core.getMasterClient();\n      masterClient.call(connect.MasterMethods.BECOME_MASTER, {\n        topic: topic\n      }, {\n        success: function () {\n          if (successCallback) {\n            successCallback();\n          }\n        }\n      });\n    }\n  };\n\n  connect.Agent = Agent;\n  connect.AgentSnapshot = AgentSnapshot;\n  connect.Contact = Contact;\n  connect.ContactSnapshot = ContactSnapshot;\n  /** Default will get the Voice connection */\n\n  connect.Connection = VoiceConnection;\n  connect.BaseConnection = Connection;\n  connect.VoiceConnection = VoiceConnection;\n  connect.ChatConnection = ChatConnection;\n  connect.TaskConnection = TaskConnection;\n  connect.ConnectionSnapshot = ConnectionSnapshot;\n  connect.Endpoint = Endpoint;\n  connect.Address = Endpoint;\n  connect.SoftphoneError = SoftphoneError;\n  connect.VoiceId = VoiceId;\n})();\n\n!function (e) {\n  var n = {};\n\n  function t(o) {\n    if (n[o]) return n[o].exports;\n    var r = n[o] = {\n      i: o,\n      l: !1,\n      exports: {}\n    };\n    return e[o].call(r.exports, r, r.exports, t), r.l = !0, r.exports;\n  }\n\n  t.m = e, t.c = n, t.d = function (e, n, o) {\n    t.o(e, n) || Object.defineProperty(e, n, {\n      enumerable: !0,\n      get: o\n    });\n  }, t.r = function (e) {\n    \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n      value: \"Module\"\n    }), Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n  }, t.t = function (e, n) {\n    if (1 & n && (e = t(e)), 8 & n) return e;\n    if (4 & n && \"object\" == typeof e && e && e.__esModule) return e;\n    var o = Object.create(null);\n    if (t.r(o), Object.defineProperty(o, \"default\", {\n      enumerable: !0,\n      value: e\n    }), 2 & n && \"string\" != typeof e) for (var r in e) t.d(o, r, function (n) {\n      return e[n];\n    }.bind(null, r));\n    return o;\n  }, t.n = function (e) {\n    var n = e && e.__esModule ? function () {\n      return e.default;\n    } : function () {\n      return e;\n    };\n    return t.d(n, \"a\", n), n;\n  }, t.o = function (e, n) {\n    return Object.prototype.hasOwnProperty.call(e, n);\n  }, t.p = \"\", t(t.s = 2);\n}([function (e, n, t) {\n  \"use strict\";\n\n  var o = t(1),\n      r = \"NULL\",\n      i = \"CLIENT_LOGGER\",\n      c = \"DEBUG\",\n      s = 2e3,\n      a = \"aws/subscribe\",\n      u = \"aws/unsubscribe\",\n      l = \"aws/heartbeat\",\n      f = \"connected\",\n      p = \"disconnected\";\n\n  function d(e) {\n    return (d = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n      return typeof e;\n    } : function (e) {\n      return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n    })(e);\n  }\n\n  var b = {\n    assertTrue: function (e, n) {\n      if (!e) throw new Error(n);\n    },\n    assertNotNull: function (e, n) {\n      return b.assertTrue(null !== e && void 0 !== d(e), Object(o.sprintf)(\"%s must be provided\", n || \"A value\")), e;\n    },\n    isNonEmptyString: function (e) {\n      return \"string\" == typeof e && e.length > 0;\n    },\n    assertIsList: function (e, n) {\n      if (!Array.isArray(e)) throw new Error(n + \" is not an array\");\n    },\n    isFunction: function (e) {\n      return !!(e && e.constructor && e.call && e.apply);\n    },\n    isObject: function (e) {\n      return !(\"object\" !== d(e) || null === e);\n    },\n    isString: function (e) {\n      return \"string\" == typeof e;\n    },\n    isNumber: function (e) {\n      return \"number\" == typeof e;\n    }\n  },\n      g = new RegExp(\"^(wss://)\\\\w*\");\n  b.validWSUrl = function (e) {\n    return g.test(e);\n  }, b.getSubscriptionResponse = function (e, n, t) {\n    return {\n      topic: e,\n      content: {\n        status: n ? \"success\" : \"failure\",\n        topics: t\n      }\n    };\n  }, b.assertIsObject = function (e, n) {\n    if (!b.isObject(e)) throw new Error(n + \" is not an object!\");\n  }, b.addJitter = function (e) {\n    var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\n    n = Math.min(n, 1);\n    var t = Math.random() > .5 ? 1 : -1;\n    return Math.floor(e + t * e * Math.random() * n);\n  }, b.isNetworkOnline = function () {\n    return navigator.onLine;\n  }, b.isNetworkFailure = function (e) {\n    return !(!e._debug || !e._debug.type) && \"NetworkingError\" === e._debug.type;\n  };\n  var y = b;\n\n  function m(e) {\n    return (m = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n      return typeof e;\n    } : function (e) {\n      return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n    })(e);\n  }\n\n  function S(e, n) {\n    return !n || \"object\" !== m(n) && \"function\" != typeof n ? function (e) {\n      if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return e;\n    }(e) : n;\n  }\n\n  function k(e) {\n    return (k = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n      return e.__proto__ || Object.getPrototypeOf(e);\n    })(e);\n  }\n\n  function h(e, n) {\n    return (h = Object.setPrototypeOf || function (e, n) {\n      return e.__proto__ = n, e;\n    })(e, n);\n  }\n\n  function v(e, n) {\n    if (!(e instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n\n  function w(e, n) {\n    for (var t = 0; t < n.length; t++) {\n      var o = n[t];\n      o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);\n    }\n  }\n\n  function C(e, n, t) {\n    return n && w(e.prototype, n), t && w(e, t), e;\n  }\n\n  var T = function () {\n    function e() {\n      v(this, e);\n    }\n\n    return C(e, [{\n      key: \"debug\",\n      value: function (e) {}\n    }, {\n      key: \"info\",\n      value: function (e) {}\n    }, {\n      key: \"warn\",\n      value: function (e) {}\n    }, {\n      key: \"error\",\n      value: function (e) {}\n    }]), e;\n  }(),\n      O = {\n    DEBUG: 10,\n    INFO: 20,\n    WARN: 30,\n    ERROR: 40\n  },\n      I = function () {\n    function e() {\n      v(this, e), this.updateLoggerConfig(), this.consoleLoggerWrapper = _();\n    }\n\n    return C(e, [{\n      key: \"writeToClientLogger\",\n      value: function (e, n) {\n        if (this.hasClientLogger()) switch (e) {\n          case O.DEBUG:\n            return this._clientLogger.debug(n);\n\n          case O.INFO:\n            return this._clientLogger.info(n);\n\n          case O.WARN:\n            return this._clientLogger.warn(n);\n\n          case O.ERROR:\n            return this._clientLogger.error(n);\n        }\n      }\n    }, {\n      key: \"isLevelEnabled\",\n      value: function (e) {\n        return e >= this._level;\n      }\n    }, {\n      key: \"hasClientLogger\",\n      value: function () {\n        return null !== this._clientLogger;\n      }\n    }, {\n      key: \"getLogger\",\n      value: function (e) {\n        var n = e.prefix || \"\";\n        return this._logsDestination === c ? this.consoleLoggerWrapper : new N(n);\n      }\n    }, {\n      key: \"updateLoggerConfig\",\n      value: function (e) {\n        var n = e || {};\n        this._level = n.level || O.DEBUG, this._clientLogger = n.logger || null, this._logsDestination = r, n.debug && (this._logsDestination = c), n.logger && (this._logsDestination = i);\n      }\n    }]), e;\n  }(),\n      W = function () {\n    function e() {\n      v(this, e);\n    }\n\n    return C(e, [{\n      key: \"debug\",\n      value: function () {}\n    }, {\n      key: \"info\",\n      value: function () {}\n    }, {\n      key: \"warn\",\n      value: function () {}\n    }, {\n      key: \"error\",\n      value: function () {}\n    }]), e;\n  }(),\n      N = function (e) {\n    function n(e) {\n      var t;\n      return v(this, n), (t = S(this, k(n).call(this))).prefix = e || \"\", t;\n    }\n\n    return function (e, n) {\n      if (\"function\" != typeof n && null !== n) throw new TypeError(\"Super expression must either be null or a function\");\n      e.prototype = Object.create(n && n.prototype, {\n        constructor: {\n          value: e,\n          writable: !0,\n          configurable: !0\n        }\n      }), n && h(e, n);\n    }(n, W), C(n, [{\n      key: \"debug\",\n      value: function () {\n        for (var e = arguments.length, n = new Array(e), t = 0; t < e; t++) n[t] = arguments[t];\n\n        return this._log(O.DEBUG, n);\n      }\n    }, {\n      key: \"info\",\n      value: function () {\n        for (var e = arguments.length, n = new Array(e), t = 0; t < e; t++) n[t] = arguments[t];\n\n        return this._log(O.INFO, n);\n      }\n    }, {\n      key: \"warn\",\n      value: function () {\n        for (var e = arguments.length, n = new Array(e), t = 0; t < e; t++) n[t] = arguments[t];\n\n        return this._log(O.WARN, n);\n      }\n    }, {\n      key: \"error\",\n      value: function () {\n        for (var e = arguments.length, n = new Array(e), t = 0; t < e; t++) n[t] = arguments[t];\n\n        return this._log(O.ERROR, n);\n      }\n    }, {\n      key: \"_shouldLog\",\n      value: function (e) {\n        return E.hasClientLogger() && E.isLevelEnabled(e);\n      }\n    }, {\n      key: \"_writeToClientLogger\",\n      value: function (e, n) {\n        return E.writeToClientLogger(e, n);\n      }\n    }, {\n      key: \"_log\",\n      value: function (e, n) {\n        if (this._shouldLog(e)) {\n          var t = this._convertToSingleStatement(n);\n\n          return this._writeToClientLogger(e, t);\n        }\n      }\n    }, {\n      key: \"_convertToSingleStatement\",\n      value: function (e) {\n        var n = \"\";\n        this.prefix && (n += this.prefix + \" \");\n\n        for (var t = 0; t < e.length; t++) {\n          var o = e[t];\n          n += this._convertToString(o) + \" \";\n        }\n\n        return n;\n      }\n    }, {\n      key: \"_convertToString\",\n      value: function (e) {\n        try {\n          if (!e) return \"\";\n          if (y.isString(e)) return e;\n\n          if (y.isObject(e) && y.isFunction(e.toString)) {\n            var n = e.toString();\n            if (\"[object Object]\" !== n) return n;\n          }\n\n          return JSON.stringify(e);\n        } catch (n) {\n          return console.error(\"Error while converting argument to string\", e, n), \"\";\n        }\n      }\n    }]), n;\n  }(),\n      _ = function () {\n    var e = new W();\n    return e.debug = console.debug, e.info = console.info, e.warn = console.warn, e.error = console.error, e;\n  },\n      E = new I();\n\n  function F(e, n) {\n    for (var t = 0; t < n.length; t++) {\n      var o = n[t];\n      o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);\n    }\n  }\n\n  var L = function () {\n    function e(n) {\n      var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : s;\n      !function (e, n) {\n        if (!(e instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, e), this.numAttempts = 0, this.executor = n, this.hasActiveReconnection = !1, this.defaultRetry = t;\n    }\n\n    var n, t, o;\n    return n = e, (t = [{\n      key: \"retry\",\n      value: function () {\n        var e = this;\n        this.hasActiveReconnection || (this.hasActiveReconnection = !0, setTimeout(function () {\n          e._execute();\n        }, this._getDelay()));\n      }\n    }, {\n      key: \"_execute\",\n      value: function () {\n        this.hasActiveReconnection = !1, this.executor(), this.numAttempts++;\n      }\n    }, {\n      key: \"connected\",\n      value: function () {\n        this.numAttempts = 0;\n      }\n    }, {\n      key: \"_getDelay\",\n      value: function () {\n        var e = Math.pow(2, this.numAttempts) * this.defaultRetry;\n        return e <= 3e4 ? e : 3e4;\n      }\n    }]) && F(n.prototype, t), o && F(n, o), e;\n  }();\n\n  t.d(n, \"a\", function () {\n    return R;\n  });\n\n  var x = function () {\n    var e = E.getLogger({}),\n        n = y.isNetworkOnline(),\n        t = {\n      primary: null,\n      secondary: null\n    },\n        o = {\n      reconnectWebSocket: !0,\n      websocketInitFailed: !1,\n      exponentialBackOffTime: 1e3,\n      exponentialTimeoutHandle: null,\n      lifeTimeTimeoutHandle: null,\n      webSocketInitCheckerTimeoutId: null,\n      connState: null\n    },\n        r = {\n      connectWebSocketRetryCount: 0,\n      connectionAttemptStartTime: null,\n      noOpenConnectionsTimestamp: null\n    },\n        i = {\n      pendingResponse: !1,\n      intervalHandle: null\n    },\n        c = {\n      initFailure: new Set(),\n      getWebSocketTransport: null,\n      subscriptionUpdate: new Set(),\n      subscriptionFailure: new Set(),\n      topic: new Map(),\n      allMessage: new Set(),\n      connectionGain: new Set(),\n      connectionLost: new Set(),\n      connectionOpen: new Set(),\n      connectionClose: new Set()\n    },\n        s = {\n      connConfig: null,\n      promiseHandle: null,\n      promiseCompleted: !0\n    },\n        d = {\n      subscribed: new Set(),\n      pending: new Set(),\n      subscriptionHistory: new Set()\n    },\n        b = {\n      responseCheckIntervalId: null,\n      requestCompleted: !0,\n      reSubscribeIntervalId: null,\n      consecutiveFailedSubscribeAttempts: 0,\n      consecutiveNoResponseRequest: 0\n    },\n        g = new L(function () {\n      U();\n    }),\n        m = new Set([a, u, l]),\n        S = setInterval(function () {\n      if (n !== y.isNetworkOnline()) {\n        if (!(n = y.isNetworkOnline())) return void J(e.info(\"Network offline\"));\n        var t = O();\n        n && (!t || w(t, WebSocket.CLOSING) || w(t, WebSocket.CLOSED)) && (J(e.info(\"Network online, connecting to WebSocket server\")), U());\n      }\n    }, 250),\n        k = function (n, t) {\n      n.forEach(function (n) {\n        try {\n          n(t);\n        } catch (n) {\n          J(e.error(\"Error executing callback\", n));\n        }\n      });\n    },\n        h = function (e) {\n      if (null === e) return \"NULL\";\n\n      switch (e.readyState) {\n        case WebSocket.CONNECTING:\n          return \"CONNECTING\";\n\n        case WebSocket.OPEN:\n          return \"OPEN\";\n\n        case WebSocket.CLOSING:\n          return \"CLOSING\";\n\n        case WebSocket.CLOSED:\n          return \"CLOSED\";\n\n        default:\n          return \"UNDEFINED\";\n      }\n    },\n        v = function () {\n      var n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : \"\";\n      J(e.debug(\"[\" + n + \"] Primary WebSocket: \" + h(t.primary) + \" | Secondary WebSocket: \" + h(t.secondary)));\n    },\n        w = function (e, n) {\n      return e && e.readyState === n;\n    },\n        C = function (e) {\n      return w(e, WebSocket.OPEN);\n    },\n        T = function (e) {\n      return null === e || void 0 === e.readyState || w(e, WebSocket.CLOSED);\n    },\n        O = function () {\n      return null !== t.secondary ? t.secondary : t.primary;\n    },\n        I = function () {\n      return C(O());\n    },\n        W = function () {\n      if (i.pendingResponse) return J(e.warn(\"Heartbeat response not received\")), clearInterval(i.intervalHandle), i.pendingResponse = !1, void U();\n      I() ? (J(e.debug(\"Sending heartbeat\")), O().send(G(l)), i.pendingResponse = !0) : (J(e.warn(\"Failed to send heartbeat since WebSocket is not open\")), v(\"sendHeartBeat\"), U());\n    },\n        N = function () {\n      o.exponentialBackOffTime = 1e3, i.pendingResponse = !1, o.reconnectWebSocket = !0, clearTimeout(o.lifeTimeTimeoutHandle), clearInterval(i.intervalHandle), clearTimeout(o.exponentialTimeoutHandle), clearTimeout(o.webSocketInitCheckerTimeoutId);\n    },\n        _ = function () {\n      b.consecutiveFailedSubscribeAttempts = 0, b.consecutiveNoResponseRequest = 0, clearInterval(b.responseCheckIntervalId), clearInterval(b.reSubscribeIntervalId);\n    },\n        F = function () {\n      r.connectWebSocketRetryCount = 0, r.connectionAttemptStartTime = null, r.noOpenConnectionsTimestamp = null;\n    },\n        x = function () {\n      try {\n        J(e.info(\"WebSocket connection established!\")), v(\"webSocketOnOpen\"), null !== o.connState && o.connState !== p || k(c.connectionGain), o.connState = f;\n        var n = Date.now();\n        k(c.connectionOpen, {\n          connectWebSocketRetryCount: r.connectWebSocketRetryCount,\n          connectionAttemptStartTime: r.connectionAttemptStartTime,\n          noOpenConnectionsTimestamp: r.noOpenConnectionsTimestamp,\n          connectionEstablishedTime: n,\n          timeToConnect: n - r.connectionAttemptStartTime,\n          timeWithoutConnection: r.noOpenConnectionsTimestamp ? n - r.noOpenConnectionsTimestamp : null\n        }), F(), N(), O().openTimestamp = Date.now(), 0 === d.subscribed.size && C(t.secondary) && D(t.primary, \"[Primary WebSocket] Closing WebSocket\"), (d.subscribed.size > 0 || d.pending.size > 0) && (C(t.secondary) && J(e.info(\"Subscribing secondary websocket to topics of primary websocket\")), d.subscribed.forEach(function (e) {\n          d.subscriptionHistory.add(e), d.pending.add(e);\n        }), d.subscribed.clear(), A()), W(), i.intervalHandle = setInterval(W, 1e4);\n        var a = 1e3 * s.connConfig.webSocketTransport.transportLifeTimeInSeconds;\n        J(e.debug(\"Scheduling WebSocket manager reconnection, after delay \" + a + \" ms\")), o.lifeTimeTimeoutHandle = setTimeout(function () {\n          J(e.debug(\"Starting scheduled WebSocket manager reconnection\")), U();\n        }, a);\n      } catch (n) {\n        J(e.error(\"Error after establishing WebSocket connection\", n));\n      }\n    },\n        R = function (n) {\n      v(\"webSocketOnError\"), J(e.error(\"WebSocketManager Error, error_event: \", JSON.stringify(n))), U();\n    },\n        j = function (n) {\n      var o = JSON.parse(n.data);\n\n      switch (o.topic) {\n        case a:\n          if (J(e.debug(\"Subscription Message received from webSocket server\", n.data)), b.requestCompleted = !0, b.consecutiveNoResponseRequest = 0, \"success\" === o.content.status) b.consecutiveFailedSubscribeAttempts = 0, o.content.topics.forEach(function (e) {\n            d.subscriptionHistory.delete(e), d.pending.delete(e), d.subscribed.add(e);\n          }), 0 === d.subscriptionHistory.size ? C(t.secondary) && (J(e.info(\"Successfully subscribed secondary websocket to all topics of primary websocket\")), D(t.primary, \"[Primary WebSocket] Closing WebSocket\")) : A(), k(c.subscriptionUpdate, o);else {\n            if (clearInterval(b.reSubscribeIntervalId), ++b.consecutiveFailedSubscribeAttempts, 5 === b.consecutiveFailedSubscribeAttempts) return k(c.subscriptionFailure, o), void (b.consecutiveFailedSubscribeAttempts = 0);\n            b.reSubscribeIntervalId = setInterval(function () {\n              A();\n            }, 500);\n          }\n          break;\n\n        case l:\n          J(e.debug(\"Heartbeat response received\")), i.pendingResponse = !1;\n          break;\n\n        default:\n          if (o.topic) {\n            if (J(e.debug(\"Message received for topic \" + o.topic)), C(t.primary) && C(t.secondary) && 0 === d.subscriptionHistory.size && this === t.primary) return void J(e.warn(\"Ignoring Message for Topic \" + o.topic + \", to avoid duplicates\"));\n            if (0 === c.allMessage.size && 0 === c.topic.size) return void J(e.warn(\"No registered callback listener for Topic\", o.topic));\n            k(c.allMessage, o), c.topic.has(o.topic) && k(c.topic.get(o.topic), o);\n          } else o.message ? J(e.warn(\"WebSocketManager Message Error\", o)) : J(e.warn(\"Invalid incoming message\", o));\n\n      }\n    },\n        A = function n() {\n      if (b.consecutiveNoResponseRequest > 3) return J(e.warn(\"Ignoring subscribePendingTopics since we have exhausted max subscription retries with no response\")), void k(c.subscriptionFailure, y.getSubscriptionResponse(a, !1, Array.from(d.pending)));\n      I() ? (clearInterval(b.responseCheckIntervalId), O().send(G(a, {\n        topics: Array.from(d.pending)\n      })), b.requestCompleted = !1, b.responseCheckIntervalId = setInterval(function () {\n        b.requestCompleted || (++b.consecutiveNoResponseRequest, n());\n      }, 1e3)) : J(e.warn(\"Ignoring subscribePendingTopics call since Default WebSocket is not open\"));\n    },\n        D = function (n, t) {\n      w(n, WebSocket.CONNECTING) || w(n, WebSocket.OPEN) ? n.close(1e3, t) : J(e.warn(\"Ignoring WebSocket Close request, WebSocket State: \" + h(n)));\n    },\n        M = function (e) {\n      D(t.primary, \"[Primary] WebSocket \" + e), D(t.secondary, \"[Secondary] WebSocket \" + e);\n    },\n        P = function () {\n      r.connectWebSocketRetryCount++;\n      var n = y.addJitter(o.exponentialBackOffTime, .3);\n      Date.now() + n <= s.connConfig.urlConnValidTime ? (J(e.debug(\"Scheduling WebSocket reinitialization, after delay \" + n + \" ms\")), o.exponentialTimeoutHandle = setTimeout(function () {\n        return q();\n      }, n), o.exponentialBackOffTime *= 2) : (J(e.warn(\"WebSocket URL cannot be used to establish connection\")), U());\n    },\n        H = function (n) {\n      N(), _(), J(e.error(\"WebSocket Initialization failed\")), o.websocketInitFailed = !0, M(\"Terminating WebSocket Manager\"), clearInterval(S), k(c.initFailure, {\n        connectWebSocketRetryCount: r.connectWebSocketRetryCount,\n        connectionAttemptStartTime: r.connectionAttemptStartTime,\n        reason: n\n      }), F();\n    },\n        G = function (e, n) {\n      return JSON.stringify({\n        topic: e,\n        content: n\n      });\n    },\n        z = function (n) {\n      return !!(y.isObject(n) && y.isObject(n.webSocketTransport) && y.isNonEmptyString(n.webSocketTransport.url) && y.validWSUrl(n.webSocketTransport.url) && 1e3 * n.webSocketTransport.transportLifeTimeInSeconds >= 3e5) || (J(e.error(\"Invalid WebSocket Connection Configuration\", n)), !1);\n    },\n        U = function () {\n      if (y.isNetworkOnline()) {\n        if (o.websocketInitFailed) J(e.debug(\"WebSocket Init had failed, ignoring this getWebSocketConnConfig request\"));else {\n          if (s.promiseCompleted) return N(), J(e.info(\"Fetching new WebSocket connection configuration\")), r.connectionAttemptStartTime = r.connectionAttemptStartTime || Date.now(), s.promiseCompleted = !1, s.promiseHandle = c.getWebSocketTransport(), s.promiseHandle.then(function (n) {\n            return s.promiseCompleted = !0, J(e.debug(\"Successfully fetched webSocket connection configuration\", n)), z(n) ? (s.connConfig = n, s.connConfig.urlConnValidTime = Date.now() + 85e3, g.connected(), q()) : (H(\"Invalid WebSocket connection configuration: \" + n), {\n              webSocketConnectionFailed: !0\n            });\n          }, function (n) {\n            return s.promiseCompleted = !0, J(e.error(\"Failed to fetch webSocket connection configuration\", n)), y.isNetworkFailure(n) ? (J(e.info(\"Retrying fetching new WebSocket connection configuration\")), g.retry()) : H(\"Failed to fetch webSocket connection configuration: \" + JSON.stringify(n)), {\n              webSocketConnectionFailed: !0\n            };\n          });\n          J(e.debug(\"There is an ongoing getWebSocketConnConfig request, this request will be ignored\"));\n        }\n      } else J(e.info(\"Network offline, ignoring this getWebSocketConnConfig request\"));\n    },\n        q = function () {\n      if (o.websocketInitFailed) return J(e.info(\"web-socket initializing had failed, aborting re-init\")), {\n        webSocketConnectionFailed: !0\n      };\n      if (!y.isNetworkOnline()) return J(e.warn(\"System is offline aborting web-socket init\")), {\n        webSocketConnectionFailed: !0\n      };\n      J(e.info(\"Initializing Websocket Manager\")), v(\"initWebSocket\");\n\n      try {\n        if (z(s.connConfig)) {\n          var n = null;\n          return C(t.primary) ? (J(e.debug(\"Primary Socket connection is already open\")), w(t.secondary, WebSocket.CONNECTING) || (J(e.debug(\"Establishing a secondary web-socket connection\")), t.secondary = B()), n = t.secondary) : (w(t.primary, WebSocket.CONNECTING) || (J(e.debug(\"Establishing a primary web-socket connection\")), t.primary = B()), n = t.primary), o.webSocketInitCheckerTimeoutId = setTimeout(function () {\n            C(n) || P();\n          }, 1e3), {\n            webSocketConnectionFailed: !1\n          };\n        }\n      } catch (n) {\n        return J(e.error(\"Error Initializing web-socket-manager\", n)), H(\"Failed to initialize new WebSocket: \" + n.message), {\n          webSocketConnectionFailed: !0\n        };\n      }\n    },\n        B = function () {\n      var n = new WebSocket(s.connConfig.webSocketTransport.url);\n      return n.addEventListener(\"open\", x), n.addEventListener(\"message\", j), n.addEventListener(\"error\", R), n.addEventListener(\"close\", function (i) {\n        return function (n, i) {\n          J(e.info(\"Socket connection is closed\", n)), v(\"webSocketOnClose before-cleanup\"), k(c.connectionClose, {\n            openTimestamp: i.openTimestamp,\n            closeTimestamp: Date.now(),\n            connectionDuration: Date.now() - i.openTimestamp,\n            code: n.code,\n            reason: n.reason\n          }), T(t.primary) && (t.primary = null), T(t.secondary) && (t.secondary = null), o.reconnectWebSocket && (C(t.primary) || C(t.secondary) ? T(t.primary) && C(t.secondary) && (J(e.info(\"[Primary] WebSocket Cleanly Closed\")), t.primary = t.secondary, t.secondary = null) : (J(e.warn(\"Neither primary websocket and nor secondary websocket have open connections, attempting to re-establish connection\")), o.connState === p ? J(e.info(\"Ignoring connectionLost callback invocation\")) : (k(c.connectionLost, {\n            openTimestamp: i.openTimestamp,\n            closeTimestamp: Date.now(),\n            connectionDuration: Date.now() - i.openTimestamp,\n            code: n.code,\n            reason: n.reason\n          }), r.noOpenConnectionsTimestamp = Date.now()), o.connState = p, U()), v(\"webSocketOnClose after-cleanup\"));\n        }(i, n);\n      }), n;\n    },\n        J = function (e) {\n      return e && \"function\" == typeof e.sendInternalLogToServer && e.sendInternalLogToServer(), e;\n    };\n\n    this.init = function (n) {\n      if (y.assertTrue(y.isFunction(n), \"transportHandle must be a function\"), null === c.getWebSocketTransport) return c.getWebSocketTransport = n, U();\n      J(e.warn(\"Web Socket Manager was already initialized\"));\n    }, this.onInitFailure = function (e) {\n      return y.assertTrue(y.isFunction(e), \"cb must be a function\"), c.initFailure.add(e), o.websocketInitFailed && e(), function () {\n        return c.initFailure.delete(e);\n      };\n    }, this.onConnectionOpen = function (e) {\n      return y.assertTrue(y.isFunction(e), \"cb must be a function\"), c.connectionOpen.add(e), function () {\n        return c.connectionOpen.delete(e);\n      };\n    }, this.onConnectionClose = function (e) {\n      return y.assertTrue(y.isFunction(e), \"cb must be a function\"), c.connectionClose.add(e), function () {\n        return c.connectionClose.delete(e);\n      };\n    }, this.onConnectionGain = function (e) {\n      return y.assertTrue(y.isFunction(e), \"cb must be a function\"), c.connectionGain.add(e), I() && e(), function () {\n        return c.connectionGain.delete(e);\n      };\n    }, this.onConnectionLost = function (e) {\n      return y.assertTrue(y.isFunction(e), \"cb must be a function\"), c.connectionLost.add(e), o.connState === p && e(), function () {\n        return c.connectionLost.delete(e);\n      };\n    }, this.onSubscriptionUpdate = function (e) {\n      return y.assertTrue(y.isFunction(e), \"cb must be a function\"), c.subscriptionUpdate.add(e), function () {\n        return c.subscriptionUpdate.delete(e);\n      };\n    }, this.onSubscriptionFailure = function (e) {\n      return y.assertTrue(y.isFunction(e), \"cb must be a function\"), c.subscriptionFailure.add(e), function () {\n        return c.subscriptionFailure.delete(e);\n      };\n    }, this.onMessage = function (e, n) {\n      return y.assertNotNull(e, \"topicName\"), y.assertTrue(y.isFunction(n), \"cb must be a function\"), c.topic.has(e) ? c.topic.get(e).add(n) : c.topic.set(e, new Set([n])), function () {\n        return c.topic.get(e).delete(n);\n      };\n    }, this.onAllMessage = function (e) {\n      return y.assertTrue(y.isFunction(e), \"cb must be a function\"), c.allMessage.add(e), function () {\n        return c.allMessage.delete(e);\n      };\n    }, this.subscribeTopics = function (e) {\n      y.assertNotNull(e, \"topics\"), y.assertIsList(e), e.forEach(function (e) {\n        d.subscribed.has(e) || d.pending.add(e);\n      }), b.consecutiveNoResponseRequest = 0, A();\n    }, this.sendMessage = function (n) {\n      if (y.assertIsObject(n, \"payload\"), void 0 === n.topic || m.has(n.topic)) J(e.warn(\"Cannot send message, Invalid topic\", n));else {\n        try {\n          n = JSON.stringify(n);\n        } catch (t) {\n          return void J(e.warn(\"Error stringify message\", n));\n        }\n\n        I() ? O().send(n) : J(e.warn(\"Cannot send message, web socket connection is not open\"));\n      }\n    }, this.closeWebSocket = function () {\n      N(), _(), o.reconnectWebSocket = !1, clearInterval(S), M(\"User request to close WebSocket\");\n    }, this.terminateWebSocketManager = H;\n  },\n      R = {\n    create: function () {\n      return new x();\n    },\n    setGlobalConfig: function (e) {\n      var n = e.loggerConfig;\n      E.updateLoggerConfig(n);\n    },\n    LogLevel: O,\n    Logger: T\n  };\n}, function (e, n, t) {\n  var o;\n  !function () {\n    \"use strict\";\n\n    var r = {\n      not_string: /[^s]/,\n      not_bool: /[^t]/,\n      not_type: /[^T]/,\n      not_primitive: /[^v]/,\n      number: /[diefg]/,\n      numeric_arg: /[bcdiefguxX]/,\n      json: /[j]/,\n      not_json: /[^j]/,\n      text: /^[^\\x25]+/,\n      modulo: /^\\x25{2}/,\n      placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-gijostTuvxX])/,\n      key: /^([a-z_][a-z_\\d]*)/i,\n      key_access: /^\\.([a-z_][a-z_\\d]*)/i,\n      index_access: /^\\[(\\d+)\\]/,\n      sign: /^[+-]/\n    };\n\n    function i(e) {\n      return function (e, n) {\n        var t,\n            o,\n            c,\n            s,\n            a,\n            u,\n            l,\n            f,\n            p,\n            d = 1,\n            b = e.length,\n            g = \"\";\n\n        for (o = 0; o < b; o++) if (\"string\" == typeof e[o]) g += e[o];else if (\"object\" == typeof e[o]) {\n          if ((s = e[o]).keys) for (t = n[d], c = 0; c < s.keys.length; c++) {\n            if (null == t) throw new Error(i('[sprintf] Cannot access property \"%s\" of undefined value \"%s\"', s.keys[c], s.keys[c - 1]));\n            t = t[s.keys[c]];\n          } else t = s.param_no ? n[s.param_no] : n[d++];\n          if (r.not_type.test(s.type) && r.not_primitive.test(s.type) && t instanceof Function && (t = t()), r.numeric_arg.test(s.type) && \"number\" != typeof t && isNaN(t)) throw new TypeError(i(\"[sprintf] expecting number but found %T\", t));\n\n          switch (r.number.test(s.type) && (f = t >= 0), s.type) {\n            case \"b\":\n              t = parseInt(t, 10).toString(2);\n              break;\n\n            case \"c\":\n              t = String.fromCharCode(parseInt(t, 10));\n              break;\n\n            case \"d\":\n            case \"i\":\n              t = parseInt(t, 10);\n              break;\n\n            case \"j\":\n              t = JSON.stringify(t, null, s.width ? parseInt(s.width) : 0);\n              break;\n\n            case \"e\":\n              t = s.precision ? parseFloat(t).toExponential(s.precision) : parseFloat(t).toExponential();\n              break;\n\n            case \"f\":\n              t = s.precision ? parseFloat(t).toFixed(s.precision) : parseFloat(t);\n              break;\n\n            case \"g\":\n              t = s.precision ? String(Number(t.toPrecision(s.precision))) : parseFloat(t);\n              break;\n\n            case \"o\":\n              t = (parseInt(t, 10) >>> 0).toString(8);\n              break;\n\n            case \"s\":\n              t = String(t), t = s.precision ? t.substring(0, s.precision) : t;\n              break;\n\n            case \"t\":\n              t = String(!!t), t = s.precision ? t.substring(0, s.precision) : t;\n              break;\n\n            case \"T\":\n              t = Object.prototype.toString.call(t).slice(8, -1).toLowerCase(), t = s.precision ? t.substring(0, s.precision) : t;\n              break;\n\n            case \"u\":\n              t = parseInt(t, 10) >>> 0;\n              break;\n\n            case \"v\":\n              t = t.valueOf(), t = s.precision ? t.substring(0, s.precision) : t;\n              break;\n\n            case \"x\":\n              t = (parseInt(t, 10) >>> 0).toString(16);\n              break;\n\n            case \"X\":\n              t = (parseInt(t, 10) >>> 0).toString(16).toUpperCase();\n          }\n\n          r.json.test(s.type) ? g += t : (!r.number.test(s.type) || f && !s.sign ? p = \"\" : (p = f ? \"+\" : \"-\", t = t.toString().replace(r.sign, \"\")), u = s.pad_char ? \"0\" === s.pad_char ? \"0\" : s.pad_char.charAt(1) : \" \", l = s.width - (p + t).length, a = s.width && l > 0 ? u.repeat(l) : \"\", g += s.align ? p + t + a : \"0\" === u ? p + a + t : a + p + t);\n        }\n\n        return g;\n      }(function (e) {\n        if (s[e]) return s[e];\n        var n,\n            t = e,\n            o = [],\n            i = 0;\n\n        for (; t;) {\n          if (null !== (n = r.text.exec(t))) o.push(n[0]);else if (null !== (n = r.modulo.exec(t))) o.push(\"%\");else {\n            if (null === (n = r.placeholder.exec(t))) throw new SyntaxError(\"[sprintf] unexpected placeholder\");\n\n            if (n[2]) {\n              i |= 1;\n              var c = [],\n                  a = n[2],\n                  u = [];\n              if (null === (u = r.key.exec(a))) throw new SyntaxError(\"[sprintf] failed to parse named argument key\");\n\n              for (c.push(u[1]); \"\" !== (a = a.substring(u[0].length));) if (null !== (u = r.key_access.exec(a))) c.push(u[1]);else {\n                if (null === (u = r.index_access.exec(a))) throw new SyntaxError(\"[sprintf] failed to parse named argument key\");\n                c.push(u[1]);\n              }\n\n              n[2] = c;\n            } else i |= 2;\n\n            if (3 === i) throw new Error(\"[sprintf] mixing positional and named placeholders is not (yet) supported\");\n            o.push({\n              placeholder: n[0],\n              param_no: n[1],\n              keys: n[2],\n              sign: n[3],\n              pad_char: n[4],\n              align: n[5],\n              width: n[6],\n              precision: n[7],\n              type: n[8]\n            });\n          }\n          t = t.substring(n[0].length);\n        }\n\n        return s[e] = o;\n      }(e), arguments);\n    }\n\n    function c(e, n) {\n      return i.apply(null, [e].concat(n || []));\n    }\n\n    var s = Object.create(null);\n    n.sprintf = i, n.vsprintf = c, \"undefined\" != typeof window && (window.sprintf = i, window.vsprintf = c, void 0 === (o = function () {\n      return {\n        sprintf: i,\n        vsprintf: c\n      };\n    }.call(n, t, n, e)) || (e.exports = o));\n  }();\n}, function (e, n, t) {\n  \"use strict\";\n\n  t.r(n), function (e) {\n    t.d(n, \"WebSocketManager\", function () {\n      return r;\n    });\n    var o = t(0);\n    e.connect = e.connect || {}, connect.WebSocketManager = o.a;\n    var r = o.a;\n  }.call(this, t(3));\n}, function (e, n) {\n  var t;\n\n  t = function () {\n    return this;\n  }();\n\n  try {\n    t = t || new Function(\"return this\")();\n  } catch (e) {\n    \"object\" == typeof window && (t = window);\n  }\n\n  e.exports = t;\n}]); //# sourceMappingURL=amazon-connect-websocket-manager.js.map\n\n/*\n * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n(function () {\n  var global = this;\n  connect = global.connect || {};\n  global.connect = connect;\n  global.lily = connect;\n  connect.core = {};\n  connect.core.initialized = false;\n  connect.version = \"1.7.4\";\n  connect.DEFAULT_BATCH_SIZE = 500;\n  var CCP_SYN_TIMEOUT = 1000; // 1 sec\n\n  var CCP_ACK_TIMEOUT = 3000; // 3 sec\n\n  var CCP_LOAD_TIMEOUT = 5000; // 5 sec\n\n  var CCP_IFRAME_REFRESH_INTERVAL = 5000; // 5 sec\n\n  var LEGACY_LOGIN_URL_PATTERN = \"https://{alias}.awsapps.com/auth/?client_id={client_id}&redirect_uri={redirect}\";\n  var CLIENT_ID_MAP = {\n    \"us-east-1\": \"06919f4fd8ed324e\"\n  };\n  var AUTHORIZE_ENDPOINT = \"/auth/authorize\";\n  var LEGACY_AUTHORIZE_ENDPOINT = \"/connect/auth/authorize\";\n  var AUTHORIZE_RETRY_INTERVAL = 2000;\n  var AUTHORIZE_MAX_RETRY = 5;\n  var LEGACY_WHITELISTED_ORIGINS_ENDPOINT = \"/connect/whitelisted-origins\";\n  var WHITELISTED_ORIGINS_ENDPOINT = \"/whitelisted-origins\";\n  var WHITELISTED_ORIGINS_RETRY_INTERVAL = 2000;\n  var WHITELISTED_ORIGINS_MAX_RETRY = 5;\n  connect.numberOfConnectedCCPs = 0;\n  /**\n   * @deprecated\n   * This function was only meant for internal use. \n   * The name is misleading for what it should do.\n   * Internally we have replaced its usage with `getLoginUrl`.\n   */\n\n  var createLoginUrl = function (params) {\n    var redirect = \"https://lily.us-east-1.amazonaws.com/taw/auth/code\";\n    connect.assertNotNull(redirect);\n\n    if (params.loginUrl) {\n      return params.loginUrl;\n    } else if (params.alias) {\n      log.warn(\"The `alias` param is deprecated and should not be expected to function properly. Please use `ccpUrl` or `loginUrl`. See https://github.com/amazon-connect/amazon-connect-streams/blob/master/README.md#connectcoreinitccp for valid parameters.\");\n      return LEGACY_LOGIN_URL_PATTERN.replace(\"{alias}\", params.alias).replace(\"{client_id}\", CLIENT_ID_MAP[\"us-east-1\"]).replace(\"{redirect}\", global.encodeURIComponent(redirect));\n    } else {\n      return params.ccpUrl;\n    }\n  };\n  /**\n   * Replaces `createLoginUrl`, as that function's name was misleading.\n   * The `params.alias` parameter is deprecated. Please refrain from using it.\n   */\n\n\n  var getLoginUrl = function (params) {\n    var redirect = \"https://lily.us-east-1.amazonaws.com/taw/auth/code\";\n    connect.assertNotNull(redirect);\n\n    if (params.loginUrl) {\n      return params.loginUrl;\n    } else if (params.alias) {\n      log.warn(\"The `alias` param is deprecated and should not be expected to function properly. Please use `ccpUrl` or `loginUrl`. See https://github.com/amazon-connect/amazon-connect-streams/blob/master/README.md#connectcoreinitccp for valid parameters.\");\n      return LEGACY_LOGIN_URL_PATTERN.replace(\"{alias}\", params.alias).replace(\"{client_id}\", CLIENT_ID_MAP[\"us-east-1\"]).replace(\"{redirect}\", global.encodeURIComponent(redirect));\n    } else {\n      return params.ccpUrl;\n    }\n  };\n  /**-------------------------------------------------------------------------\n  * Returns scheme://host:port for a given url\n  */\n\n\n  function sanitizeDomain(url) {\n    var domain = url.match(/^(?:https?:\\/\\/)?(?:[^@\\n]+@)?(?:www\\.)?([^:\\/\\n?]+)/ig);\n    return domain.length ? domain[0] : \"\";\n  }\n  /**-------------------------------------------------------------------------\n    * Print a warning message if the Connect core is not initialized.\n    */\n\n\n  connect.core.checkNotInitialized = function () {\n    if (connect.core.initialized) {\n      var log = connect.getLog();\n      log.warn(\"Connect core already initialized, only needs to be initialized once.\").sendInternalLogToServer();\n    }\n  };\n  /**-------------------------------------------------------------------------\n   * Basic Connect client initialization.\n   * Should be used only by the API Shared Worker.\n   */\n\n\n  connect.core.init = function (params) {\n    connect.core.eventBus = new connect.EventBus();\n    connect.core.agentDataProvider = new AgentDataProvider(connect.core.getEventBus());\n    connect.core.initClient(params);\n    connect.core.initAgentAppClient(params);\n    connect.core.initialized = true;\n  };\n  /**-------------------------------------------------------------------------\n   * Initialized AWS client\n   * Should be used by Shared Worker to update AWS client with new credentials\n   * after refreshed authentication.\n   */\n\n\n  connect.core.initClient = function (params) {\n    connect.assertNotNull(params, 'params');\n    var authToken = connect.assertNotNull(params.authToken, 'params.authToken');\n    var region = connect.assertNotNull(params.region, 'params.region');\n    var endpoint = params.endpoint || null;\n    connect.core.client = new connect.AWSClient(authToken, region, endpoint);\n  };\n  /**-------------------------------------------------------------------------\n   * Initialized AgentApp client\n   * Should be used by Shared Worker to update AgentApp client with new credentials\n   * after refreshed authentication.\n   */\n\n\n  connect.core.initAgentAppClient = function (params) {\n    connect.assertNotNull(params, 'params');\n    var authToken = connect.assertNotNull(params.authToken, 'params.authToken');\n    var authCookieName = connect.assertNotNull(params.authCookieName, 'params.authCookieName');\n    var endpoint = connect.assertNotNull(params.agentAppEndpoint, 'params.agentAppEndpoint');\n    connect.core.agentAppClient = new connect.AgentAppClient(authCookieName, authToken, endpoint);\n  };\n  /**-------------------------------------------------------------------------\n   * Uninitialize Connect.\n   */\n\n\n  connect.core.terminate = function () {\n    connect.core.client = new connect.NullClient();\n    connect.core.agentAppClient = new connect.NullClient();\n    connect.core.masterClient = new connect.NullClient();\n    var bus = connect.core.getEventBus();\n    if (bus) bus.unsubscribeAll();\n    connect.core.bus = new connect.EventBus();\n    connect.core.agentDataProvider = null;\n    connect.core.softphoneManager = null;\n    connect.core.upstream = null;\n    connect.core.keepaliveManager = null;\n    connect.agent.initialized = false;\n    connect.core.initialized = false;\n  };\n  /**-------------------------------------------------------------------------\n   * Setup the SoftphoneManager to be initialized when the agent\n   * is determined to have softphone enabled.\n   */\n\n\n  connect.core.softphoneUserMediaStream = null;\n\n  connect.core.getSoftphoneUserMediaStream = function () {\n    return connect.core.softphoneUserMediaStream;\n  };\n\n  connect.core.setSoftphoneUserMediaStream = function (stream) {\n    connect.core.softphoneUserMediaStream = stream;\n  };\n\n  connect.core.initRingtoneEngines = function (params) {\n    connect.assertNotNull(params, \"params\");\n\n    var setupRingtoneEngines = function (ringtoneSettings) {\n      connect.assertNotNull(ringtoneSettings, \"ringtoneSettings\");\n      connect.assertNotNull(ringtoneSettings.voice, \"ringtoneSettings.voice\");\n      connect.assertTrue(ringtoneSettings.voice.ringtoneUrl || ringtoneSettings.voice.disabled, \"ringtoneSettings.voice.ringtoneUrl must be provided or ringtoneSettings.voice.disabled must be true\");\n      connect.assertNotNull(ringtoneSettings.queue_callback, \"ringtoneSettings.queue_callback\");\n      connect.assertTrue(ringtoneSettings.queue_callback.ringtoneUrl || ringtoneSettings.queue_callback.disabled, \"ringtoneSettings.voice.ringtoneUrl must be provided or ringtoneSettings.queue_callback.disabled must be true\");\n      connect.core.ringtoneEngines = {};\n      connect.agent(function (agent) {\n        agent.onRefresh(function () {\n          connect.ifMaster(connect.MasterTopics.RINGTONE, function () {\n            if (!ringtoneSettings.voice.disabled && !connect.core.ringtoneEngines.voice) {\n              connect.core.ringtoneEngines.voice = new connect.VoiceRingtoneEngine(ringtoneSettings.voice);\n              connect.getLog().info(\"VoiceRingtoneEngine initialized.\").sendInternalLogToServer();\n            }\n\n            if (!ringtoneSettings.chat.disabled && !connect.core.ringtoneEngines.chat) {\n              connect.core.ringtoneEngines.chat = new connect.ChatRingtoneEngine(ringtoneSettings.chat);\n              connect.getLog().info(\"ChatRingtoneEngine initialized.\").sendInternalLogToServer();\n            }\n\n            if (!ringtoneSettings.task.disabled && !connect.core.ringtoneEngines.task) {\n              connect.core.ringtoneEngines.task = new connect.TaskRingtoneEngine(ringtoneSettings.task);\n              connect.getLog().info(\"TaskRingtoneEngine initialized.\").sendInternalLogToServer();\n            }\n\n            if (!ringtoneSettings.queue_callback.disabled && !connect.core.ringtoneEngines.queue_callback) {\n              connect.core.ringtoneEngines.queue_callback = new connect.QueueCallbackRingtoneEngine(ringtoneSettings.queue_callback);\n              connect.getLog().info(\"QueueCallbackRingtoneEngine initialized.\").sendInternalLogToServer();\n            }\n          });\n        });\n      });\n      handleRingerDeviceChange();\n    };\n\n    var mergeParams = function (params, otherParams) {\n      // For backwards compatibility: support pulling disabled flag and ringtoneUrl\n      // from softphone config if it exists from downstream into the ringtone config.\n      params.ringtone = params.ringtone || {};\n      params.ringtone.voice = params.ringtone.voice || {};\n      params.ringtone.queue_callback = params.ringtone.queue_callback || {};\n      params.ringtone.chat = params.ringtone.chat || {\n        disabled: true\n      };\n      params.ringtone.task = params.ringtone.task || {\n        disabled: true\n      };\n\n      if (otherParams.softphone) {\n        if (otherParams.softphone.disableRingtone) {\n          params.ringtone.voice.disabled = true;\n          params.ringtone.queue_callback.disabled = true;\n        }\n\n        if (otherParams.softphone.ringtoneUrl) {\n          params.ringtone.voice.ringtoneUrl = otherParams.softphone.ringtoneUrl;\n          params.ringtone.queue_callback.ringtoneUrl = otherParams.softphone.ringtoneUrl;\n        }\n      }\n\n      if (otherParams.chat) {\n        if (otherParams.chat.disableRingtone) {\n          params.ringtone.chat.disabled = true;\n        }\n\n        if (otherParams.chat.ringtoneUrl) {\n          params.ringtone.chat.ringtoneUrl = otherParams.chat.ringtoneUrl;\n        }\n      } // Merge in ringtone settings from downstream.\n\n\n      if (otherParams.ringtone) {\n        params.ringtone.voice = connect.merge(params.ringtone.voice, otherParams.ringtone.voice || {});\n        params.ringtone.queue_callback = connect.merge(params.ringtone.queue_callback, otherParams.ringtone.voice || {});\n        params.ringtone.chat = connect.merge(params.ringtone.chat, otherParams.ringtone.chat || {});\n      }\n    }; // Merge params from params.softphone and params.chat into params.ringtone\n    // for embedded and non-embedded use cases so that defaults are picked up.\n\n\n    mergeParams(params, params);\n\n    if (connect.isFramed()) {\n      // If the CCP is in a frame, wait for configuration from downstream.\n      var bus = connect.core.getEventBus();\n      bus.subscribe(connect.EventType.CONFIGURE, function (data) {\n        this.unsubscribe(); // Merge all params from data into params for any overridden\n        // values in either legacy \"softphone\" or \"ringtone\" settings.\n\n        mergeParams(params, data);\n        setupRingtoneEngines(params.ringtone);\n      });\n    } else {\n      setupRingtoneEngines(params.ringtone);\n    }\n  };\n\n  var handleRingerDeviceChange = function () {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(connect.ConfigurationEvents.SET_RINGER_DEVICE, setRingerDevice);\n  };\n\n  var setRingerDevice = function (data) {\n    if (connect.keys(connect.core.ringtoneEngines).length === 0 || !data || !data.deviceId) {\n      return;\n    }\n\n    var deviceId = data.deviceId;\n\n    for (var ringtoneType in connect.core.ringtoneEngines) {\n      connect.core.ringtoneEngines[ringtoneType].setOutputDevice(deviceId);\n    }\n\n    connect.core.getUpstream().sendUpstream(connect.EventType.BROADCAST, {\n      event: connect.ConfigurationEvents.RINGER_DEVICE_CHANGED,\n      data: {\n        deviceId: deviceId\n      }\n    });\n  };\n\n  connect.core.initSoftphoneManager = function (paramsIn) {\n    connect.getLog().info(\"[Softphone Manager] initSoftphoneManager started\").sendInternalLogToServer();\n    var params = paramsIn || {};\n\n    var competeForMasterOnAgentUpdate = function (softphoneParamsIn) {\n      var softphoneParams = connect.merge(params.softphone || {}, softphoneParamsIn);\n      connect.getLog().info(\"[Softphone Manager] competeForMasterOnAgentUpdate executed\").sendInternalLogToServer();\n      connect.agent(function (agent) {\n        if (!agent.getChannelConcurrency(connect.ChannelType.VOICE)) {\n          return;\n        }\n\n        agent.onRefresh(function () {\n          var sub = this;\n          connect.getLog().info(\"[Softphone Manager] agent refresh handler executed\").sendInternalLogToServer();\n          connect.ifMaster(connect.MasterTopics.SOFTPHONE, function () {\n            connect.getLog().info(\"[Softphone Manager] confirmed as softphone master topic\").sendInternalLogToServer();\n\n            if (!connect.core.softphoneManager && agent.isSoftphoneEnabled()) {\n              // Become master to send logs, since we need logs from softphone tab.\n              connect.becomeMaster(connect.MasterTopics.SEND_LOGS);\n              connect.core.softphoneManager = new connect.SoftphoneManager(softphoneParams);\n              sub.unsubscribe();\n            }\n          });\n        });\n      });\n    };\n    /**\n     * If the window is framed, we need to wait for a CONFIGURE message from\n     * downstream before we try to initialize, unless params.allowFramedSoftphone is true.\n     */\n\n\n    if (connect.isFramed() && !params.allowFramedSoftphone) {\n      var bus = connect.core.getEventBus();\n      bus.subscribe(connect.EventType.CONFIGURE, function (data) {\n        connect.getLog().info(\"[Softphone Manager] Configure event handler executed\").sendInternalLogToServer();\n\n        if (data.softphone && data.softphone.allowFramedSoftphone) {\n          this.unsubscribe();\n          competeForMasterOnAgentUpdate(data.softphone);\n        }\n\n        setupEventListenersForMultiTabUseInFirefox(data.softphone);\n      });\n    } else {\n      competeForMasterOnAgentUpdate(params);\n      setupEventListenersForMultiTabUseInFirefox(params);\n    }\n\n    connect.agent(function (agent) {\n      // Sync mute across all tabs \n      if (agent.isSoftphoneEnabled() && agent.getChannelConcurrency(connect.ChannelType.VOICE)) {\n        connect.core.getUpstream().sendUpstream(connect.EventType.BROADCAST, {\n          event: connect.EventType.MUTE\n        });\n      }\n    });\n\n    function setupEventListenersForMultiTabUseInFirefox(softphoneParamsIn) {\n      var softphoneParams = connect.merge(params.softphone || {}, softphoneParamsIn); // keep the softphone params for external use\n\n      connect.core.softphoneParams = softphoneParams;\n\n      if (connect.isFirefoxBrowser()) {\n        // In Firefox, when a tab takes over another tab's softphone primary,\n        // the previous primary tab should delete sofphone manager and stop microphone\n        connect.core.getUpstream().onUpstream(connect.EventType.MASTER_RESPONSE, function (res) {\n          if (res.data && res.data.topic === connect.MasterTopics.SOFTPHONE && res.data.takeOver && res.data.masterId !== connect.core.portStreamId) {\n            if (connect.core.softphoneManager) {\n              connect.core.softphoneManager.onInitContactSub.unsubscribe();\n              delete connect.core.softphoneManager;\n            }\n\n            var userMediaStream = connect.core.getSoftphoneUserMediaStream();\n\n            if (userMediaStream) {\n              userMediaStream.getTracks().forEach(function (track) {\n                track.stop();\n              });\n              connect.core.setSoftphoneUserMediaStream(null);\n            }\n          }\n        }); // In Firefox, when multiple tabs are open,\n        // webrtc session is not started until READY_TO_START_SESSION event is triggered\n\n        connect.core.getEventBus().subscribe(connect.ConnectionEvents.READY_TO_START_SESSION, function () {\n          connect.ifMaster(connect.MasterTopics.SOFTPHONE, function () {\n            if (connect.core.softphoneManager) {\n              connect.core.softphoneManager.startSession();\n            }\n          }, function () {\n            connect.becomeMaster(connect.MasterTopics.SOFTPHONE, function () {\n              connect.agent(function (agent) {\n                if (!connect.core.softphoneManager && agent.isSoftphoneEnabled()) {\n                  connect.becomeMaster(connect.MasterTopics.SEND_LOGS);\n                  connect.core.softphoneManager = new connect.SoftphoneManager(softphoneParams);\n                  connect.core.softphoneManager.startSession();\n                }\n              });\n            });\n          });\n        }); // handling outbound-call and auto-accept cases for pending session\n\n        connect.contact(function (c) {\n          connect.agent(function (agent) {\n            c.onRefresh(function (contact) {\n              if (connect.hasOtherConnectedCCPs() && document.visibilityState === 'visible' && (contact.getStatus().type === connect.ContactStatusType.CONNECTING || contact.getStatus().type === connect.ContactStatusType.INCOMING)) {\n                var isOutBoundCall = contact.isSoftphoneCall() && !contact.isInbound();\n                var isAutoAcceptEnabled = contact.isSoftphoneCall() && agent.getConfiguration().softphoneAutoAccept;\n                var isQueuedCallback = contact.getType() === connect.ContactType.QUEUE_CALLBACK;\n\n                if (isOutBoundCall || isAutoAcceptEnabled || isQueuedCallback) {\n                  connect.core.triggerReadyToStartSessionEvent();\n                }\n              }\n            });\n          });\n        });\n      }\n    }\n  }; // trigger READY_TO_START_SESSION event in a context with Softphone Manager\n  // internal use only\n\n\n  connect.core.triggerReadyToStartSessionEvent = function () {\n    var allowFramedSoftphone = connect.core.softphoneParams && connect.core.softphoneParams.allowFramedSoftphone;\n\n    if (connect.isCCP()) {\n      if (allowFramedSoftphone) {\n        // the event is triggered in this iframed CCP context\n        connect.core.getEventBus().trigger(connect.ConnectionEvents.READY_TO_START_SESSION);\n      } else {\n        if (connect.isFramed()) {\n          // if this is an iframed CCP, the event is send to downstream (CRM)\n          connect.core.getUpstream().sendDownstream(connect.ConnectionEvents.READY_TO_START_SESSION);\n        } else {\n          // if this is a standalone CCP, trigger this event in this CCP context\n          connect.core.getEventBus().trigger(connect.ConnectionEvents.READY_TO_START_SESSION);\n        }\n      }\n    } else {\n      if (allowFramedSoftphone) {\n        // the event is send to the upstream (iframed CCP)\n        connect.core.getUpstream().sendUpstream(connect.ConnectionEvents.READY_TO_START_SESSION);\n      } else {\n        // the event is triggered in this CRM context\n        connect.core.getEventBus().trigger(connect.ConnectionEvents.READY_TO_START_SESSION);\n      }\n    }\n  };\n\n  connect.core.initPageOptions = function (params) {\n    connect.assertNotNull(params, \"params\");\n\n    if (connect.isFramed()) {\n      // If the CCP is in a frame, wait for configuration from downstream.\n      var bus = connect.core.getEventBus();\n      bus.subscribe(connect.EventType.CONFIGURE, function (data) {\n        connect.core.getUpstream().sendUpstream(connect.EventType.BROADCAST, {\n          event: connect.ConfigurationEvents.CONFIGURE,\n          data: data\n        });\n      }); // Listen for iframe media devices request from CRM\n\n      bus.subscribe(connect.EventType.MEDIA_DEVICE_REQUEST, function () {\n        function sendDevices(devices) {\n          connect.core.getUpstream().sendDownstream(connect.EventType.MEDIA_DEVICE_RESPONSE, devices);\n        }\n\n        if (navigator && navigator.mediaDevices) {\n          navigator.mediaDevices.enumerateDevices().then(function (devicesIn) {\n            devices = devicesIn || [];\n            devices = devices.map(function (d) {\n              return d.toJSON();\n            });\n            sendDevices(devices);\n          }).catch(function (err) {\n            sendDevices({\n              error: err.message\n            });\n          });\n        } else {\n          sendDevices({\n            error: \"No navigator or navigator.mediaDevices object found\"\n          });\n        }\n      });\n    }\n  };\n  /**-------------------------------------------------------------------------\n   * Get the list of media devices from iframed CCP\n   * Timeout for the request is passed an an optional argument\n   * The default timeout is 1000ms\n   */\n\n\n  connect.core.getFrameMediaDevices = function (timeoutIn) {\n    var sub = null;\n    var timeout = timeoutIn || 1000;\n    var timeoutPromise = new Promise(function (resolve, reject) {\n      setTimeout(function () {\n        reject(new Error(\"Timeout exceeded\"));\n      }, timeout);\n    });\n    var mediaDevicesPromise = new Promise(function (resolve, reject) {\n      if (connect.isFramed() || connect.isCCP()) {\n        if (navigator && navigator.mediaDevices) {\n          navigator.mediaDevices.enumerateDevices().then(function (devicesIn) {\n            devices = devicesIn || [];\n            devices = devices.map(function (d) {\n              return d.toJSON();\n            });\n            resolve(devices);\n          });\n        } else {\n          reject(new Error(\"No navigator or navigator.mediaDevices object found\"));\n        }\n      } else {\n        var bus = connect.core.getEventBus();\n        sub = bus.subscribe(connect.EventType.MEDIA_DEVICE_RESPONSE, function (data) {\n          if (data.error) {\n            reject(new Error(data.error));\n          } else {\n            resolve(data);\n          }\n        });\n        connect.core.getUpstream().sendUpstream(connect.EventType.MEDIA_DEVICE_REQUEST);\n      }\n    });\n    return Promise.race([mediaDevicesPromise, timeoutPromise]).finally(function () {\n      if (sub) {\n        sub.unsubscribe();\n      }\n    });\n  }; //Internal use only.\n\n\n  connect.core.authorize = function (endpoint) {\n    var options = {\n      credentials: 'include'\n    };\n    var authorizeEndpoint = endpoint;\n\n    if (!authorizeEndpoint) {\n      authorizeEndpoint = connect.core.isLegacyDomain() ? LEGACY_AUTHORIZE_ENDPOINT : AUTHORIZE_ENDPOINT;\n    }\n\n    return connect.fetch(authorizeEndpoint, options, AUTHORIZE_RETRY_INTERVAL, AUTHORIZE_MAX_RETRY);\n  };\n  /**\n   * @deprecated\n   * This used to be used internally, but is no longer needed.\n   */\n\n\n  connect.core.verifyDomainAccess = function (authToken, endpoint) {\n    connect.getLog().warn(\"This API will be deprecated in the next major version release\");\n\n    if (!connect.isFramed()) {\n      return Promise.resolve();\n    }\n\n    var options = {\n      headers: {\n        'X-Amz-Bearer': authToken\n      }\n    };\n    var whitelistedOriginsEndpoint = null;\n\n    if (endpoint) {\n      whitelistedOriginsEndpoint = endpoint;\n    } else {\n      whitelistedOriginsEndpoint = connect.core.isLegacyDomain() ? LEGACY_WHITELISTED_ORIGINS_ENDPOINT : WHITELISTED_ORIGINS_ENDPOINT;\n    }\n\n    return connect.fetch(whitelistedOriginsEndpoint, options, WHITELISTED_ORIGINS_RETRY_INTERVAL, WHITELISTED_ORIGINS_MAX_RETRY).then(function (response) {\n      var topDomain = sanitizeDomain(window.document.referrer);\n      var isAllowed = response.whitelistedOrigins.some(function (origin) {\n        return topDomain === sanitizeDomain(origin);\n      });\n      return isAllowed ? Promise.resolve() : Promise.reject();\n    });\n  };\n  /**-------------------------------------------------------------------------\n   * Returns true if this window's href is on the legacy connect domain. \n   * Only useful for internal use. \n   */\n\n\n  connect.core.isLegacyDomain = function (url) {\n    url = url || window.location.href;\n    return url.includes('.awsapps.com');\n  };\n  /**-------------------------------------------------------------------------\n   * Initializes Connect by creating or connecting to the API Shared Worker.\n   * Used only by the CCP\n   */\n\n\n  connect.core.initSharedWorker = function (params) {\n    connect.core.checkNotInitialized();\n\n    if (connect.core.initialized) {\n      return;\n    }\n\n    connect.assertNotNull(params, 'params');\n    var sharedWorkerUrl = connect.assertNotNull(params.sharedWorkerUrl, 'params.sharedWorkerUrl');\n    var authToken = connect.assertNotNull(params.authToken, 'params.authToken');\n    var refreshToken = connect.assertNotNull(params.refreshToken, 'params.refreshToken');\n    var authTokenExpiration = connect.assertNotNull(params.authTokenExpiration, 'params.authTokenExpiration');\n    var region = connect.assertNotNull(params.region, 'params.region');\n    var endpoint = params.endpoint || null;\n    var authorizeEndpoint = params.authorizeEndpoint;\n\n    if (!authorizeEndpoint) {\n      authorizeEndpoint = connect.core.isLegacyDomain() ? LEGACY_AUTHORIZE_ENDPOINT : AUTHORIZE_ENDPOINT;\n    }\n\n    var agentAppEndpoint = params.agentAppEndpoint || null;\n    var authCookieName = params.authCookieName || null;\n\n    try {\n      // Initialize the event bus and agent data providers.\n      connect.core.eventBus = new connect.EventBus({\n        logEvents: true\n      });\n      connect.core.agentDataProvider = new AgentDataProvider(connect.core.getEventBus());\n      connect.core.mediaFactory = new connect.MediaFactory(params); // Create the shared worker and upstream conduit.\n\n      var worker = new SharedWorker(sharedWorkerUrl, \"ConnectSharedWorker\");\n      var conduit = new connect.Conduit(\"ConnectSharedWorkerConduit\", new connect.PortStream(worker.port), new connect.WindowIOStream(window, parent)); // Set the global upstream conduit for external use.\n\n      connect.core.upstream = conduit;\n      connect.core.webSocketProvider = new WebSocketProvider(); // Close our port to the shared worker before the window closes.\n\n      global.onunload = function () {\n        conduit.sendUpstream(connect.EventType.CLOSE);\n        worker.port.close();\n      };\n\n      connect.getLog().scheduleUpstreamLogPush(conduit);\n      connect.getLog().scheduleDownstreamClientSideLogsPush(); // Bridge all upstream messages into the event bus.\n\n      conduit.onAllUpstream(connect.core.getEventBus().bridge()); // Pass all upstream messages (from shared worker) downstream (to CCP consumer).\n\n      conduit.onAllUpstream(conduit.passDownstream());\n\n      if (connect.isFramed()) {\n        // Bridge all downstream messages into the event bus.\n        conduit.onAllDownstream(connect.core.getEventBus().bridge()); // Pass all downstream messages (from CCP consumer) upstream (to shared worker).\n\n        conduit.onAllDownstream(conduit.passUpstream());\n      } // Send configuration up to the shared worker.\n\n\n      conduit.sendUpstream(connect.EventType.CONFIGURE, {\n        authToken: authToken,\n        authTokenExpiration: authTokenExpiration,\n        endpoint: endpoint,\n        refreshToken: refreshToken,\n        region: region,\n        authorizeEndpoint: authorizeEndpoint,\n        agentAppEndpoint: agentAppEndpoint,\n        authCookieName: authCookieName\n      });\n      conduit.onUpstream(connect.EventType.ACKNOWLEDGE, function (data) {\n        connect.getLog().info(\"Acknowledged by the ConnectSharedWorker!\").sendInternalLogToServer();\n        connect.core.initialized = true;\n        connect.core.portStreamId = data.id;\n        this.unsubscribe();\n      }); // Add all upstream log entries to our own logger.\n\n      conduit.onUpstream(connect.EventType.LOG, function (logEntry) {\n        if (logEntry.loggerId !== connect.getLog().getLoggerId()) {\n          connect.getLog().addLogEntry(connect.LogEntry.fromObject(logEntry));\n        }\n      }); // Get worker logs\n\n      conduit.onUpstream(connect.EventType.SERVER_BOUND_INTERNAL_LOG, function (logEntry) {\n        connect.getLog().sendInternalLogEntryToServer(connect.LogEntry.fromObject(logEntry));\n      }); // Get outer context logs\n\n      conduit.onDownstream(connect.EventType.SERVER_BOUND_INTERNAL_LOG, function (logs) {\n        if (connect.isFramed() && Array.isArray(logs)) {\n          logs.forEach(function (log) {\n            connect.getLog().sendInternalLogEntryToServer(connect.LogEntry.fromObject(log));\n          });\n        }\n      }); // Get log from outer context\n\n      conduit.onDownstream(connect.EventType.LOG, function (log) {\n        if (connect.isFramed() && log.loggerId !== connect.getLog().getLoggerId()) {\n          connect.getLog().addLogEntry(connect.LogEntry.fromObject(log));\n        }\n      }); // Reload the page if the shared worker detects an API auth failure.\n\n      conduit.onUpstream(connect.EventType.AUTH_FAIL, function (logEntry) {\n        location.reload();\n      });\n      connect.getLog().info(\"User Agent: \" + navigator.userAgent).sendInternalLogToServer();\n      connect.getLog().info(\"isCCPv2: \" + true).sendInternalLogToServer();\n      connect.getLog().info(\"isFramed: \" + connect.isFramed()).sendInternalLogToServer();\n      connect.core.upstream.onDownstream(connect.EventType.OUTER_CONTEXT_INFO, function (data) {\n        var streamsVersion = data.streamsVersion;\n        connect.getLog().info(\"StreamsJS Version: \" + streamsVersion).sendInternalLogToServer();\n      });\n      conduit.onUpstream(connect.EventType.UPDATE_CONNECTED_CCPS, function (data) {\n        connect.getLog().info(\"Number of connected CCPs updated: \" + data.length).sendInternalLogToServer();\n        connect.numberOfConnectedCCPs = data.length;\n      });\n      connect.core.client = new connect.UpstreamConduitClient(conduit);\n      connect.core.masterClient = new connect.UpstreamConduitMasterClient(conduit); // Pass the TERMINATE request upstream to the shared worker.\n\n      connect.core.getEventBus().subscribe(connect.EventType.TERMINATE, conduit.passUpstream()); // Refresh the page when we receive the TERMINATED response from the\n      // shared worker.\n\n      connect.core.getEventBus().subscribe(connect.EventType.TERMINATED, function () {\n        window.location.reload(true);\n      });\n      worker.port.start();\n      conduit.onUpstream(connect.VoiceIdEvents.UPDATE_DOMAIN_ID, function (data) {\n        if (data && data.domainId) {\n          connect.core.voiceIdDomainId = data.domainId;\n        }\n      }); // try fetching voiceId's domainId once the agent is initialized\n\n      connect.agent(function () {\n        var voiceId = new connect.VoiceId();\n        voiceId.getDomainId().then(function (domainId) {\n          connect.getLog().info(\"voiceId domainId successfully fetched at agent initialization: \" + domainId).sendInternalLogToServer();\n        }).catch(function (err) {\n          connect.getLog().info(\"voiceId domainId not fetched at agent initialization\").withObject({\n            err: err\n          }).sendInternalLogToServer();\n        });\n      }); // Attempt to get permission to show notifications.\n\n      var nm = connect.core.getNotificationManager();\n      nm.requestPermission();\n    } catch (e) {\n      connect.getLog().error(\"Failed to initialize the API shared worker, we're dead!\").withException(e).sendInternalLogToServer();\n    }\n  };\n  /**-------------------------------------------------------------------------\n   * Initializes Connect by creating or connecting to the API Shared Worker.\n   * Initializes Connect by loading the CCP in an iframe and connecting to it.\n   */\n\n\n  connect.core.initCCP = function (containerDiv, paramsIn) {\n    connect.core.checkNotInitialized();\n\n    if (connect.core.initialized) {\n      return;\n    } // For backwards compatibility, when instead of taking a params object\n    // as input we only accepted ccpUrl.\n\n\n    var params = {};\n\n    if (typeof paramsIn === 'string') {\n      params.ccpUrl = paramsIn;\n    } else {\n      params = paramsIn;\n    }\n\n    connect.assertNotNull(containerDiv, 'containerDiv');\n    connect.assertNotNull(params.ccpUrl, 'params.ccpUrl'); // Create the CCP iframe and append it to the container div.\n\n    var iframe = document.createElement('iframe');\n    iframe.src = params.ccpUrl;\n    iframe.allow = \"microphone; autoplay\";\n    iframe.style = \"width: 100%; height: 100%\";\n    iframe.title = 'Amazon Connect CCP';\n    containerDiv.appendChild(iframe); // Initialize the event bus and agent data providers.\n    // NOTE: Setting logEvents here to FALSE in order to avoid duplicating\n    // events which are logged in CCP.\n\n    connect.core.eventBus = new connect.EventBus({\n      logEvents: false\n    });\n    connect.core.agentDataProvider = new AgentDataProvider(connect.core.getEventBus());\n    connect.core.mediaFactory = new connect.MediaFactory(params); // Build the upstream conduit communicating with the CCP iframe.\n\n    var conduit = new connect.IFrameConduit(params.ccpUrl, window, iframe); // Let CCP know if iframe is visible\n\n    iframe.onload = setTimeout(function () {\n      var style = window.getComputedStyle(iframe, null);\n      var data = {\n        display: style.display,\n        offsetWidth: iframe.offsetWidth,\n        offsetHeight: iframe.offsetHeight,\n        clientRectsLength: iframe.getClientRects().length\n      };\n      conduit.sendUpstream(connect.EventType.IFRAME_STYLE, data);\n    }, 10000); // Set the global upstream conduit for external use.\n\n    connect.core.upstream = conduit; // Init webSocketProvider\n\n    connect.core.webSocketProvider = new WebSocketProvider();\n    conduit.onAllUpstream(connect.core.getEventBus().bridge()); // Initialize the keepalive manager.\n\n    connect.core.keepaliveManager = new KeepaliveManager(conduit, connect.core.getEventBus(), params.ccpSynTimeout || CCP_SYN_TIMEOUT, params.ccpAckTimeout || CCP_ACK_TIMEOUT);\n    connect.core.iframeRefreshInterval = null; // Allow 10 sec (default) before receiving the first ACK from the CCP.\n\n    connect.core.ccpLoadTimeoutInstance = global.setTimeout(function () {\n      connect.core.ccpLoadTimeoutInstance = null;\n      connect.core.getEventBus().trigger(connect.EventType.ACK_TIMEOUT);\n    }, params.ccpLoadTimeout || CCP_LOAD_TIMEOUT);\n    connect.getLog().scheduleUpstreamOuterContextCCPLogsPush(conduit);\n    connect.getLog().scheduleUpstreamOuterContextCCPserverBoundLogsPush(conduit); // Once we receive the first ACK, setup our upstream API client and establish\n    // the SYN/ACK refresh flow.\n\n    conduit.onUpstream(connect.EventType.ACKNOWLEDGE, function (data) {\n      connect.getLog().info(\"Acknowledged by the CCP!\").sendInternalLogToServer();\n      connect.core.client = new connect.UpstreamConduitClient(conduit);\n      connect.core.masterClient = new connect.UpstreamConduitMasterClient(conduit);\n      connect.core.portStreamId = data.id;\n\n      if (params.softphone || params.chat || params.pageOptions) {\n        // Send configuration up to the CCP.\n        //set it to false if secondary\n        conduit.sendUpstream(connect.EventType.CONFIGURE, {\n          softphone: params.softphone,\n          chat: params.chat,\n          pageOptions: params.pageOptions\n        });\n      }\n\n      if (connect.core.ccpLoadTimeoutInstance) {\n        global.clearTimeout(connect.core.ccpLoadTimeoutInstance);\n        connect.core.ccpLoadTimeoutInstance = null;\n      }\n\n      conduit.sendUpstream(connect.EventType.OUTER_CONTEXT_INFO, {\n        streamsVersion: connect.version\n      });\n      connect.core.keepaliveManager.start();\n      this.unsubscribe();\n      connect.core.initialized = true;\n      connect.core.getEventBus().trigger(connect.EventType.INIT);\n    }); // Add any logs from the upstream to our own logger.\n\n    conduit.onUpstream(connect.EventType.LOG, function (logEntry) {\n      if (logEntry.loggerId !== connect.getLog().getLoggerId()) {\n        connect.getLog().addLogEntry(connect.LogEntry.fromObject(logEntry));\n      }\n    }); // Pop a login page when we encounter an ACK timeout.\n\n    connect.core.getEventBus().subscribe(connect.EventType.ACK_TIMEOUT, function () {\n      // loginPopup is true by default, only false if explicitly set to false.\n      if (params.loginPopup !== false) {\n        try {\n          var loginUrl = getLoginUrl(params);\n          connect.getLog().warn(\"ACK_TIMEOUT occurred, attempting to pop the login page if not already open.\").sendInternalLogToServer(); // clear out last opened timestamp for SAML authentication when there is ACK_TIMEOUT\n\n          if (params.loginUrl) {\n            connect.core.getPopupManager().clear(connect.MasterTopics.LOGIN_POPUP);\n          }\n\n          connect.core.loginWindow = connect.core.getPopupManager().open(loginUrl, connect.MasterTopics.LOGIN_POPUP, params.loginOptions);\n        } catch (e) {\n          connect.getLog().error(\"ACK_TIMEOUT occurred but we are unable to open the login popup.\").withException(e).sendInternalLogToServer();\n        }\n      }\n\n      if (connect.core.iframeRefreshInterval == null) {\n        connect.core.iframeRefreshInterval = window.setInterval(function () {\n          iframe.src = params.ccpUrl;\n        }, CCP_IFRAME_REFRESH_INTERVAL);\n        conduit.onUpstream(connect.EventType.ACKNOWLEDGE, function () {\n          this.unsubscribe();\n          global.clearInterval(connect.core.iframeRefreshInterval);\n          connect.core.iframeRefreshInterval = null;\n          connect.core.getPopupManager().clear(connect.MasterTopics.LOGIN_POPUP);\n\n          if ((params.loginPopupAutoClose || params.loginOptions && params.loginOptions.autoClose) && connect.core.loginWindow) {\n            connect.core.loginWindow.close();\n            connect.core.loginWindow = null;\n          }\n        });\n      }\n    });\n\n    if (params.onViewContact) {\n      connect.core.onViewContact(params.onViewContact);\n    }\n\n    conduit.onUpstream(connect.EventType.UPDATE_CONNECTED_CCPS, function (data) {\n      connect.numberOfConnectedCCPs = data.length;\n    });\n    conduit.onUpstream(connect.VoiceIdEvents.UPDATE_DOMAIN_ID, function (data) {\n      if (data && data.domainId) {\n        connect.core.voiceIdDomainId = data.domainId;\n      }\n    }); // keep the softphone params for external use\n\n    connect.core.softphoneParams = params.softphone;\n  };\n  /**-----------------------------------------------------------------------*/\n\n\n  var KeepaliveManager = function (conduit, eventBus, synTimeout, ackTimeout) {\n    this.conduit = conduit;\n    this.eventBus = eventBus;\n    this.synTimeout = synTimeout;\n    this.ackTimeout = ackTimeout;\n    this.ackTimer = null;\n    this.synTimer = null;\n    this.ackSub = null;\n  };\n\n  KeepaliveManager.prototype.start = function () {\n    var self = this;\n    this.conduit.sendUpstream(connect.EventType.SYNCHRONIZE);\n    this.ackSub = this.conduit.onUpstream(connect.EventType.ACKNOWLEDGE, function () {\n      this.unsubscribe();\n      global.clearTimeout(self.ackTimer);\n\n      self._deferStart();\n    });\n    this.ackTimer = global.setTimeout(function () {\n      self.ackSub.unsubscribe();\n      self.eventBus.trigger(connect.EventType.ACK_TIMEOUT);\n\n      self._deferStart();\n    }, this.ackTimeout);\n  }; //Fixes the keepalivemanager.\n\n\n  KeepaliveManager.prototype._deferStart = function () {\n    this.synTimer = global.setTimeout(connect.hitch(this, this.start), this.synTimeout);\n  }; // For backwards compatibility only, in case customers are using this to start the keepalivemanager for some reason.\n\n\n  KeepaliveManager.prototype.deferStart = function () {\n    if (this.synTimer == null) {\n      this.synTimer = global.setTimeout(connect.hitch(this, this.start), this.synTimeout);\n    }\n  };\n  /**-----------------------------------------------------------------------*/\n\n\n  var WebSocketProvider = function () {\n    var callbacks = {\n      initFailure: new Set(),\n      subscriptionUpdate: new Set(),\n      subscriptionFailure: new Set(),\n      topic: new Map(),\n      allMessage: new Set(),\n      connectionGain: new Set(),\n      connectionLost: new Set(),\n      connectionOpen: new Set(),\n      connectionClose: new Set()\n    };\n\n    var invokeCallbacks = function (callbacks, response) {\n      callbacks.forEach(function (callback) {\n        callback(response);\n      });\n    };\n\n    connect.core.getUpstream().onUpstream(connect.WebSocketEvents.INIT_FAILURE, function () {\n      invokeCallbacks(callbacks.initFailure);\n    });\n    connect.core.getUpstream().onUpstream(connect.WebSocketEvents.CONNECTION_OPEN, function (response) {\n      invokeCallbacks(callbacks.connectionOpen, response);\n    });\n    connect.core.getUpstream().onUpstream(connect.WebSocketEvents.CONNECTION_CLOSE, function (response) {\n      invokeCallbacks(callbacks.connectionClose, response);\n    });\n    connect.core.getUpstream().onUpstream(connect.WebSocketEvents.CONNECTION_GAIN, function () {\n      invokeCallbacks(callbacks.connectionGain);\n    });\n    connect.core.getUpstream().onUpstream(connect.WebSocketEvents.CONNECTION_LOST, function (response) {\n      invokeCallbacks(callbacks.connectionLost, response);\n    });\n    connect.core.getUpstream().onUpstream(connect.WebSocketEvents.SUBSCRIPTION_UPDATE, function (response) {\n      invokeCallbacks(callbacks.subscriptionUpdate, response);\n    });\n    connect.core.getUpstream().onUpstream(connect.WebSocketEvents.SUBSCRIPTION_FAILURE, function (response) {\n      invokeCallbacks(callbacks.subscriptionFailure, response);\n    });\n    connect.core.getUpstream().onUpstream(connect.WebSocketEvents.ALL_MESSAGE, function (response) {\n      invokeCallbacks(callbacks.allMessage, response);\n\n      if (callbacks.topic.has(response.topic)) {\n        invokeCallbacks(callbacks.topic.get(response.topic), response);\n      }\n    });\n\n    this.sendMessage = function (webSocketPayload) {\n      connect.core.getUpstream().sendUpstream(connect.WebSocketEvents.SEND, webSocketPayload);\n    };\n\n    this.onInitFailure = function (cb) {\n      connect.assertTrue(connect.isFunction(cb), 'method must be a function');\n      callbacks.initFailure.add(cb);\n      return function () {\n        return callbacks.initFailure.delete(cb);\n      };\n    };\n\n    this.onConnectionOpen = function (cb) {\n      connect.assertTrue(connect.isFunction(cb), 'method must be a function');\n      callbacks.connectionOpen.add(cb);\n      return function () {\n        return callbacks.connectionOpen.delete(cb);\n      };\n    };\n\n    this.onConnectionClose = function (cb) {\n      connect.assertTrue(connect.isFunction(cb), 'method must be a function');\n      callbacks.connectionClose.add(cb);\n      return function () {\n        return callbacks.connectionClose.delete(cb);\n      };\n    };\n\n    this.onConnectionGain = function (cb) {\n      connect.assertTrue(connect.isFunction(cb), 'method must be a function');\n      callbacks.connectionGain.add(cb);\n      return function () {\n        return callbacks.connectionGain.delete(cb);\n      };\n    };\n\n    this.onConnectionLost = function (cb) {\n      connect.assertTrue(connect.isFunction(cb), 'method must be a function');\n      callbacks.connectionLost.add(cb);\n      return function () {\n        return callbacks.connectionLost.delete(cb);\n      };\n    };\n\n    this.onSubscriptionUpdate = function (cb) {\n      connect.assertTrue(connect.isFunction(cb), 'method must be a function');\n      callbacks.subscriptionUpdate.add(cb);\n      return function () {\n        return callbacks.subscriptionUpdate.delete(cb);\n      };\n    };\n\n    this.onSubscriptionFailure = function (cb) {\n      connect.assertTrue(connect.isFunction(cb), 'method must be a function');\n      callbacks.subscriptionFailure.add(cb);\n      return function () {\n        return callbacks.subscriptionFailure.delete(cb);\n      };\n    };\n\n    this.subscribeTopics = function (topics) {\n      connect.assertNotNull(topics, 'topics');\n      connect.assertTrue(connect.isArray(topics), 'topics must be a array');\n      connect.core.getUpstream().sendUpstream(connect.WebSocketEvents.SUBSCRIBE, topics);\n    };\n\n    this.onMessage = function (topicName, cb) {\n      connect.assertNotNull(topicName, 'topicName');\n      connect.assertTrue(connect.isFunction(cb), 'method must be a function');\n\n      if (callbacks.topic.has(topicName)) {\n        callbacks.topic.get(topicName).add(cb);\n      } else {\n        callbacks.topic.set(topicName, new Set([cb]));\n      }\n\n      return function () {\n        return callbacks.topic.get(topicName).delete(cb);\n      };\n    };\n\n    this.onAllMessage = function (cb) {\n      connect.assertTrue(connect.isFunction(cb), 'method must be a function');\n      callbacks.allMessage.add(cb);\n      return function () {\n        return callbacks.allMessage.delete(cb);\n      };\n    };\n  };\n  /**-----------------------------------------------------------------------*/\n\n\n  var AgentDataProvider = function (bus) {\n    var agentData = null;\n    this.bus = bus;\n    this.bus.subscribe(connect.AgentEvents.UPDATE, connect.hitch(this, this.updateAgentData));\n  };\n\n  AgentDataProvider.prototype.updateAgentData = function (agentData) {\n    var oldAgentData = this.agentData;\n    this.agentData = agentData;\n\n    if (oldAgentData == null) {\n      connect.agent.initialized = true;\n      this.bus.trigger(connect.AgentEvents.INIT, new connect.Agent());\n    }\n\n    this.bus.trigger(connect.AgentEvents.REFRESH, new connect.Agent());\n\n    this._fireAgentUpdateEvents(oldAgentData);\n  };\n\n  AgentDataProvider.prototype.getAgentData = function () {\n    if (this.agentData == null) {\n      throw new connect.StateError('No agent data is available yet!');\n    }\n\n    return this.agentData;\n  };\n\n  AgentDataProvider.prototype.getContactData = function (contactId) {\n    var agentData = this.getAgentData();\n    var contactData = connect.find(agentData.snapshot.contacts, function (ctdata) {\n      return ctdata.contactId === contactId;\n    });\n\n    if (contactData == null) {\n      throw new connect.StateError('Contact %s no longer exists.', contactId);\n    }\n\n    return contactData;\n  };\n\n  AgentDataProvider.prototype.getConnectionData = function (contactId, connectionId) {\n    var contactData = this.getContactData(contactId);\n    var connectionData = connect.find(contactData.connections, function (cdata) {\n      return cdata.connectionId === connectionId;\n    });\n\n    if (connectionData == null) {\n      throw new connect.StateError('Connection %s for contact %s no longer exists.', connectionId, contactId);\n    }\n\n    return connectionData;\n  };\n\n  AgentDataProvider.prototype.getInstanceId = function () {\n    return this.getAgentData().configuration.routingProfile.routingProfileId.match(/instance\\/([0-9a-fA-F|-]+)\\//)[1];\n  };\n\n  AgentDataProvider.prototype.getAWSAccountId = function () {\n    return this.getAgentData().configuration.routingProfile.routingProfileId.match(/:([0-9]+):instance/)[1];\n  };\n\n  AgentDataProvider.prototype._diffContacts = function (oldAgentData) {\n    var diff = {\n      added: {},\n      removed: {},\n      common: {},\n      oldMap: connect.index(oldAgentData == null ? [] : oldAgentData.snapshot.contacts, function (contact) {\n        return contact.contactId;\n      }),\n      newMap: connect.index(this.agentData.snapshot.contacts, function (contact) {\n        return contact.contactId;\n      })\n    };\n    connect.keys(diff.oldMap).forEach(function (contactId) {\n      if (connect.contains(diff.newMap, contactId)) {\n        diff.common[contactId] = diff.newMap[contactId];\n      } else {\n        diff.removed[contactId] = diff.oldMap[contactId];\n      }\n    });\n    connect.keys(diff.newMap).forEach(function (contactId) {\n      if (!connect.contains(diff.oldMap, contactId)) {\n        diff.added[contactId] = diff.newMap[contactId];\n      }\n    });\n    return diff;\n  };\n\n  AgentDataProvider.prototype._fireAgentUpdateEvents = function (oldAgentData) {\n    var self = this;\n    var diff = null;\n    var oldAgentState = oldAgentData == null ? connect.AgentAvailStates.INIT : oldAgentData.snapshot.state.name;\n    var newAgentState = this.agentData.snapshot.state.name;\n    var oldRoutingState = oldAgentData == null ? connect.AgentStateType.INIT : oldAgentData.snapshot.state.type;\n    var newRoutingState = this.agentData.snapshot.state.type;\n\n    if (oldRoutingState !== newRoutingState) {\n      connect.core.getAgentRoutingEventGraph().getAssociations(this, oldRoutingState, newRoutingState).forEach(function (event) {\n        self.bus.trigger(event, new connect.Agent());\n      });\n    }\n\n    if (oldAgentState !== newAgentState) {\n      this.bus.trigger(connect.AgentEvents.STATE_CHANGE, {\n        agent: new connect.Agent(),\n        oldState: oldAgentState,\n        newState: newAgentState\n      });\n      connect.core.getAgentStateEventGraph().getAssociations(this, oldAgentState, newAgentState).forEach(function (event) {\n        self.bus.trigger(event, new connect.Agent());\n      });\n    }\n\n    var oldNextState = oldAgentData && oldAgentData.snapshot.nextState ? oldAgentData.snapshot.nextState.name : null;\n    var newNextState = this.agentData.snapshot.nextState ? this.agentData.snapshot.nextState.name : null;\n\n    if (oldNextState !== newNextState && newNextState) {\n      self.bus.trigger(connect.AgentEvents.ENQUEUED_NEXT_STATE, new connect.Agent());\n    }\n\n    if (oldAgentData !== null) {\n      diff = this._diffContacts(oldAgentData);\n    } else {\n      diff = {\n        added: connect.index(this.agentData.snapshot.contacts, function (contact) {\n          return contact.contactId;\n        }),\n        removed: {},\n        common: {},\n        oldMap: {},\n        newMap: connect.index(this.agentData.snapshot.contacts, function (contact) {\n          return contact.contactId;\n        })\n      };\n    }\n\n    connect.values(diff.added).forEach(function (contactData) {\n      self.bus.trigger(connect.ContactEvents.INIT, new connect.Contact(contactData.contactId));\n\n      self._fireContactUpdateEvents(contactData.contactId, connect.ContactStateType.INIT, contactData.state.type);\n    });\n    connect.values(diff.removed).forEach(function (contactData) {\n      self.bus.trigger(connect.ContactEvents.DESTROYED, new connect.ContactSnapshot(contactData));\n      self.bus.trigger(connect.core.getContactEventName(connect.ContactEvents.DESTROYED, contactData.contactId), new connect.ContactSnapshot(contactData));\n\n      self._unsubAllContactEventsForContact(contactData.contactId);\n    });\n    connect.keys(diff.common).forEach(function (contactId) {\n      self._fireContactUpdateEvents(contactId, diff.oldMap[contactId].state.type, diff.newMap[contactId].state.type);\n    });\n  };\n\n  AgentDataProvider.prototype._fireContactUpdateEvents = function (contactId, oldContactState, newContactState) {\n    var self = this;\n\n    if (oldContactState !== newContactState) {\n      connect.core.getContactEventGraph().getAssociations(this, oldContactState, newContactState).forEach(function (event) {\n        self.bus.trigger(event, new connect.Contact(contactId));\n        self.bus.trigger(connect.core.getContactEventName(event, contactId), new connect.Contact(contactId));\n      });\n    }\n\n    self.bus.trigger(connect.ContactEvents.REFRESH, new connect.Contact(contactId));\n    self.bus.trigger(connect.core.getContactEventName(connect.ContactEvents.REFRESH, contactId), new connect.Contact(contactId));\n  };\n\n  AgentDataProvider.prototype._unsubAllContactEventsForContact = function (contactId) {\n    var self = this;\n    connect.values(connect.ContactEvents).forEach(function (eventName) {\n      self.bus.getSubscriptions(connect.core.getContactEventName(eventName, contactId)).map(function (sub) {\n        sub.unsubscribe();\n      });\n    });\n  };\n  /** ----- minimal view layer event handling **/\n\n\n  connect.core.onViewContact = function (f) {\n    connect.core.getUpstream().onUpstream(connect.ContactEvents.VIEW, f);\n  };\n  /**\n   * Used of agent interface control. \n   * connect.core.viewContact(\"contactId\") ->  this is curently programmed to get the contact into view.\n   */\n\n\n  connect.core.viewContact = function (contactId) {\n    connect.core.getUpstream().sendUpstream(connect.EventType.BROADCAST, {\n      event: connect.ContactEvents.VIEW,\n      data: {\n        contactId: contactId\n      }\n    });\n  };\n  /** ----- minimal view layer event handling **/\n\n\n  connect.core.onActivateChannelWithViewType = function (f) {\n    connect.core.getUpstream().onUpstream(connect.ChannelViewEvents.ACTIVATE_CHANNEL_WITH_VIEW_TYPE, f);\n  };\n  /**\n   * Used of agent interface control. \n   * connect.core.activateChannelWithViewType() ->  this is curently programmed to get either the number pad, quick connects, or create task into view.\n   * the valid combinations are (\"create_task\", \"task\"), (\"number_pad\", \"softphone\"), (\"create_task\", \"softphone\"), (\"quick_connects\", \"softphone\")\n   * the softphone with create_task combo is a special case in the channel view to allow all three view type buttons to appear on the softphone screen\n   */\n\n\n  connect.core.activateChannelWithViewType = function (viewType, mediaType) {\n    connect.core.getUpstream().sendUpstream(connect.EventType.BROADCAST, {\n      event: connect.ChannelViewEvents.ACTIVATE_CHANNEL_WITH_VIEW_TYPE,\n      data: {\n        viewType: viewType,\n        mediaType: mediaType\n      }\n    });\n  };\n  /**\n   * Used to publish 'task created' event\n   */\n\n\n  connect.core.triggerTaskCreated = function (data) {\n    connect.core.getUpstream().upstreamBus.trigger(connect.TaskEvents.CREATED, data);\n  };\n  /** ------------------------------------------------- */\n\n  /**\n  * This will be helpful for the custom and embedded CCPs \n  * to handle the access denied use case. \n  */\n\n\n  connect.core.onAccessDenied = function (f) {\n    connect.core.getUpstream().onUpstream(connect.EventType.ACCESS_DENIED, f);\n  };\n  /**\n  * This will be helpful for SAML use cases to handle the custom logins. \n  */\n\n\n  connect.core.onAuthFail = function (f) {\n    connect.core.getUpstream().onUpstream(connect.EventType.AUTH_FAIL, f);\n  };\n  /** ------------------------------------------------- */\n\n  /**\n   * Used for handling the rtc session stats.\n   * Usage\n   * connect.core.onSoftphoneSessionInit(function({ connectionId }) {\n   *     var softphoneManager = connect.core.getSoftphoneManager();\n   *     if(softphoneManager){\n   *        // access session\n   *        var session = softphoneManager.getSession(connectionId); \n   *      }\n   * });\n   */\n\n\n  connect.core.onSoftphoneSessionInit = function (f) {\n    connect.core.getUpstream().onUpstream(connect.ConnectionEvents.SESSION_INIT, f);\n  };\n  /**-----------------------------------------------------------------------*/\n\n\n  connect.core.onConfigure = function (f) {\n    connect.core.getUpstream().onUpstream(connect.ConfigurationEvents.CONFIGURE, f);\n  };\n  /**-----------------------------------------------------------------------*/\n\n\n  connect.core.onInitialized = function (f) {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(connect.EventType.INIT, f);\n  };\n  /**-----------------------------------------------------------------------*/\n\n\n  connect.core.getContactEventName = function (eventName, contactId) {\n    connect.assertNotNull(eventName, 'eventName');\n    connect.assertNotNull(contactId, 'contactId');\n\n    if (!connect.contains(connect.values(connect.ContactEvents), eventName)) {\n      throw new connect.ValueError('%s is not a valid contact event.', eventName);\n    }\n\n    return connect.sprintf('%s::%s', eventName, contactId);\n  };\n  /**-----------------------------------------------------------------------*/\n\n\n  connect.core.getEventBus = function () {\n    return connect.core.eventBus;\n  };\n  /**-----------------------------------------------------------------------*/\n\n\n  connect.core.getWebSocketManager = function () {\n    return connect.core.webSocketProvider;\n  };\n  /**-----------------------------------------------------------------------*/\n\n\n  connect.core.getAgentDataProvider = function () {\n    return connect.core.agentDataProvider;\n  };\n  /**-----------------------------------------------------------------------*/\n\n\n  connect.core.getLocalTimestamp = function () {\n    return connect.core.getAgentDataProvider().getAgentData().snapshot.localTimestamp;\n  };\n  /**-----------------------------------------------------------------------*/\n\n\n  connect.core.getSkew = function () {\n    return connect.core.getAgentDataProvider().getAgentData().snapshot.skew;\n  };\n  /**-----------------------------------------------------------------------*/\n\n\n  connect.core.getAgentRoutingEventGraph = function () {\n    return connect.core.agentRoutingEventGraph;\n  };\n\n  connect.core.agentRoutingEventGraph = new connect.EventGraph().assoc(connect.EventGraph.ANY, connect.AgentStateType.ROUTABLE, connect.AgentEvents.ROUTABLE).assoc(connect.EventGraph.ANY, connect.AgentStateType.NOT_ROUTABLE, connect.AgentEvents.NOT_ROUTABLE).assoc(connect.EventGraph.ANY, connect.AgentStateType.OFFLINE, connect.AgentEvents.OFFLINE);\n  /**-----------------------------------------------------------------------*/\n\n  connect.core.getAgentStateEventGraph = function () {\n    return connect.core.agentStateEventGraph;\n  };\n\n  connect.core.agentStateEventGraph = new connect.EventGraph().assoc(connect.EventGraph.ANY, connect.values(connect.AgentErrorStates), connect.AgentEvents.ERROR).assoc(connect.EventGraph.ANY, connect.AgentAvailStates.AFTER_CALL_WORK, connect.AgentEvents.ACW);\n  /**-----------------------------------------------------------------------*/\n\n  connect.core.getContactEventGraph = function () {\n    return connect.core.contactEventGraph;\n  };\n\n  connect.core.contactEventGraph = new connect.EventGraph().assoc(connect.EventGraph.ANY, connect.ContactStateType.INCOMING, connect.ContactEvents.INCOMING).assoc(connect.EventGraph.ANY, connect.ContactStateType.PENDING, connect.ContactEvents.PENDING).assoc(connect.EventGraph.ANY, connect.ContactStateType.CONNECTING, connect.ContactEvents.CONNECTING).assoc(connect.EventGraph.ANY, connect.ContactStateType.CONNECTED, connect.ContactEvents.CONNECTED).assoc(connect.ContactStateType.CONNECTING, connect.ContactStateType.ERROR, connect.ContactEvents.MISSED).assoc(connect.ContactStateType.INCOMING, connect.ContactStateType.ERROR, connect.ContactEvents.MISSED).assoc(connect.EventGraph.ANY, connect.ContactStateType.ENDED, connect.ContactEvents.ACW).assoc(connect.values(connect.CONTACT_ACTIVE_STATES), connect.values(connect.relativeComplement(connect.CONTACT_ACTIVE_STATES, connect.ContactStateType)), connect.ContactEvents.ENDED).assoc(connect.EventGraph.ANY, connect.values(connect.AgentErrorStates), connect.ContactEvents.ERROR).assoc(connect.ContactStateType.CONNECTING, connect.ContactStateType.MISSED, connect.ContactEvents.MISSED);\n  /**-----------------------------------------------------------------------*/\n\n  connect.core.getClient = function () {\n    if (!connect.core.client) {\n      throw new connect.StateError('The connect core has not been initialized!');\n    }\n\n    return connect.core.client;\n  };\n\n  connect.core.client = null;\n  /**-----------------------------------------------------------------------*/\n\n  connect.core.getAgentAppClient = function () {\n    if (!connect.core.agentAppClient) {\n      throw new connect.StateError('The connect AgentApp Client has not been initialized!');\n    }\n\n    return connect.core.agentAppClient;\n  };\n\n  connect.core.agentAppClient = null;\n  /**-----------------------------------------------------------------------*/\n\n  connect.core.getMasterClient = function () {\n    if (!connect.core.masterClient) {\n      throw new connect.StateError('The connect master client has not been initialized!');\n    }\n\n    return connect.core.masterClient;\n  };\n\n  connect.core.masterClient = null;\n  /**-----------------------------------------------------------------------*/\n\n  connect.core.getSoftphoneManager = function () {\n    return connect.core.softphoneManager;\n  };\n\n  connect.core.softphoneManager = null;\n  /**-----------------------------------------------------------------------*/\n\n  connect.core.getNotificationManager = function () {\n    if (!connect.core.notificationManager) {\n      connect.core.notificationManager = new connect.NotificationManager();\n    }\n\n    return connect.core.notificationManager;\n  };\n\n  connect.core.notificationManager = null;\n  /**-----------------------------------------------------------------------*/\n\n  connect.core.getPopupManager = function () {\n    return connect.core.popupManager;\n  };\n\n  connect.core.popupManager = new connect.PopupManager();\n  /**-----------------------------------------------------------------------*/\n\n  connect.core.getUpstream = function () {\n    if (!connect.core.upstream) {\n      throw new connect.StateError('There is no upstream conduit!');\n    }\n\n    return connect.core.upstream;\n  };\n\n  connect.core.upstream = null;\n  /**-----------------------------------------------------------------------*/\n\n  connect.core.AgentDataProvider = AgentDataProvider;\n})();\n/*\n * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\n(function () {\n  var global = this;\n  var connect = global.connect || {};\n  global.connect = connect;\n  global.lily = connect;\n\n  var RingtoneEngineBase = function (ringtoneConfig) {\n    var self = this;\n    this._prevContactId = null;\n    connect.assertNotNull(ringtoneConfig, \"ringtoneConfig\");\n\n    if (!ringtoneConfig.ringtoneUrl) {\n      throw new Error(\"ringtoneUrl is required!\");\n    }\n\n    if (global.Audio && typeof global.Promise !== \"undefined\") {\n      this._playableAudioPromise = new Promise(function (resolve, reject) {\n        self._audio = new Audio(ringtoneConfig.ringtoneUrl);\n        self._audio.loop = true;\n\n        self._audio.addEventListener(\"canplay\", function () {\n          self._audioPlayable = true;\n          resolve(self._audio);\n        });\n      });\n    } else {\n      this._audio = null;\n      connect.getLog().error(\"Unable to provide a ringtone.\").sendInternalLogToServer();\n    }\n\n    self._driveRingtone();\n  };\n\n  RingtoneEngineBase.prototype._driveRingtone = function () {\n    throw new Error(\"Not implemented.\");\n  };\n\n  RingtoneEngineBase.prototype._startRingtone = function (contact) {\n    if (this._audio) {\n      this._audio.play().catch(function (e) {\n        this._publishTelemetryEvent(\"Ringtone Playback Failure\", contact);\n\n        connect.getLog().error(\"Ringtone Playback Failure\").sendInternalLogToServer();\n      });\n\n      this._publishTelemetryEvent(\"Ringtone Start\", contact);\n\n      connect.getLog().info(\"Ringtone Start\").sendInternalLogToServer();\n    }\n  };\n\n  RingtoneEngineBase.prototype._stopRingtone = function (contact) {\n    if (this._audio) {\n      this._audio.pause();\n\n      this._audio.currentTime = 0;\n\n      this._publishTelemetryEvent(\"Ringtone Stop\", contact);\n\n      connect.getLog().info(\"Ringtone Stop\").sendInternalLogToServer();\n    }\n  };\n  /**\n   * Stop ringtone.\n   */\n\n\n  RingtoneEngineBase.prototype.stopRingtone = function () {\n    this._stopRingtone();\n  };\n\n  RingtoneEngineBase.prototype._ringtoneSetup = function (contact) {\n    var self = this;\n    connect.ifMaster(connect.MasterTopics.RINGTONE, function () {\n      self._startRingtone(contact);\n\n      self._prevContactId = contact.getContactId();\n      contact.onConnected(lily.hitch(self, self._stopRingtone));\n      contact.onAccepted(lily.hitch(self, self._stopRingtone));\n      contact.onEnded(lily.hitch(self, self._stopRingtone)); // Just to make sure to stop the ringtone in case of the failures of specific callbacks(onAccepted,onConnected);\n\n      contact.onRefresh(function (contact) {\n        if (contact.getStatus().type !== connect.ContactStatusType.CONNECTING && contact.getStatus().type !== connect.ContactStatusType.INCOMING) {\n          self._stopRingtone();\n        }\n      });\n    });\n  };\n\n  RingtoneEngineBase.prototype._publishTelemetryEvent = function (eventName, contact) {\n    if (contact && contact.getContactId()) {\n      connect.publishMetric({\n        name: eventName,\n        contactId: contact.getContactId()\n      });\n    }\n  };\n  /**\n   * Change the audio device used to play ringtone.\n   * If audio element is not fully initialized, the API will wait _audioPlayablePromise for 3 seconds and fail on timeout.\n   * This API is supported only by browsers that implemented ES6 Promise and http://www.w3.org/TR/audio-output/\n   * Return a Promise that indicates the result of changing output device.\n   */\n\n\n  RingtoneEngineBase.prototype.setOutputDevice = function (deviceId) {\n    if (this._playableAudioPromise) {\n      var playableAudioWithTimeout = Promise.race([this._playableAudioPromise, new Promise(function (resolve, reject) {\n        global.setTimeout(function () {\n          reject(\"Timed out waiting for playable audio\");\n        }, 3000\n        /*ms*/\n        );\n      })]);\n      return playableAudioWithTimeout.then(function (audio) {\n        if (audio) {\n          if (audio.setSinkId) {\n            return Promise.resolve(audio.setSinkId(deviceId));\n          } else {\n            return Promise.reject(\"Not supported\");\n          }\n        } else {\n          return Promise.reject(\"No audio found\");\n        }\n      });\n    }\n\n    if (global.Promise) {\n      return Promise.reject(\"Not eligible ringtone owner\");\n    }\n  };\n\n  var VoiceRingtoneEngine = function (ringtoneConfig) {\n    RingtoneEngineBase.call(this, ringtoneConfig);\n  };\n\n  VoiceRingtoneEngine.prototype = Object.create(RingtoneEngineBase.prototype);\n  VoiceRingtoneEngine.prototype.constructor = VoiceRingtoneEngine;\n\n  VoiceRingtoneEngine.prototype._driveRingtone = function () {\n    var self = this;\n\n    var onContactConnect = function (contact) {\n      if (contact.getType() === lily.ContactType.VOICE && contact.isSoftphoneCall() && contact.isInbound()) {\n        self._ringtoneSetup(contact);\n\n        self._publishTelemetryEvent(\"Ringtone Connecting\", contact);\n\n        connect.getLog().info(\"Ringtone Connecting\").sendInternalLogToServer();\n      }\n    };\n\n    connect.contact(function (contact) {\n      contact.onConnecting(onContactConnect);\n    });\n    new connect.Agent().getContacts().forEach(function (contact) {\n      if (contact.getStatus().type === connect.ContactStatusType.CONNECTING) {\n        onContactConnect(contact);\n      }\n    });\n  };\n\n  var ChatRingtoneEngine = function (ringtoneConfig) {\n    RingtoneEngineBase.call(this, ringtoneConfig);\n  };\n\n  ChatRingtoneEngine.prototype = Object.create(RingtoneEngineBase.prototype);\n  ChatRingtoneEngine.prototype.constructor = ChatRingtoneEngine;\n\n  ChatRingtoneEngine.prototype._driveRingtone = function () {\n    var self = this;\n\n    var onContactConnect = function (contact) {\n      if (contact.getType() === lily.ContactType.CHAT && contact.isInbound()) {\n        self._ringtoneSetup(contact);\n\n        self._publishTelemetryEvent(\"Chat Ringtone Connecting\", contact);\n\n        connect.getLog().info(\"Chat Ringtone Connecting\").sendInternalLogToServer();\n      }\n    };\n\n    connect.contact(function (contact) {\n      contact.onConnecting(onContactConnect);\n    });\n  };\n\n  var TaskRingtoneEngine = function (ringtoneConfig) {\n    RingtoneEngineBase.call(this, ringtoneConfig);\n  };\n\n  TaskRingtoneEngine.prototype = Object.create(RingtoneEngineBase.prototype);\n  TaskRingtoneEngine.prototype.constructor = TaskRingtoneEngine;\n\n  TaskRingtoneEngine.prototype._driveRingtone = function () {\n    var self = this;\n\n    var onContactConnect = function (contact) {\n      if (contact.getType() === lily.ContactType.TASK && contact.isInbound()) {\n        self._ringtoneSetup(contact);\n\n        self._publishTelemetryEvent(\"Task Ringtone Connecting\", contact);\n\n        connect.getLog().info(\"Task Ringtone Connecting\").sendInternalLogToServer();\n      }\n    };\n\n    connect.contact(function (contact) {\n      contact.onConnecting(onContactConnect);\n    });\n  };\n\n  var QueueCallbackRingtoneEngine = function (ringtoneConfig) {\n    RingtoneEngineBase.call(this, ringtoneConfig);\n  };\n\n  QueueCallbackRingtoneEngine.prototype = Object.create(RingtoneEngineBase.prototype);\n  QueueCallbackRingtoneEngine.prototype.constructor = QueueCallbackRingtoneEngine;\n\n  QueueCallbackRingtoneEngine.prototype._driveRingtone = function () {\n    var self = this;\n    connect.contact(function (contact) {\n      contact.onIncoming(function () {\n        if (contact.getType() === lily.ContactType.QUEUE_CALLBACK) {\n          self._ringtoneSetup(contact);\n\n          self._publishTelemetryEvent(\"Callback Ringtone Connecting\", contact);\n\n          connect.getLog().info(\"Callback Ringtone Connecting\").sendInternalLogToServer();\n        }\n      });\n    });\n  };\n  /* export connect.RingtoneEngine */\n\n\n  connect.VoiceRingtoneEngine = VoiceRingtoneEngine;\n  connect.ChatRingtoneEngine = ChatRingtoneEngine;\n  connect.TaskRingtoneEngine = TaskRingtoneEngine;\n  connect.QueueCallbackRingtoneEngine = QueueCallbackRingtoneEngine;\n})();\n/*\n * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\n(function () {\n  var global = this;\n  connect = global.connect || {};\n  global.connect = connect;\n  global.lily = connect;\n  global.ccpVersion = \"V2\";\n  var RTPJobIntervalMs = 1000;\n  var statsReportingJobIntervalMs = 30000;\n  var streamBufferSize = 500;\n  var CallTypeMap = {};\n  CallTypeMap[connect.SoftphoneCallType.AUDIO_ONLY] = 'Audio';\n  CallTypeMap[connect.SoftphoneCallType.VIDEO_ONLY] = 'Video';\n  CallTypeMap[connect.SoftphoneCallType.AUDIO_VIDEO] = 'AudioVideo';\n  CallTypeMap[connect.SoftphoneCallType.NONE] = 'None';\n  var AUDIO_INPUT = 'audio_input';\n  var AUDIO_OUTPUT = 'audio_output';\n  var MediaTypeMap = {};\n  MediaTypeMap[connect.ContactType.VOICE] = \"Voice\";\n  var UNKNOWN_MEDIA_TYPE = \"Unknown\";\n  var timeSeriesStreamStatsBuffer = [];\n  var aggregatedUserAudioStats = {};\n  var aggregatedRemoteAudioStats = {};\n  var rtpStatsJob = null;\n  var reportStatsJob = null; //Logger specific to softphone.\n\n  var logger = null;\n  var SoftphoneErrorTypes = connect.SoftphoneErrorTypes;\n  var HANG_UP_MULTIPLE_SESSIONS_EVENT = \"MultiSessionHangUp\";\n  var MULTIPLE_SESSIONS_EVENT = \"MultiSessions\";\n  var localMediaStream = {};\n  var softphoneClientId = connect.randomId();\n\n  var requestIceAccess = function (transport) {\n    return new Promise(function (resolve, reject) {\n      connect.core.getClient().call(connect.ClientMethods.CREATE_TRANSPORT, transport, {\n        success: function (data) {\n          resolve(data.softphoneTransport.softphoneMediaConnections);\n        },\n        failure: function (reason) {\n          if (reason.message && reason.message.includes(\"SoftphoneConnectionLimitBreachedException\")) {\n            publishError(\"multiple_softphone_active_sessions\", \"Number of active sessions are more then allowed limit.\", \"\");\n          }\n\n          reject(Error(\"requestIceAccess failed\"));\n        },\n        authFailure: function () {\n          reject(Error(\"Authentication failed while requestIceAccess\"));\n        },\n        accessDenied: function () {\n          reject(Error(\"Access Denied while requestIceAccess\"));\n        }\n      });\n    });\n  };\n\n  var SoftphoneManager = function (softphoneParams) {\n    var self = this;\n    logger = new SoftphoneLogger(connect.getLog());\n    logger.info(\"[Softphone Manager] softphone manager initialization has begun\").sendInternalLogToServer();\n    var rtcPeerConnectionFactory;\n\n    if (connect.RtcPeerConnectionFactory) {\n      rtcPeerConnectionFactory = new connect.RtcPeerConnectionFactory(logger, connect.core.getWebSocketManager(), softphoneClientId, connect.hitch(self, requestIceAccess, {\n        transportType: \"softphone\",\n        softphoneClientId: softphoneClientId\n      }), connect.hitch(self, publishError));\n    }\n\n    if (!isBrowserSoftPhoneSupported()) {\n      publishError(SoftphoneErrorTypes.UNSUPPORTED_BROWSER, \"Connect does not support this browser. Some functionality may not work. \", \"\");\n    }\n\n    var gumPromise = fetchUserMedia({\n      success: function (stream) {\n        connect.core.setSoftphoneUserMediaStream(stream);\n      },\n      failure: function (err) {\n        publishError(err, \"Your microphone is not enabled in your browser. \", \"\");\n      }\n    });\n    handleSoftPhoneMuteToggle();\n    handleSpeakerDeviceChange();\n    handleMicrophoneDeviceChange();\n    this.ringtoneEngine = null;\n    var rtcSessions = {}; // Tracks the agent connection ID, so that if the same contact gets re-routed to the same agent, it'll still set up softphone\n\n    var callsDetected = {};\n    this.onInitContactSub = {};\n\n    this.onInitContactSub.unsubscribe = function () {}; // variables for firefox multitab\n\n\n    var isSessionPending = false;\n    var pendingContact = null;\n    var pendingAgentConnectionId = null;\n\n    var postponeStartingSession = function (contact, agentConnectionId) {\n      isSessionPending = true;\n      pendingContact = contact;\n      pendingAgentConnectionId = agentConnectionId;\n    };\n\n    var cancelPendingSession = function () {\n      isSessionPending = false;\n      pendingContact = null;\n      pendingAgentConnectionId = null;\n    }; // helper method to provide access to rtc sessions\n\n\n    this.getSession = function (connectionId) {\n      return rtcSessions[connectionId];\n    };\n\n    this.replaceLocalMediaTrack = function (connectionId, track) {\n      var stream = localMediaStream[connectionId].stream;\n\n      if (stream) {\n        var oldTrack = stream.getAudioTracks()[0];\n        track.enabled = oldTrack.enabled;\n        oldTrack.enabled = false;\n        stream.removeTrack(oldTrack);\n        stream.addTrack(track);\n      }\n    };\n\n    var isContactTerminated = function (contact) {\n      return contact.getStatus().type === connect.ContactStatusType.ENDED || contact.getStatus().type === connect.ContactStatusType.ERROR || contact.getStatus().type === connect.ContactStatusType.MISSED;\n    };\n\n    var destroySession = function (agentConnectionId) {\n      if (rtcSessions.hasOwnProperty(agentConnectionId)) {\n        var session = rtcSessions[agentConnectionId]; // Currently the assumption is it will throw an exception only and if only it already has been hung up.\n        // TODO: Update once the hangup API does not throw exceptions\n\n        new Promise(function (resolve, reject) {\n          delete rtcSessions[agentConnectionId];\n          delete callsDetected[agentConnectionId];\n          session.hangup();\n        }).catch(function (err) {\n          lily.getLog().warn(\"Clean up the session locally \" + agentConnectionId, err.message).sendInternalLogToServer();\n        });\n      }\n    }; // When multiple RTC sessions detected, ignore the new call and hang up the previous sessions.\n    // TODO: Update when connect-rtc exposes an API to detect session status.\n\n\n    var sanityCheckActiveSessions = function (rtcSessions) {\n      if (Object.keys(rtcSessions).length > 0) {\n        // Error! our state doesn't match, tear it all down.\n        for (var connectionId in rtcSessions) {\n          if (rtcSessions.hasOwnProperty(connectionId)) {\n            // Log an error for the session we are about to end.\n            publishMultipleSessionsEvent(HANG_UP_MULTIPLE_SESSIONS_EVENT, rtcSessions[connectionId].callId, connectionId);\n            destroySession(connectionId);\n          }\n        }\n\n        throw new Error(\"duplicate session detected, refusing to setup new connection\");\n      }\n    };\n\n    this.startSession = function (_contact, _agentConnectionId) {\n      var contact = isSessionPending ? pendingContact : _contact;\n      var agentConnectionId = isSessionPending ? pendingAgentConnectionId : _agentConnectionId;\n\n      if (!contact || !agentConnectionId) {\n        return;\n      }\n\n      cancelPendingSession(); // Set to true, this will block subsequent invokes from entering.\n\n      callsDetected[agentConnectionId] = true;\n      logger.info(\"Softphone call detected:\", \"contactId \" + contact.getContactId(), \"agent connectionId \" + agentConnectionId).sendInternalLogToServer(); // Ensure our session state matches our contact state to prevent issues should we lose track of a contact.\n\n      sanityCheckActiveSessions(rtcSessions);\n\n      if (contact.getStatus().type === connect.ContactStatusType.CONNECTING) {\n        publishTelemetryEvent(\"Softphone Connecting\", contact.getContactId());\n      }\n\n      initializeParams();\n      var softphoneInfo = contact.getAgentConnection().getSoftphoneMediaInfo();\n      var callConfig = parseCallConfig(softphoneInfo.callConfigJson);\n      var webSocketProvider;\n\n      if (callConfig.useWebSocketProvider) {\n        webSocketProvider = connect.core.getWebSocketManager();\n      }\n\n      var session = new connect.RTCSession(callConfig.signalingEndpoint, callConfig.iceServers, softphoneInfo.callContextToken, logger, contact.getContactId(), agentConnectionId, webSocketProvider);\n      rtcSessions[agentConnectionId] = session;\n\n      if (connect.core.getSoftphoneUserMediaStream()) {\n        session.mediaStream = connect.core.getSoftphoneUserMediaStream();\n      } // Custom Event to indicate the session init operations\n\n\n      connect.core.getUpstream().sendUpstream(connect.EventType.BROADCAST, {\n        event: connect.ConnectionEvents.SESSION_INIT,\n        data: {\n          connectionId: agentConnectionId\n        }\n      });\n\n      session.onSessionFailed = function (rtcSession, reason) {\n        delete rtcSessions[agentConnectionId];\n        delete callsDetected[agentConnectionId];\n        publishSoftphoneFailureLogs(rtcSession, reason);\n        publishSessionFailureTelemetryEvent(contact.getContactId(), reason);\n        stopJobsAndReport(contact, rtcSession.sessionReport);\n      };\n\n      session.onSessionConnected = function (rtcSession) {\n        publishTelemetryEvent(\"Softphone Session Connected\", contact.getContactId()); // Become master to send logs, since we need logs from softphone tab.\n\n        connect.becomeMaster(connect.MasterTopics.SEND_LOGS); //start stats collection and reporting jobs\n\n        startStatsCollectionJob(rtcSession);\n        startStatsReportingJob(contact);\n        fireContactAcceptedEvent(contact);\n      };\n\n      session.onSessionCompleted = function (rtcSession) {\n        publishTelemetryEvent(\"Softphone Session Completed\", contact.getContactId());\n        delete rtcSessions[agentConnectionId];\n        delete callsDetected[agentConnectionId]; // Stop all jobs and perform one last job.\n\n        stopJobsAndReport(contact, rtcSession.sessionReport); // Cleanup the cached streams\n\n        deleteLocalMediaStream(agentConnectionId);\n      };\n\n      session.onLocalStreamAdded = function (rtcSession, stream) {\n        // Cache the streams for mute/unmute\n        localMediaStream[agentConnectionId] = {\n          stream: stream\n        };\n        connect.core.getUpstream().sendUpstream(connect.EventType.BROADCAST, {\n          event: connect.AgentEvents.LOCAL_MEDIA_STREAM_CREATED,\n          data: {\n            connectionId: agentConnectionId\n          }\n        });\n      };\n\n      session.remoteAudioElement = document.getElementById('remote-audio');\n\n      if (rtcPeerConnectionFactory) {\n        session.connect(rtcPeerConnectionFactory.get(callConfig.iceServers));\n      } else {\n        session.connect();\n      }\n    };\n\n    var onRefreshContact = function (contact, agentConnectionId) {\n      if (rtcSessions[agentConnectionId] && isContactTerminated(contact)) {\n        destroySession(agentConnectionId);\n        cancelPendingSession();\n      }\n\n      if (contact.isSoftphoneCall() && !callsDetected[agentConnectionId] && (contact.getStatus().type === connect.ContactStatusType.CONNECTING || contact.getStatus().type === connect.ContactStatusType.INCOMING)) {\n        if (connect.isFirefoxBrowser() && connect.hasOtherConnectedCCPs()) {\n          postponeStartingSession(contact, agentConnectionId);\n        } else {\n          self.startSession(contact, agentConnectionId);\n        }\n      }\n    };\n\n    var onInitContact = function (contact) {\n      var agentConnectionId = contact.getAgentConnection().connectionId;\n      logger.info(\"Contact detected:\", \"contactId \" + contact.getContactId(), \"agent connectionId \" + agentConnectionId).sendInternalLogToServer();\n\n      if (!callsDetected[agentConnectionId]) {\n        contact.onRefresh(function () {\n          onRefreshContact(contact, agentConnectionId);\n        });\n      }\n    };\n\n    self.onInitContactSub = connect.contact(onInitContact); // Contact already in connecting state scenario - In this case contact INIT is missed hence the OnRefresh callback is missed. \n\n    new connect.Agent().getContacts().forEach(function (contact) {\n      var agentConnectionId = contact.getAgentConnection().connectionId;\n      logger.info(\"Contact exist in the snapshot. Reinitiate the Contact and RTC session creation for contactId\" + contact.getContactId(), \"agent connectionId \" + agentConnectionId).sendInternalLogToServer();\n      onInitContact(contact);\n      onRefreshContact(contact, agentConnectionId);\n    });\n  };\n\n  var fireContactAcceptedEvent = function (contact) {\n    var conduit = connect.core.getUpstream();\n    var agentConnection = contact.getAgentConnection();\n\n    if (!agentConnection) {\n      logger.info(\"Not able to retrieve the auto-accept setting from null AgentConnection, ignoring event publish..\").sendInternalLogToServer();\n      return;\n    }\n\n    var softphoneMediaInfo = agentConnection.getSoftphoneMediaInfo();\n\n    if (!softphoneMediaInfo) {\n      logger.info(\"Not able to retrieve the auto-accept setting from null SoftphoneMediaInfo, ignoring event publish..\").sendInternalLogToServer();\n      return;\n    }\n\n    if (softphoneMediaInfo.autoAccept === true) {\n      logger.info(\"Auto-accept is enabled, sending out Accepted event to stop ringtone..\").sendInternalLogToServer();\n      conduit.sendUpstream(connect.EventType.BROADCAST, {\n        event: connect.ContactEvents.ACCEPTED,\n        data: new connect.Contact(contact.contactId)\n      });\n      conduit.sendUpstream(connect.EventType.BROADCAST, {\n        event: connect.core.getContactEventName(connect.ContactEvents.ACCEPTED, contact.contactId),\n        data: new connect.Contact(contact.contactId)\n      });\n    } else {\n      logger.info(\"Auto-accept is disabled, ringtone will be stopped by user action.\").sendInternalLogToServer();\n    }\n  }; // Bind events for mute\n\n\n  var handleSoftPhoneMuteToggle = function () {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(connect.EventType.MUTE, muteToggle);\n  };\n\n  var handleSpeakerDeviceChange = function () {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(connect.ConfigurationEvents.SET_SPEAKER_DEVICE, setSpeakerDevice);\n  };\n\n  var handleMicrophoneDeviceChange = function () {\n    var bus = connect.core.getEventBus();\n    bus.subscribe(connect.ConfigurationEvents.SET_MICROPHONE_DEVICE, setMicrophoneDevice);\n  }; // Make sure once we disconnected we get the mute state back to normal\n\n\n  var deleteLocalMediaStream = function (connectionId) {\n    delete localMediaStream[connectionId];\n    connect.core.getUpstream().sendUpstream(connect.EventType.BROADCAST, {\n      event: connect.AgentEvents.MUTE_TOGGLE,\n      data: {\n        muted: false\n      }\n    });\n  }; // Check for the local streams if exists  -  revert it\n  // And inform other clients about the change \n\n\n  var muteToggle = function (data) {\n    var status;\n\n    if (connect.keys(localMediaStream).length === 0) {\n      return;\n    }\n\n    if (data && data.mute !== undefined) {\n      status = data.mute;\n    }\n\n    for (var connectionId in localMediaStream) {\n      if (localMediaStream.hasOwnProperty(connectionId)) {\n        var localMedia = localMediaStream[connectionId].stream;\n\n        if (localMedia) {\n          var audioTracks = localMedia.getAudioTracks()[0];\n\n          if (status !== undefined) {\n            audioTracks.enabled = !status;\n            localMediaStream[connectionId].muted = status;\n\n            if (status) {\n              logger.info(\"Agent has muted the contact, connectionId -  \" + connectionId).sendInternalLogToServer();\n            } else {\n              logger.info(\"Agent has unmuted the contact, connectionId - \" + connectionId).sendInternalLogToServer();\n            }\n          } else {\n            status = localMediaStream[connectionId].muted || false;\n          }\n        }\n      }\n    }\n\n    connect.core.getUpstream().sendUpstream(connect.EventType.BROADCAST, {\n      event: connect.AgentEvents.MUTE_TOGGLE,\n      data: {\n        muted: status\n      }\n    });\n  };\n\n  var setSpeakerDevice = function (data) {\n    if (connect.keys(localMediaStream).length === 0 || !data || !data.deviceId) {\n      return;\n    }\n\n    var deviceId = data.deviceId;\n    var remoteAudioElement = document.getElementById('remote-audio');\n\n    try {\n      logger.info(\"Trying to set speaker to device \" + deviceId);\n\n      if (remoteAudioElement && typeof remoteAudioElement.setSinkId === 'function') {\n        remoteAudioElement.setSinkId(deviceId);\n      }\n    } catch (e) {\n      logger.error(\"Failed to set speaker to device \" + deviceId);\n    }\n\n    connect.core.getUpstream().sendUpstream(connect.EventType.BROADCAST, {\n      event: connect.ConfigurationEvents.SPEAKER_DEVICE_CHANGED,\n      data: {\n        deviceId: deviceId\n      }\n    });\n  };\n\n  var setMicrophoneDevice = function (data) {\n    if (connect.keys(localMediaStream).length === 0 || !data || !data.deviceId) {\n      return;\n    }\n\n    var deviceId = data.deviceId;\n    var softphoneManager = connect.core.getSoftphoneManager();\n\n    try {\n      navigator.mediaDevices.getUserMedia({\n        audio: {\n          deviceId: {\n            exact: deviceId\n          }\n        }\n      }).then(function (newMicrophoneStream) {\n        var newMicrophoneTrack = newMicrophoneStream.getAudioTracks()[0];\n\n        for (var connectionId in localMediaStream) {\n          if (localMediaStream.hasOwnProperty(connectionId)) {\n            var localMedia = localMediaStream[connectionId].stream;\n            var session = softphoneManager.getSession(connectionId); //Replace the audio track in the RtcPeerConnection\n\n            session._pc.getSenders()[0].replaceTrack(newMicrophoneTrack).then(function () {\n              //Replace the audio track in the local media stream (for mute / unmute)\n              softphoneManager.replaceLocalMediaTrack(connectionId, newMicrophoneTrack);\n            });\n          }\n        }\n      });\n    } catch (e) {\n      logger.error(\"Failed to set microphone device \" + deviceId);\n    }\n\n    connect.core.getUpstream().sendUpstream(connect.EventType.BROADCAST, {\n      event: connect.ConfigurationEvents.MICROPHONE_DEVICE_CHANGED,\n      data: {\n        deviceId: deviceId\n      }\n    });\n  };\n\n  var publishSoftphoneFailureLogs = function (rtcSession, reason) {\n    if (reason === connect.RTCErrors.ICE_COLLECTION_TIMEOUT) {\n      var endPointUrl = \"\\n\";\n\n      for (var i = 0; i < rtcSession._iceServers.length; i++) {\n        for (var j = 0; j < rtcSession._iceServers[i].urls.length; j++) {\n          endPointUrl = endPointUrl + rtcSession._iceServers[i].urls[j] + \"\\n\";\n        }\n      }\n\n      publishError(SoftphoneErrorTypes.ICE_COLLECTION_TIMEOUT, \"Ice collection timedout. \", endPointUrl);\n    } else if (reason === connect.RTCErrors.USER_BUSY) {\n      publishError(SoftphoneErrorTypes.USER_BUSY_ERROR, \"Softphone call UserBusy error. \", \"\");\n    } else if (reason === connect.RTCErrors.SIGNALLING_HANDSHAKE_FAILURE) {\n      publishError(SoftphoneErrorTypes.SIGNALLING_HANDSHAKE_FAILURE, \"Handshaking with Signalling Server \" + rtcSession._signalingUri + \" failed. \", rtcSession._signalingUri);\n    } else if (reason === connect.RTCErrors.GUM_TIMEOUT_FAILURE || reason === connect.RTCErrors.GUM_OTHER_FAILURE) {\n      publishError(SoftphoneErrorTypes.MICROPHONE_NOT_SHARED, \"Your microphone is not enabled in your browser. \", \"\");\n    } else if (reason === connect.RTCErrors.SIGNALLING_CONNECTION_FAILURE) {\n      publishError(SoftphoneErrorTypes.SIGNALLING_CONNECTION_FAILURE, \"URL \" + rtcSession._signalingUri + \" cannot be reached. \", rtcSession._signalingUri);\n    } else if (reason === connect.RTCErrors.CALL_NOT_FOUND) {\n      // No need to publish any softphone error for this case. CCP UX will handle this case.\n      logger.error(\"Softphone call failed due to CallNotFoundException.\").sendInternalLogToServer();\n    } else {\n      publishError(SoftphoneErrorTypes.WEBRTC_ERROR, \"webrtc system error. \", \"\");\n    }\n  };\n  /** Parse the JSON encoded web call config into the data it represents. */\n\n\n  var parseCallConfig = function (serializedConfig) {\n    // Our underscore is too old for unescape\n    // https://issues.amazon.com/issues/CSWF-1467\n    var decodedJSON = serializedConfig.replace(/&quot;/g, '\"');\n    return JSON.parse(decodedJSON);\n  };\n\n  var fetchUserMedia = function (callbacksIn) {\n    var callbacks = callbacksIn || {};\n\n    callbacks.success = callbacks.success || function () {};\n\n    callbacks.failure = callbacks.failure || function () {};\n\n    var CONSTRAINT = {\n      audio: true\n    };\n    var promise = null;\n\n    if (typeof Promise !== \"function\") {\n      callbacks.failure(SoftphoneErrorTypes.UNSUPPORTED_BROWSER);\n      return;\n    }\n\n    if (typeof navigator.mediaDevices === \"object\" && typeof navigator.mediaDevices.getUserMedia === \"function\") {\n      promise = navigator.mediaDevices.getUserMedia(CONSTRAINT);\n    } else if (typeof navigator.webkitGetUserMedia === \"function\") {\n      promise = new Promise(function (resolve, reject) {\n        navigator.webkitGetUserMedia(CONSTRAINT, resolve, reject);\n      });\n    } else {\n      callbacks.failure(SoftphoneErrorTypes.UNSUPPORTED_BROWSER);\n      return;\n    }\n\n    promise.then(function (stream) {\n      var audioTracks = stream.getAudioTracks();\n\n      if (audioTracks && audioTracks.length > 0) {\n        callbacks.success(stream);\n      } else {\n        callbacks.failure(SoftphoneErrorTypes.MICROPHONE_NOT_SHARED);\n      }\n    }, function (err) {\n      callbacks.failure(SoftphoneErrorTypes.MICROPHONE_NOT_SHARED);\n    });\n    return promise;\n  };\n\n  var publishError = function (errorType, message, endPointUrl) {\n    logger.error(\"Softphone error occurred : \", errorType, message || \"\").sendInternalLogToServer();\n    connect.core.getUpstream().sendUpstream(connect.EventType.BROADCAST, {\n      event: connect.AgentEvents.SOFTPHONE_ERROR,\n      data: new connect.SoftphoneError(errorType, message, endPointUrl)\n    });\n  };\n\n  var publishSessionFailureTelemetryEvent = function (contactId, reason) {\n    publishTelemetryEvent(\"Softphone Session Failed\", contactId, {\n      failedReason: reason\n    });\n  };\n\n  var publishTelemetryEvent = function (eventName, contactId, data) {\n    if (contactId) {\n      connect.publishMetric({\n        name: eventName,\n        contactId: contactId,\n        data: data\n      });\n    }\n  }; // Publish the contact and agent information in a multiple sessions scenarios\n\n\n  var publishMultipleSessionsEvent = function (eventName, contactId, agentConnectionId) {\n    publishTelemetryEvent(eventName, contactId, [{\n      name: \"AgentConnectionId\",\n      value: agentConnectionId\n    }]);\n    logger.info(\"Publish multiple session error metrics\", eventName, \"contactId \" + contactId, \"agent connectionId \" + agentConnectionId).sendInternalLogToServer();\n  };\n\n  var isBrowserSoftPhoneSupported = function () {\n    // In Opera, the true version is after \"Opera\" or after \"Version\"\n    if (connect.isOperaBrowser() && connect.getOperaBrowserVersion() > 17) {\n      return true;\n    } // In Chrome, the true version is after \"Chrome\"\n    else if (connect.isChromeBrowser() && connect.getChromeBrowserVersion() > 22) {\n      return true;\n    } // In Firefox, the true version is after \"Firefox\"\n    else if (connect.isFirefoxBrowser() && connect.getFirefoxBrowserVersion() > 21) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  var sendSoftphoneMetrics = function (contact) {\n    var streamStats = timeSeriesStreamStatsBuffer.slice();\n    timeSeriesStreamStatsBuffer = [];\n\n    if (streamStats.length > 0) {\n      contact.sendSoftphoneMetrics(streamStats, {\n        success: function () {\n          logger.info(\"sendSoftphoneMetrics success\" + JSON.stringify(streamStats)).sendInternalLogToServer();\n        },\n        failure: function (data) {\n          logger.error(\"sendSoftphoneMetrics failed.\").withObject(data).sendInternalLogToServer();\n        }\n      });\n    }\n  };\n\n  var sendSoftphoneReport = function (contact, report, userAudioStats, remoteAudioStats) {\n    report.streamStats = [addStreamTypeToStats(userAudioStats, AUDIO_INPUT), addStreamTypeToStats(remoteAudioStats, AUDIO_OUTPUT)];\n    var callReport = {\n      callStartTime: report.sessionStartTime,\n      callEndTime: report.sessionEndTime,\n      gumTimeMillis: report.gumTimeMillis,\n      initializationTimeMillis: report.initializationTimeMillis,\n      iceCollectionTimeMillis: report.iceCollectionTimeMillis,\n      signallingConnectTimeMillis: report.signallingConnectTimeMillis,\n      handshakingTimeMillis: report.handshakingTimeMillis,\n      preTalkingTimeMillis: report.preTalkingTimeMillis,\n      talkingTimeMillis: report.talkingTimeMillis,\n      cleanupTimeMillis: report.cleanupTimeMillis,\n      iceCollectionFailure: report.iceCollectionFailure,\n      signallingConnectionFailure: report.signallingConnectionFailure,\n      handshakingFailure: report.handshakingFailure,\n      gumOtherFailure: report.gumOtherFailure,\n      gumTimeoutFailure: report.gumTimeoutFailure,\n      createOfferFailure: report.createOfferFailure,\n      setLocalDescriptionFailure: report.setLocalDescriptionFailure,\n      userBusyFailure: report.userBusyFailure,\n      invalidRemoteSDPFailure: report.invalidRemoteSDPFailure,\n      noRemoteIceCandidateFailure: report.noRemoteIceCandidateFailure,\n      setRemoteDescriptionFailure: report.setRemoteDescriptionFailure,\n      softphoneStreamStatistics: report.streamStats\n    };\n    contact.sendSoftphoneReport(callReport, {\n      success: function () {\n        logger.info(\"sendSoftphoneReport success\" + JSON.stringify(callReport)).sendInternalLogToServer();\n      },\n      failure: function (data) {\n        logger.error(\"sendSoftphoneReport failed.\").withObject(data).sendInternalLogToServer();\n      }\n    });\n  };\n\n  var startStatsCollectionJob = function (rtcSession) {\n    rtpStatsJob = window.setInterval(function () {\n      rtcSession.getUserAudioStats().then(function (stats) {\n        var previousUserStats = aggregatedUserAudioStats;\n        aggregatedUserAudioStats = stats;\n        timeSeriesStreamStatsBuffer.push(getTimeSeriesStats(aggregatedUserAudioStats, previousUserStats, AUDIO_INPUT));\n      }, function (error) {\n        logger.debug(\"Failed to get user audio stats.\", error).sendInternalLogToServer();\n      });\n      rtcSession.getRemoteAudioStats().then(function (stats) {\n        var previousRemoteStats = aggregatedRemoteAudioStats;\n        aggregatedRemoteAudioStats = stats;\n        timeSeriesStreamStatsBuffer.push(getTimeSeriesStats(aggregatedRemoteAudioStats, previousRemoteStats, AUDIO_OUTPUT));\n      }, function (error) {\n        logger.debug(\"Failed to get remote audio stats.\", error).sendInternalLogToServer();\n      });\n    }, 1000);\n  };\n\n  var startStatsReportingJob = function (contact) {\n    reportStatsJob = window.setInterval(function () {\n      sendSoftphoneMetrics(contact);\n    }, statsReportingJobIntervalMs);\n  };\n\n  var initializeParams = function () {\n    aggregatedUserAudioStats = null;\n    aggregatedRemoteAudioStats = null;\n    timeSeriesStreamStatsBuffer = [];\n    rtpStatsJob = null;\n    reportStatsJob = null;\n  };\n\n  var getTimeSeriesStats = function (currentStats, previousStats, streamType) {\n    if (previousStats && currentStats) {\n      var packetsLost = currentStats.packetsLost > previousStats.packetsLost ? currentStats.packetsLost - previousStats.packetsLost : 0;\n      var packetsCount = currentStats.packetsCount > previousStats.packetsCount ? currentStats.packetsCount - previousStats.packetsCount : 0;\n      return new RTPStreamStats(currentStats.timestamp, packetsLost, packetsCount, streamType, currentStats.audioLevel, currentStats.jbMilliseconds, currentStats.rttMilliseconds);\n    } else {\n      return new RTPStreamStats(currentStats.timestamp, currentStats.packetsLost, currentStats.packetsCount, streamType, currentStats.audioLevel, currentStats.jbMilliseconds, currentStats.rttMilliseconds);\n    }\n  };\n\n  var stopJob = function (task) {\n    if (task !== null) {\n      window.clearInterval(task);\n    }\n\n    return null;\n  };\n\n  var stopJobsAndReport = function (contact, sessionReport) {\n    rtpStatsJob = stopJob(rtpStatsJob);\n    reportStatsJob = stopJob(reportStatsJob);\n    sendSoftphoneReport(contact, sessionReport, addStreamTypeToStats(aggregatedUserAudioStats, AUDIO_INPUT), addStreamTypeToStats(aggregatedRemoteAudioStats, AUDIO_OUTPUT));\n    sendSoftphoneMetrics(contact);\n  };\n  /**\n  *   Adding streamtype parameter on top of RTCJS RTStats object.\n  */\n\n\n  var RTPStreamStats = function (timestamp, packetsLost, packetsCount, streamType, audioLevel, jitterBufferMillis, roundTripTimeMillis) {\n    this.softphoneStreamType = streamType;\n    this.timestamp = timestamp;\n    this.packetsLost = packetsLost;\n    this.packetsCount = packetsCount;\n    this.audioLevel = audioLevel;\n    this.jitterBufferMillis = jitterBufferMillis;\n    this.roundTripTimeMillis = roundTripTimeMillis;\n  };\n\n  var addStreamTypeToStats = function (stats, streamType) {\n    stats = stats || {};\n    return new RTPStreamStats(stats.timestamp, stats.packetsLost, stats.packetsCount, streamType, stats.audioLevel);\n  };\n\n  var SoftphoneLogger = function (logger) {\n    this._originalLogger = logger;\n    var self = this;\n\n    this._tee = function (level, method) {\n      return function () {\n        // call the original logger object to output to browser\n        //Connect logger follows %s format to print objects to console.\n        var args = Array.prototype.slice.call(arguments[0]);\n        var format = \"\";\n        args.forEach(function () {\n          format = format + \" %s\";\n        });\n        return method.apply(self._originalLogger, [connect.LogComponent.SOFTPHONE, format].concat(args));\n      };\n    };\n  };\n\n  SoftphoneLogger.prototype.debug = function () {\n    return this._tee(1, this._originalLogger.debug)(arguments);\n  };\n\n  SoftphoneLogger.prototype.info = function () {\n    return this._tee(2, this._originalLogger.info)(arguments);\n  };\n\n  SoftphoneLogger.prototype.log = function () {\n    return this._tee(3, this._originalLogger.log)(arguments);\n  };\n\n  SoftphoneLogger.prototype.warn = function () {\n    return this._tee(4, this._originalLogger.warn)(arguments);\n  };\n\n  SoftphoneLogger.prototype.error = function () {\n    return this._tee(5, this._originalLogger.error)(arguments);\n  };\n\n  connect.SoftphoneManager = SoftphoneManager;\n})();\n/*\n * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\n(function () {\n  var global = this;\n  connect = global.connect || {};\n  global.connect = connect;\n  global.lily = connect;\n  connect.worker = {};\n  var GET_AGENT_TIMEOUT_MS = 30000;\n  var GET_AGENT_RECOVERY_TIMEOUT_MS = 5000;\n  var GET_AGENT_SUCCESS_TIMEOUT_MS = 100;\n  var LOG_BUFFER_CAP_SIZE = 400;\n  var CHECK_AUTH_TOKEN_INTERVAL_MS = 300000; // 5 minuts\n\n  var REFRESH_AUTH_TOKEN_INTERVAL_MS = 10000; // 10 seconds\n\n  var REFRESH_AUTH_TOKEN_MAX_TRY = 4;\n  var GET_AGENT_CONFIGURATION_INTERVAL_MS = 30000;\n  /**-----------------------------------------------------------------------*/\n\n  var MasterTopicCoordinator = function () {\n    this.topicMasterMap = {};\n  };\n\n  MasterTopicCoordinator.prototype.getMaster = function (topic) {\n    connect.assertNotNull(topic, 'topic');\n    return this.topicMasterMap[topic] || null;\n  };\n\n  MasterTopicCoordinator.prototype.setMaster = function (topic, id) {\n    connect.assertNotNull(topic, 'topic');\n    connect.assertNotNull(id, 'id');\n    this.topicMasterMap[topic] = id;\n  };\n\n  MasterTopicCoordinator.prototype.removeMaster = function (id) {\n    connect.assertNotNull(id, 'id');\n    var self = this;\n    connect.entries(this.topicMasterMap).filter(function (entry) {\n      return entry.value === id;\n    }).forEach(function (entry) {\n      delete self.topicMasterMap[entry.key];\n    });\n  };\n  /**---------------------------------------------------------------\n   * class WorkerClient extends ClientBase\n   */\n\n\n  var WorkerClient = function (conduit) {\n    connect.ClientBase.call(this);\n    this.conduit = conduit;\n  };\n\n  WorkerClient.prototype = Object.create(connect.ClientBase.prototype);\n  WorkerClient.prototype.constructor = WorkerClient;\n\n  WorkerClient.prototype._callImpl = function (method, params, callbacks) {\n    var self = this;\n    var request_start = new Date().getTime();\n\n    if (connect.containsValue(connect.AgentAppClientMethods, method)) {\n      connect.core.getAgentAppClient()._callImpl(method, params, {\n        success: function (data) {\n          self._recordAPILatency(method, request_start);\n\n          callbacks.success(data);\n        },\n        failure: function (error) {\n          self._recordAPILatency(method, request_start, error);\n\n          callbacks.failure(error);\n        }\n      });\n    } else {\n      connect.core.getClient()._callImpl(method, params, {\n        success: function (data) {\n          self._recordAPILatency(method, request_start);\n\n          callbacks.success(data);\n        },\n        failure: function (error, data) {\n          self._recordAPILatency(method, request_start, error);\n\n          callbacks.failure(error, data);\n        },\n        authFailure: function () {\n          self._recordAPILatency(method, request_start);\n\n          callbacks.authFailure();\n        },\n        accessDenied: function () {\n          callbacks.accessDenied && callbacks.accessDenied();\n        }\n      });\n    }\n  };\n\n  WorkerClient.prototype._recordAPILatency = function (method, request_start, err) {\n    var request_end = new Date().getTime();\n    var request_time = request_end - request_start;\n\n    this._sendAPIMetrics(method, request_time, err);\n  };\n\n  WorkerClient.prototype._sendAPIMetrics = function (method, time, err) {\n    this.conduit.sendDownstream(connect.EventType.API_METRIC, {\n      name: method,\n      time: time,\n      dimensions: [{\n        name: \"Category\",\n        value: \"API\"\n      }],\n      error: err\n    });\n  };\n  /**-------------------------------------------------------------------------\n   * The object responsible for polling and passing data downstream to all\n   * consumer ports.\n   */\n\n\n  var ClientEngine = function () {\n    var self = this;\n    this.multiplexer = new connect.StreamMultiplexer();\n    this.conduit = new connect.Conduit(\"AmazonConnectSharedWorker\", null, this.multiplexer);\n    this.client = new WorkerClient(this.conduit);\n    this.timeout = null;\n    this.agent = null;\n    this.nextToken = null;\n    this.initData = {};\n    this.portConduitMap = {};\n    this.masterCoord = new MasterTopicCoordinator();\n    this.logsBuffer = [];\n    this.suppress = false;\n    this.forceOffline = false;\n    var webSocketManager = null;\n    connect.rootLogger = new connect.DownstreamConduitLogger(this.conduit);\n    this.conduit.onDownstream(connect.EventType.SEND_LOGS, function (logsToUpload) {\n      // Add softphone logs downstream\n      connect.getLog().pushLogsDownstream(logsToUpload);\n      self.logsBuffer = self.logsBuffer.concat(logsToUpload); //only call API to send logs if buffer reached cap\n\n      if (self.logsBuffer.length > LOG_BUFFER_CAP_SIZE) {\n        self.handleSendLogsRequest(self.logsBuffer);\n      }\n    });\n    this.conduit.onDownstream(connect.EventType.CONFIGURE, function (data) {\n      if (data.authToken && data.authToken !== self.initData.authToken) {\n        self.initData = data;\n        connect.core.init(data); // init only once.\n\n        if (!webSocketManager) {\n          connect.getLog().info(\"Creating a new Websocket connection for CCP\").sendInternalLogToServer();\n          connect.WebSocketManager.setGlobalConfig({\n            loggerConfig: {\n              logger: connect.getLog()\n            }\n          });\n          webSocketManager = connect.WebSocketManager.create();\n          webSocketManager.onInitFailure(function () {\n            self.conduit.sendDownstream(connect.WebSocketEvents.INIT_FAILURE);\n          });\n          webSocketManager.onConnectionOpen(function (response) {\n            self.conduit.sendDownstream(connect.WebSocketEvents.CONNECTION_OPEN, response);\n          });\n          webSocketManager.onConnectionClose(function (response) {\n            self.conduit.sendDownstream(connect.WebSocketEvents.CONNECTION_CLOSE, response);\n          });\n          webSocketManager.onConnectionGain(function () {\n            self.conduit.sendDownstream(connect.AgentEvents.WEBSOCKET_CONNECTION_GAINED);\n            self.conduit.sendDownstream(connect.WebSocketEvents.CONNECTION_GAIN);\n          });\n          webSocketManager.onConnectionLost(function (response) {\n            self.conduit.sendDownstream(connect.AgentEvents.WEBSOCKET_CONNECTION_LOST, response);\n            self.conduit.sendDownstream(connect.WebSocketEvents.CONNECTION_LOST, response);\n          });\n          webSocketManager.onSubscriptionUpdate(function (response) {\n            self.conduit.sendDownstream(connect.WebSocketEvents.SUBSCRIPTION_UPDATE, response);\n          });\n          webSocketManager.onSubscriptionFailure(function (response) {\n            self.conduit.sendDownstream(connect.WebSocketEvents.SUBSCRIPTION_FAILURE, response);\n          });\n          webSocketManager.onAllMessage(function (response) {\n            self.conduit.sendDownstream(connect.WebSocketEvents.ALL_MESSAGE, response);\n          });\n          self.conduit.onDownstream(connect.WebSocketEvents.SEND, function (message) {\n            webSocketManager.sendMessage(message);\n          });\n          self.conduit.onDownstream(connect.WebSocketEvents.SUBSCRIBE, function (topics) {\n            webSocketManager.subscribeTopics(topics);\n          });\n          webSocketManager.init(connect.hitch(self, self.getWebSocketUrl)).then(function (response) {\n            if (response && !response.webSocketConnectionFailed) {\n              // Start polling for agent data.\n              connect.getLog().info(\"Kicking off agent polling\").sendInternalLogToServer();\n              self.pollForAgent();\n              connect.getLog().info(\"Kicking off config polling\").sendInternalLogToServer();\n              self.pollForAgentConfiguration({\n                repeatForever: true\n              });\n              connect.getLog().info(\"Kicking off auth token polling\").sendInternalLogToServer();\n              global.setInterval(connect.hitch(self, self.checkAuthToken), CHECK_AUTH_TOKEN_INTERVAL_MS);\n            } else {\n              if (!connect.webSocketInitFailed) {\n                self.conduit.sendDownstream(connect.WebSocketEvents.INIT_FAILURE);\n                connect.webSocketInitFailed = true;\n              }\n            }\n          });\n        } else {\n          connect.getLog().info(\"Not Initializing a new WebsocketManager instance, since one already exists\").sendInternalLogToServer();\n        }\n      }\n    });\n    this.conduit.onDownstream(connect.EventType.TERMINATE, function () {\n      //upload pending logs before terminating.\n      self.handleSendLogsRequest(self.logsBuffer);\n      connect.core.terminate();\n      self.conduit.sendDownstream(connect.EventType.TERMINATED);\n    });\n    this.conduit.onDownstream(connect.EventType.SYNCHRONIZE, function () {\n      self.conduit.sendDownstream(connect.EventType.ACKNOWLEDGE);\n    });\n    this.conduit.onDownstream(connect.EventType.BROADCAST, function (data) {\n      self.conduit.sendDownstream(data.event, data.data);\n    });\n    /**\n     * Called when a consumer port connects to this SharedWorker.\n     * Let's add them to our multiplexer.\n     */\n\n    global.onconnect = function (event) {\n      var port = event.ports[0];\n      var stream = new connect.PortStream(port);\n      self.multiplexer.addStream(stream);\n      port.start();\n      var portConduit = new connect.Conduit(stream.getId(), null, stream);\n      portConduit.sendDownstream(connect.EventType.ACKNOWLEDGE, {\n        id: stream.getId()\n      });\n      self.portConduitMap[stream.getId()] = portConduit;\n      self.conduit.sendDownstream(connect.EventType.UPDATE_CONNECTED_CCPS, {\n        length: Object.keys(self.portConduitMap).length\n      });\n\n      if (self.agent !== null) {\n        self.updateAgent();\n      }\n\n      portConduit.onDownstream(connect.EventType.API_REQUEST, connect.hitch(self, self.handleAPIRequest, portConduit));\n      portConduit.onDownstream(connect.EventType.MASTER_REQUEST, connect.hitch(self, self.handleMasterRequest, portConduit, stream.getId()));\n      portConduit.onDownstream(connect.EventType.RELOAD_AGENT_CONFIGURATION, connect.hitch(self, self.pollForAgentConfiguration));\n      portConduit.onDownstream(connect.EventType.CLOSE, function () {\n        self.multiplexer.removeStream(stream);\n        delete self.portConduitMap[stream.getId()];\n        self.masterCoord.removeMaster(stream.getId());\n        self.conduit.sendDownstream(connect.EventType.UPDATE_CONNECTED_CCPS, {\n          length: Object.keys(self.portConduitMap).length\n        });\n      });\n    };\n  };\n\n  ClientEngine.prototype.pollForAgent = function () {\n    var self = this;\n    var onAuthFail = connect.hitch(self, self.handleAuthFail);\n    this.client.call(connect.ClientMethods.GET_AGENT_SNAPSHOT, {\n      nextToken: self.nextToken,\n      timeout: GET_AGENT_TIMEOUT_MS\n    }, {\n      success: function (data) {\n        try {\n          self.agent = self.agent || {};\n          self.agent.snapshot = data.snapshot;\n          self.agent.snapshot.localTimestamp = connect.now();\n          self.agent.snapshot.skew = self.agent.snapshot.snapshotTimestamp - self.agent.snapshot.localTimestamp;\n          self.nextToken = data.nextToken;\n          connect.getLog().trace(\"GET_AGENT_SNAPSHOT succeeded.\").withObject(data).sendInternalLogToServer();\n          self.updateAgent();\n        } catch (e) {\n          connect.getLog().error(\"Long poll failed to update agent.\").withObject(data).withException(e).sendInternalLogToServer();\n        } finally {\n          global.setTimeout(connect.hitch(self, self.pollForAgent), GET_AGENT_SUCCESS_TIMEOUT_MS);\n        }\n      },\n      failure: function (err, data) {\n        try {\n          connect.getLog().error(\"Failed to get agent data.\").sendInternalLogToServer().withObject({\n            err: err,\n            data: data\n          });\n        } finally {\n          global.setTimeout(connect.hitch(self, self.pollForAgent), GET_AGENT_RECOVERY_TIMEOUT_MS);\n        }\n      },\n      authFailure: function () {\n        onAuthFail();\n      },\n      accessDenied: connect.hitch(self, self.handleAccessDenied)\n    });\n  };\n\n  ClientEngine.prototype.pollForAgentConfiguration = function (paramsIn) {\n    var self = this;\n    var params = paramsIn || {};\n    var onAuthFail = connect.hitch(self, self.handleAuthFail);\n    this.client.call(connect.ClientMethods.GET_AGENT_CONFIGURATION, {}, {\n      success: function (data) {\n        var configuration = data.configuration;\n        self.pollForAgentPermissions(configuration);\n        self.pollForAgentStates(configuration);\n        self.pollForDialableCountryCodes(configuration);\n        self.pollForRoutingProfileQueues(configuration);\n\n        if (params.repeatForever) {\n          global.setTimeout(connect.hitch(self, self.pollForAgentConfiguration, params), GET_AGENT_CONFIGURATION_INTERVAL_MS);\n        }\n      },\n      failure: function (err, data) {\n        try {\n          connect.getLog().error(\"Failed to fetch agent configuration data.\").sendInternalLogToServer().withObject({\n            err: err,\n            data: data\n          });\n        } finally {\n          if (params.repeatForever) {\n            global.setTimeout(connect.hitch(self, self.pollForAgentConfiguration), GET_AGENT_CONFIGURATION_INTERVAL_MS, params);\n          }\n        }\n      },\n      authFailure: function () {\n        onAuthFail();\n      },\n      accessDenied: connect.hitch(self, self.handleAccessDenied)\n    });\n  };\n\n  ClientEngine.prototype.pollForAgentStates = function (configuration, paramsIn) {\n    var self = this;\n    var params = paramsIn || {};\n    params.maxResults = params.maxResults || connect.DEFAULT_BATCH_SIZE;\n    this.client.call(connect.ClientMethods.GET_AGENT_STATES, {\n      nextToken: params.nextToken || null,\n      maxResults: params.maxResults\n    }, {\n      success: function (data) {\n        if (data.nextToken) {\n          self.pollForAgentStates(configuration, {\n            states: (params.states || []).concat(data.states),\n            nextToken: data.nextToken,\n            maxResults: params.maxResults\n          });\n        } else {\n          configuration.agentStates = (params.states || []).concat(data.states);\n          self.updateAgentConfiguration(configuration);\n        }\n      },\n      failure: function (err, data) {\n        connect.getLog().error(\"Failed to fetch agent states list.\").sendInternalLogToServer().withObject({\n          err: err,\n          data: data\n        });\n      },\n      authFailure: connect.hitch(self, self.handleAuthFail),\n      accessDenied: connect.hitch(self, self.handleAccessDenied)\n    });\n  };\n\n  ClientEngine.prototype.pollForAgentPermissions = function (configuration, paramsIn) {\n    var self = this;\n    var params = paramsIn || {};\n    params.maxResults = params.maxResults || connect.DEFAULT_BATCH_SIZE;\n    this.client.call(connect.ClientMethods.GET_AGENT_PERMISSIONS, {\n      nextToken: params.nextToken || null,\n      maxResults: params.maxResults\n    }, {\n      success: function (data) {\n        if (data.nextToken) {\n          self.pollForAgentPermissions(configuration, {\n            permissions: (params.permissions || []).concat(data.permissions),\n            nextToken: data.nextToken,\n            maxResults: params.maxResults\n          });\n        } else {\n          configuration.permissions = (params.permissions || []).concat(data.permissions);\n          self.updateAgentConfiguration(configuration);\n        }\n      },\n      failure: function (err, data) {\n        connect.getLog().error(\"Failed to fetch agent permissions list.\").sendInternalLogToServer().withObject({\n          err: err,\n          data: data\n        });\n      },\n      authFailure: connect.hitch(self, self.handleAuthFail),\n      accessDenied: connect.hitch(self, self.handleAccessDenied)\n    });\n  };\n\n  ClientEngine.prototype.pollForDialableCountryCodes = function (configuration, paramsIn) {\n    var self = this;\n    var params = paramsIn || {};\n    params.maxResults = params.maxResults || connect.DEFAULT_BATCH_SIZE;\n    this.client.call(connect.ClientMethods.GET_DIALABLE_COUNTRY_CODES, {\n      nextToken: params.nextToken || null,\n      maxResults: params.maxResults\n    }, {\n      success: function (data) {\n        if (data.nextToken) {\n          self.pollForDialableCountryCodes(configuration, {\n            countryCodes: (params.countryCodes || []).concat(data.countryCodes),\n            nextToken: data.nextToken,\n            maxResults: params.maxResults\n          });\n        } else {\n          configuration.dialableCountries = (params.countryCodes || []).concat(data.countryCodes);\n          self.updateAgentConfiguration(configuration);\n        }\n      },\n      failure: function (err, data) {\n        connect.getLog().error(\"Failed to fetch dialable country codes list.\").sendInternalLogToServer().withObject({\n          err: err,\n          data: data\n        });\n      },\n      authFailure: connect.hitch(self, self.handleAuthFail),\n      accessDenied: connect.hitch(self, self.handleAccessDenied)\n    });\n  };\n\n  ClientEngine.prototype.pollForRoutingProfileQueues = function (configuration, paramsIn) {\n    var self = this;\n    var params = paramsIn || {};\n    params.maxResults = params.maxResults || connect.DEFAULT_BATCH_SIZE;\n    this.client.call(connect.ClientMethods.GET_ROUTING_PROFILE_QUEUES, {\n      routingProfileARN: configuration.routingProfile.routingProfileARN,\n      nextToken: params.nextToken || null,\n      maxResults: params.maxResults\n    }, {\n      success: function (data) {\n        if (data.nextToken) {\n          self.pollForRoutingProfileQueues(configuration, {\n            countryCodes: (params.queues || []).concat(data.queues),\n            nextToken: data.nextToken,\n            maxResults: params.maxResults\n          });\n        } else {\n          configuration.routingProfile.queues = (params.queues || []).concat(data.queues);\n          self.updateAgentConfiguration(configuration);\n        }\n      },\n      failure: function (err, data) {\n        connect.getLog().error(\"Failed to fetch routing profile queues list.\").sendInternalLogToServer().withObject({\n          err: err,\n          data: data\n        });\n      },\n      authFailure: connect.hitch(self, self.handleAuthFail),\n      accessDenied: connect.hitch(self, self.handleAccessDenied)\n    });\n  };\n\n  ClientEngine.prototype.handleAPIRequest = function (portConduit, request) {\n    var self = this;\n    this.client.call(request.method, request.params, {\n      success: function (data) {\n        var response = connect.EventFactory.createResponse(connect.EventType.API_RESPONSE, request, data);\n        portConduit.sendDownstream(response.event, response);\n      },\n      failure: function (err, data) {\n        var response = connect.EventFactory.createResponse(connect.EventType.API_RESPONSE, request, data, JSON.stringify(err));\n        portConduit.sendDownstream(response.event, response);\n        connect.getLog().error(\"'%s' API request failed\", request.method).withObject({\n          request: self.filterAuthToken(request),\n          response: response\n        }).withException(err).sendInternalLogToServer();\n      },\n      authFailure: connect.hitch(self, self.handleAuthFail)\n    });\n  };\n  /**\n   * Handle incoming master query or modification requests from connected tab ports.\n   */\n\n\n  ClientEngine.prototype.handleMasterRequest = function (portConduit, portId, request) {\n    var multiplexerConduit = this.conduit;\n    var response = null;\n\n    switch (request.method) {\n      case connect.MasterMethods.BECOME_MASTER:\n        var masterId = this.masterCoord.getMaster(request.params.topic);\n        var takeOver = Boolean(masterId) && masterId !== portId;\n        this.masterCoord.setMaster(request.params.topic, portId);\n        response = connect.EventFactory.createResponse(connect.EventType.MASTER_RESPONSE, request, {\n          masterId: portId,\n          takeOver: takeOver,\n          topic: request.params.topic\n        });\n\n        if (takeOver) {\n          multiplexerConduit.sendDownstream(response.event, response);\n        }\n\n        break;\n\n      case connect.MasterMethods.CHECK_MASTER:\n        var masterId = this.masterCoord.getMaster(request.params.topic);\n\n        if (!masterId && !request.params.shouldNotBecomeMasterIfNone) {\n          this.masterCoord.setMaster(request.params.topic, portId);\n          masterId = portId;\n        }\n\n        response = connect.EventFactory.createResponse(connect.EventType.MASTER_RESPONSE, request, {\n          masterId: masterId,\n          isMaster: portId === masterId,\n          topic: request.params.topic\n        });\n        break;\n\n      default:\n        throw new Error(\"Unknown master method: \" + request.method);\n    }\n\n    portConduit.sendDownstream(response.event, response);\n  };\n\n  ClientEngine.prototype.updateAgentConfiguration = function (configuration) {\n    if (configuration.permissions && configuration.dialableCountries && configuration.agentStates && configuration.routingProfile.queues) {\n      this.agent = this.agent || {};\n      this.agent.configuration = configuration;\n      this.updateAgent();\n    } else {\n      connect.getLog().trace(\"Waiting to update agent configuration until all config data has been fetched.\").sendInternalLogToServer();\n    }\n  };\n\n  ClientEngine.prototype.updateAgent = function () {\n    if (!this.agent) {\n      connect.getLog().trace(\"Waiting to update agent until the agent has been fully constructed.\").sendInternalLogToServer();\n    } else if (!this.agent.snapshot) {\n      connect.getLog().trace(\"Waiting to update agent until the agent snapshot is available.\").sendInternalLogToServer();\n    } else if (!this.agent.configuration) {\n      connect.getLog().trace(\"Waiting to update agent until the agent configuration is available.\").sendInternalLogToServer();\n    } else {\n      // Alias some of the properties for backwards compatibility.\n      this.agent.snapshot.status = this.agent.state; // Sort the contacts on the timestamp\n\n      if (this.agent.snapshot.contacts && this.agent.snapshot.contacts.length > 1) {\n        this.agent.snapshot.contacts.sort(function (contactA, contactB) {\n          return contactA.state.timestamp.getTime() - contactB.state.timestamp.getTime();\n        });\n      }\n\n      this.agent.snapshot.contacts.forEach(function (contact) {\n        contact.status = contact.state;\n        contact.connections.forEach(function (connection) {\n          connection.address = connection.endpoint;\n        });\n      });\n      this.agent.configuration.routingProfile.defaultOutboundQueue.queueId = this.agent.configuration.routingProfile.defaultOutboundQueue.queueARN;\n      this.agent.configuration.routingProfile.queues.forEach(function (queue) {\n        queue.queueId = queue.queueARN;\n      });\n      this.agent.snapshot.contacts.forEach(function (contact) {\n        //contact.queue is null when monitoring\n        if (contact.queue !== undefined) {\n          contact.queue.queueId = contact.queue.queueARN;\n        }\n      });\n      this.agent.configuration.routingProfile.routingProfileId = this.agent.configuration.routingProfile.routingProfileARN;\n      this.conduit.sendDownstream(connect.AgentEvents.UPDATE, this.agent);\n    }\n  };\n  /**\n   * Provides a websocket url through the create_transport API.\n   * @returns a promise which, upon success, returns the response from the createTransport API.\n   */\n\n\n  ClientEngine.prototype.getWebSocketUrl = function () {\n    var self = this;\n    var client = connect.core.getClient();\n    var onAuthFail = connect.hitch(self, self.handleAuthFail);\n    var onAccessDenied = connect.hitch(self, self.handleAccessDenied);\n    return new Promise(function (resolve, reject) {\n      client.call(connect.ClientMethods.CREATE_TRANSPORT, {\n        transportType: connect.TRANSPORT_TYPES.WEB_SOCKET\n      }, {\n        success: function (data) {\n          connect.getLog().info(\"getWebSocketUrl succeeded\").sendInternalLogToServer();\n          resolve(data);\n        },\n        failure: function (err, data) {\n          connect.getLog().error(\"getWebSocketUrl failed\").sendInternalLogToServer().withObject({\n            err: err,\n            data: data\n          });\n          reject({\n            reason: 'getWebSocketUrl failed',\n            _debug: err\n          });\n        },\n        authFailure: function () {\n          connect.getLog().error(\"getWebSocketUrl Auth Failure\").sendInternalLogToServer();\n          reject(Error(\"Authentication failed while getting getWebSocketUrl\"));\n          onAuthFail();\n        },\n        accessDenied: function () {\n          connect.getLog().error(\"getWebSocketUrl Access Denied Failure\").sendInternalLogToServer();\n          reject(Error(\"Access Denied Failure while getting getWebSocketUrl\"));\n          onAccessDenied();\n        }\n      });\n    });\n  };\n  /**\n    * Send a message downstream to all consumers when we detect that authentication\n    * against one of our APIs has failed.\n    */\n\n\n  ClientEngine.prototype.handleSendLogsRequest = function () {\n    var self = this;\n    var logEvents = [];\n    var logsToSend = self.logsBuffer.slice();\n    self.logsBuffer = [];\n    logsToSend.forEach(function (log) {\n      logEvents.push({\n        timestamp: log.time,\n        component: log.component,\n        message: log.text\n      });\n    });\n    this.client.call(connect.ClientMethods.SEND_CLIENT_LOGS, {\n      logEvents: logEvents\n    }, {\n      success: function (data) {\n        connect.getLog().info(\"SendLogs request succeeded.\").sendInternalLogToServer();\n      },\n      failure: function (err, data) {\n        connect.getLog().error(\"SendLogs request failed.\").withObject(data).withException(err).sendInternalLogToServer();\n      },\n      authFailure: connect.hitch(self, self.handleAuthFail)\n    });\n  };\n\n  ClientEngine.prototype.handleAuthFail = function () {\n    var self = this;\n    self.conduit.sendDownstream(connect.EventType.AUTH_FAIL);\n  };\n\n  ClientEngine.prototype.handleAccessDenied = function () {\n    var self = this;\n    self.conduit.sendDownstream(connect.EventType.ACCESS_DENIED);\n  };\n\n  ClientEngine.prototype.checkAuthToken = function () {\n    var self = this;\n    var expirationDate = new Date(self.initData.authTokenExpiration);\n    var currentTimeStamp = new Date().getTime();\n    var thirtyMins = 30 * 60 * 1000; // refresh token 30 minutes before expiration\n\n    if (expirationDate.getTime() < currentTimeStamp + thirtyMins) {\n      connect.getLog().info(\"Auth token expires at \" + expirationDate + \" Start refreshing token with retry.\").sendInternalLogToServer();\n      connect.backoff(connect.hitch(self, self.authorize), REFRESH_AUTH_TOKEN_INTERVAL_MS, REFRESH_AUTH_TOKEN_MAX_TRY);\n    }\n  };\n\n  ClientEngine.prototype.authorize = function (callbacks) {\n    var self = this;\n    connect.core.authorize(this.initData.authorizeEndpoint).then(function (response) {\n      var expiration = new Date(response.expiration);\n      connect.getLog().info(\"Authorization succeeded and the token expires at %s\", expiration).sendInternalLogToServer();\n      self.initData.authToken = response.accessToken;\n      self.initData.authTokenExpiration = expiration;\n      connect.core.initClient(self.initData);\n      connect.core.initAgentAppClient(self.initData);\n      callbacks.success();\n    }).catch(function (response) {\n      connect.getLog().error(\"Authorization failed with code %s\", response.status).sendInternalLogToServer();\n\n      if (response.status === 401) {\n        self.handleAuthFail();\n      } else {\n        callbacks.failure();\n      }\n    });\n  };\n  /**\n   * Filter the 'authentication' field of the request params from the given API_REQUEST event.\n   */\n\n\n  ClientEngine.prototype.filterAuthToken = function (request) {\n    var new_request = {};\n\n    for (var keyA in request) {\n      if (keyA === 'params') {\n        var new_params = {};\n\n        for (var keyB in request.params) {\n          if (keyB !== 'authentication') {\n            new_params[keyB] = request.params[keyB];\n          }\n        }\n\n        new_request.params = new_params;\n      } else {\n        new_request[keyA] = request[keyA];\n      }\n    }\n\n    return new_request;\n  };\n  /**-----------------------------------------------------------------------*/\n\n\n  connect.worker.main = function () {\n    connect.worker.clientEngine = new ClientEngine();\n  };\n})();\n/*\n * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Amazon Software License (the \"License\"). You may not use\n * this file except in compliance with the License. A copy of the License is\n * located at\n *\n *    http://aws.amazon.com/asl/\n *\n * or in the \"license\" file accompanying this file. This file is distributed\n * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express\n * or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n\n\n(function () {\n  var global = this;\n  connect = global.connect || {};\n  global.connect = connect;\n\n  connect.ChatMediaController = function (mediaInfo, metadata) {\n    var logger = connect.getLog();\n    var logComponent = connect.LogComponent.CHAT;\n\n    var createMediaInstance = function () {\n      publishTelemetryEvent(\"Chat media controller init\", mediaInfo.contactId);\n      logger.info(logComponent, \"Chat media controller init\").withObject(mediaInfo).sendInternalLogToServer();\n      connect.ChatSession.setGlobalConfig({\n        loggerConfig: {\n          logger: logger\n        },\n        region: metadata.region\n      });\n      /** Could be also CUSTOMER -  For now we are creating only Agent connection media object */\n\n      var controller = connect.ChatSession.create({\n        chatDetails: mediaInfo,\n        type: \"AGENT\",\n        websocketManager: connect.core.getWebSocketManager()\n      });\n      trackChatConnectionStatus(controller);\n      return controller.connect().then(function (data) {\n        logger.info(logComponent, \"Chat Session Successfully established for contactId %s\", mediaInfo.contactId).sendInternalLogToServer();\n        publishTelemetryEvent(\"Chat Session Successfully established\", mediaInfo.contactId);\n        return controller;\n      }).catch(function (error) {\n        logger.error(logComponent, \"Chat Session establishement failed for contact %s\", mediaInfo.contactId).withException(error).sendInternalLogToServer();\n        publishTelemetryEvent(\"Chat Session establishement failed\", mediaInfo.contactId, error);\n        throw error;\n      });\n    };\n\n    var publishTelemetryEvent = function (eventName, data) {\n      connect.publishMetric({\n        name: eventName,\n        contactId: mediaInfo.contactId,\n        data: data || mediaInfo\n      });\n    };\n\n    var trackChatConnectionStatus = function (controller) {\n      controller.onConnectionBroken(function (data) {\n        logger.error(logComponent, \"Chat Session connection broken\").withException(data).sendInternalLogToServer();\n        publishTelemetryEvent(\"Chat Session connection broken\", data);\n      });\n      controller.onConnectionEstablished(function (data) {\n        logger.info(logComponent, \"Chat Session connection established\").withObject(data).sendInternalLogToServer();\n        publishTelemetryEvent(\"Chat Session connection established\", data);\n      });\n    };\n\n    return {\n      get: function () {\n        return createMediaInstance();\n      }\n    };\n  };\n})();\n/*\n * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Amazon Software License (the \"License\"). You may not use\n * this file except in compliance with the License. A copy of the License is\n * located at\n *\n *    http://aws.amazon.com/asl/\n *\n * or in the \"license\" file accompanying this file. This file is distributed\n * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express\n * or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n\n\n(function () {\n  var global = this;\n  connect = global.connect || {};\n  global.connect = connect;\n\n  connect.MediaFactory = function (params) {\n    /** controller holder */\n    var mediaControllers = {};\n    var toBeDestroyed = new Set();\n    var logger = connect.getLog();\n    var logComponent = connect.LogComponent.CHAT;\n    var metadata = connect.merge({}, params) || {};\n    metadata.region = metadata.region || \"us-west-2\"; // Default it to us-west-2\n\n    var getMediaController = function (connectionObj) {\n      var connectionId = connectionObj.getConnectionId();\n      var mediaInfo = connectionObj.getMediaInfo();\n      /** if we do not have the media info then just reject the request */\n\n      if (!mediaInfo) {\n        logger.error(logComponent, \"Media info does not exist for a media type %s\", connectionObj.getMediaType()).withObject(connectionObj).sendInternalLogToServer();\n        return Promise.reject(\"Media info does not exist for this connection\");\n      }\n\n      if (!mediaControllers[connectionId]) {\n        logger.info(logComponent, \"media controller of type %s init\", connectionObj.getMediaType()).withObject(connectionObj).sendInternalLogToServer();\n\n        switch (connectionObj.getMediaType()) {\n          case connect.MediaType.CHAT:\n            return mediaControllers[connectionId] = new connect.ChatMediaController(connectionObj.getMediaInfo(), metadata).get();\n\n          case connect.MediaType.SOFTPHONE:\n            return mediaControllers[connectionId] = new connect.SoftphoneMediaController(connectionObj.getMediaInfo()).get();\n\n          case connect.MediaType.TASK:\n            return mediaControllers[connectionId] = new connect.TaskMediaController(connectionObj.getMediaInfo()).get();\n\n          default:\n            logger.error(logComponent, \"Unrecognized media type %s \", connectionObj.getMediaType()).sendInternalLogToServer();\n            return Promise.reject();\n        }\n      } else {\n        return mediaControllers[connectionId];\n      }\n    };\n    /** Check all the active states for the connection */\n\n\n    var ifConnectionActive = function (connectionObj) {\n      return connectionObj.isActive();\n    };\n\n    var get = function (connectionObj) {\n      if (ifConnectionActive(connectionObj)) {\n        return getMediaController(connectionObj);\n      } else {\n        destroy(connectionObj.getConnectionId());\n        return Promise.reject(\"Media Controller is no longer available for this connection\");\n      }\n    };\n\n    var destroy = function (connectionId) {\n      if (mediaControllers[connectionId] && !toBeDestroyed.has(connectionId)) {\n        logger.info(logComponent, \"Destroying mediaController for %s\", connectionId);\n        toBeDestroyed.add(connectionId);\n        mediaControllers[connectionId].then(function () {\n          if (typeof controller.cleanUp === \"function\") controller.cleanUp();\n          delete mediaControllers[connectionId];\n          toBeDestroyed.delete(connectionId);\n        }).catch(function () {\n          delete mediaControllers[connectionId];\n          toBeDestroyed.delete(connectionId);\n        });\n      }\n    };\n\n    return {\n      get: get,\n      destroy: destroy\n    };\n  };\n})();\n/*\n * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Amazon Software License (the \"License\"). You may not use\n * this file except in compliance with the License. A copy of the License is\n * located at\n *\n *    http://aws.amazon.com/asl/\n *\n * or in the \"license\" file accompanying this file. This file is distributed\n * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express\n * or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n\n\n(function () {\n  var global = this;\n  connect = global.connect || {};\n  global.connect = connect; // TODO move softphone implementations here - Wil do this for GA\n\n  connect.SoftphoneMediaController = function (mediaInfo) {\n    return {\n      get: function () {\n        return Promise.resolve(mediaInfo);\n      }\n    };\n  };\n})();\n/*\n * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Amazon Software License (the \"License\"). You may not use\n * this file except in compliance with the License. A copy of the License is\n * located at\n *\n *    http://aws.amazon.com/asl/\n *\n * or in the \"license\" file accompanying this file. This file is distributed\n * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express\n * or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n\n\n(function () {\n  var global = this;\n  connect = global.connect || {};\n  global.connect = connect;\n\n  connect.TaskMediaController = function (mediaInfo) {\n    var logger = connect.getLog();\n    var logComponent = connect.LogComponent.TASK;\n\n    var createMediaInstance = function () {\n      publishTelemetryEvent(\"Task media controller init\", mediaInfo.contactId);\n      logger.info(logComponent, \"Task media controller init\").withObject(mediaInfo);\n      var controller = connect.TaskSession.create({\n        contactId: mediaInfo.contactId,\n        initialContactId: mediaInfo.initialContactId,\n        websocketManager: connect.core.getWebSocketManager()\n      });\n      trackTaskConnectionStatus(controller);\n      return controller.connect().then(function () {\n        logger.info(logComponent, \"Task Session Successfully established for contactId %s\", mediaInfo.contactId);\n        publishTelemetryEvent(\"Task Session Successfully established\", mediaInfo.contactId);\n        return controller;\n      }).catch(function (error) {\n        logger.error(logComponent, \"Task Session establishement failed for contact %s\", mediaInfo.contactId).withException(error);\n        publishTelemetryEvent(\"Chat Session establishement failed\", mediaInfo.contactId, error);\n        throw error;\n      });\n    };\n\n    var publishTelemetryEvent = function (eventName, data) {\n      connect.publishMetric({\n        name: eventName,\n        contactId: mediaInfo.contactId,\n        data: data || mediaInfo\n      });\n    };\n\n    var trackTaskConnectionStatus = function (controller) {\n      controller.onConnectionBroken(function (data) {\n        logger.error(logComponent, \"Task Session connection broken\").withException(data);\n        publishTelemetryEvent(\"Task Session connection broken\", data);\n      });\n      controller.onConnectionEstablished(function (data) {\n        logger.info(logComponent, \"Task Session connection established\").withObject(data);\n        publishTelemetryEvent(\"Task Session connection established\", data);\n      });\n    };\n\n    return {\n      get: function () {\n        return createMediaInstance();\n      }\n    };\n  };\n})();\n\n(function () {\n  var global = this;\n  connect = global.connect || {};\n  global.connect = connect;\n  global.lily = connect;\n  connect.agentApp = {};\n  var APP = {\n    CCP: 'ccp'\n  };\n  connect.agentApp.initCCP = connect.core.initCCP;\n\n  connect.agentApp.isInitialized = function (instanceAlias) {};\n\n  connect.agentApp.initAppCommunication = function (iframeId, endpoint) {\n    var iframe = document.getElementById(iframeId);\n    var iframeConduit = new connect.IFrameConduit(endpoint, window, iframe);\n    var BROADCAST_TYPE = [connect.AgentEvents.UPDATE, connect.ContactEvents.VIEW, connect.EventType.ACKNOWLEDGE, connect.EventType.TERMINATED, connect.TaskEvents.CREATED];\n    iframe.addEventListener('load', function (e) {\n      BROADCAST_TYPE.forEach(function (type) {\n        connect.core.getUpstream().onUpstream(type, function (data) {\n          iframeConduit.sendUpstream(type, data);\n        });\n      });\n    });\n  };\n\n  var getConnectUrl = function (ccpUrl) {\n    var pos = ccpUrl.indexOf('ccp-v2');\n    return ccpUrl.slice(0, pos - 1);\n  };\n\n  var signOutThroughCCP = function (ccpUrl) {\n    var logoutUrl = getConnectUrl(ccpUrl) + '/logout';\n    return connect.fetch(logoutUrl, {\n      credentials: 'include'\n    }).then(function () {\n      var eventBus = connect.core.getEventBus();\n      eventBus.trigger(connect.EventType.TERMINATE);\n      return true;\n    }).catch(function (e) {\n      connect.getLog().error('An error occured on logout.' + e).withException(e);\n      window.location.href = logoutUrl;\n      return false;\n    });\n  };\n\n  var signInThroughinitCCP = function (ccpUrl, container, config) {\n    var defaultParams = {\n      ccpUrl: ccpUrl,\n      ccpLoadTimeout: 10000,\n      loginPopup: true,\n      loginUrl: getConnectUrl(ccpUrl) + '/login',\n      softphone: {\n        allowFramedSoftphone: true,\n        disableRingtone: false\n      }\n    };\n    var ccpParams = connect.merge(defaultParams, config.ccpParams);\n    connect.core.initCCP(container, ccpParams);\n  };\n\n  connect.agentApp.initApp = function (name, containerId, appUrl, config) {\n    config = config ? config : {};\n    var endpoint = appUrl.endsWith('/') ? appUrl : appUrl + '/';\n    var registerConfig = {\n      endpoint: endpoint,\n      style: config.style\n    };\n    connect.agentApp.AppRegistry.register(name, registerConfig, document.getElementById(containerId));\n    connect.agentApp.AppRegistry.start(name, function (moduleData) {\n      var endpoint = moduleData.endpoint;\n      var containerDOM = moduleData.containerDOM;\n      return {\n        init: function () {\n          if (name === APP.CCP) return signInThroughinitCCP(endpoint, containerDOM, config);\n          return connect.agentApp.initAppCommunication(name, endpoint);\n        },\n        destroy: function () {\n          if (name === APP.CCP) return signOutThroughCCP(endpoint);\n          return null;\n        }\n      };\n    });\n  };\n\n  connect.agentApp.stopApp = function (name) {\n    return connect.agentApp.AppRegistry.stop(name);\n  };\n})();\n\n(function () {\n  var global = this;\n  connect = global.connect || {};\n  global.connect = connect;\n  var APP = {\n    CCP: 'ccp'\n  };\n\n  function AppRegistry() {\n    var moduleData = {};\n\n    var makeAppIframe = function (appName, endpoint, style) {\n      var iframe = document.createElement('iframe');\n      iframe.src = endpoint;\n      iframe.style = style || 'width: 100%; height:100%;';\n      iframe.id = appName;\n      iframe['aria-label'] = appName;\n      iframe.setAttribute(\"sandbox\", \"allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts\"); // TODO: Update sandbox option for 3P widget\n\n      return iframe;\n    };\n\n    return {\n      register: function (appName, config, containerDOM) {\n        moduleData[appName] = {\n          containerDOM: containerDOM,\n          endpoint: config.endpoint,\n          style: config.style,\n          instance: undefined\n        };\n      },\n      start: function (appName, creator) {\n        if (!moduleData[appName]) return;\n        var containerDOM = moduleData[appName].containerDOM;\n        var endpoint = moduleData[appName].endpoint;\n        var style = moduleData[appName].style;\n\n        if (appName !== APP.CCP) {\n          var app = makeAppIframe(appName, endpoint, style);\n          containerDOM.appendChild(app);\n        }\n\n        moduleData[appName].instance = creator(moduleData[appName]);\n        return moduleData[appName].instance.init();\n      },\n      stop: function (appName) {\n        if (!moduleData[appName]) return;\n        var data = moduleData[appName];\n        var app = data.containerDOM.querySelector('iframe');\n        data.containerDOM.removeChild(app);\n        var result;\n\n        if (data.instance) {\n          result = data.instance.destroy();\n          delete data.instance;\n        }\n\n        return result;\n      }\n    };\n  }\n\n  global.connect.agentApp.AppRegistry = AppRegistry();\n})();","map":null,"metadata":{},"sourceType":"script"}